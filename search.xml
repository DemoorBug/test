<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mac hyper key 仅需要使用hammerspoon就可实现, 可配合Alfred, 不需要借助Karabiner-Elements 和 BetterTouchTool | Mac hyper key only requires hammerspoon, works with Alfred and does not require Karabiner-Elements or BetterTouchTool.]]></title>
    <url>%2Fblog%2F2022%2F02%2F18%2FMac-hyper-key%2F</url>
    <content type="text"><![CDATA[为什么不使用Karabiner-Elements 和 BetterTouchToolKarabiner-Elements我一直在使用Karabiner-Elements软件绑定我的键位以及设置Hyper key, 但是有时候这个软件会出bug,比如说偶尔开机会导致软件的映射全部失效,必须重新安装或者重启电脑,这真的很烦人,并且软件更新频率很低, 我这个bug已经好几个月没有解决了,索性就换一款类似产品用,不然太糟心了BetterTouchTool还是bug问题,我是将Caps_lock映射为Control,Control映射为Caps_lock,Hyper key我是用的Caps_lock映射的(这里可能有点绕),在Karabiner-Elements中功能是正常的,大家各司其职,但是呢这款软件会把以上两个键位全部映射为Hyper key,所以最后导致放弃,软件大概有100m左右,我就是要一个小功能而已,完全没必要,折腾了一小时无果卸载了 用hidutil 和 hammerspoon 实现Hyper keyhidutil首先打开这个网址hidutil key remapping generator for MacOS 选择From key,To key设置自己需要映射的快捷键,我这里遇到一个坑,就是left_command实际上映射的是右边的command的键,这里大家最好自己实践一下left_command escape 这里实际上映射的是右commandapplication fn 因为用的是win键盘,mac上这个键没有实际意义,重新映射一个fn用caps_lock left_controlleft_control f18 这个f18是为了后面映射Hyper key做准备的,你可以把自己喜欢的键位映射为f13-f19 这是我的键位映射xml,映射好自己的键位后,点击页面的Copy或者手动复制12345678910111213141516171819202122232425262728293031323334&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&gt;&lt;plist version="1.0"&gt;&lt;dict&gt; &lt;key&gt;Label&lt;/key&gt; &lt;string&gt;com.local.KeyRemapping&lt;/string&gt; &lt;key&gt;ProgramArguments&lt;/key&gt; &lt;array&gt; &lt;string&gt;/usr/bin/hidutil&lt;/string&gt; &lt;string&gt;property&lt;/string&gt; &lt;string&gt;--set&lt;/string&gt; &lt;string&gt;&#123;"UserKeyMapping":[ &#123; "HIDKeyboardModifierMappingSrc": 0x7000000E3, "HIDKeyboardModifierMappingDst": 0x700000029 &#125;, &#123; "HIDKeyboardModifierMappingSrc": 0x700000065, "HIDKeyboardModifierMappingDst": 0xFF00000003 &#125;, &#123; "HIDKeyboardModifierMappingSrc": 0x700000039, "HIDKeyboardModifierMappingDst": 0x7000000E0 &#125;, &#123; "HIDKeyboardModifierMappingSrc": 0x7000000E0, "HIDKeyboardModifierMappingDst": 0x70000006D &#125; ]&#125;&lt;/string&gt; &lt;/array&gt; &lt;key&gt;RunAtLoad&lt;/key&gt; &lt;true/&gt;&lt;/dict&gt;&lt;/plist&gt; 在启动台里面打开终端(Terminal)输入以下命令:1234cd ~/Library/LaunchAgents/vim com.local.keyRemppin.plistp:wq 如果上面命令看不懂可以使用下面这串命令1234cd ~/Library/LaunchAgents/touch com.local.keyRemppin.plistopen .右键com.local.keyRemppin.plist文件&gt;打开方式&gt;其他&gt;文本编辑&gt;右健粘贴自己映射的xml&gt;Command+s保存 粘贴好之后打开终端输入:1launchctl load com.local.keyRempping.plist 这样就映射好了键位,如果后续更新这个文件,必须要先取消加载再重新加载12launchctl unload com.local.keyRempping.plistlaunchctl load com.local.keyRempping.plist 以上命令必须保证自己在~/Library/LaunchAgents/目录,否则会报错 使用Hammerspoon设置Hyper key可以去官网下载hammerspoon官网或用HomeBrew安装:1brew cask install hammerspoon 在启动台里面打开终端(Terminal)输入以下命令:12cd ~/.hammerspoon/open . 右健新建init.lua文件,并加入一下代码1require &quot;hotkey.hotkey&quot; 接着终端输入12mkdir hotkey/ &amp;&amp; cd hotkeyopen . 右健新建hotkey.lua,并加入一下代码1234567891011121314151617181920212223242526hyper = hs.hotkey.modal.new(&#123;&#125;, 'F17')function enterHyperMode() hyper:enter()end-- 绑定f18为hyper keyf18 = hs.hotkey.bind(&#123;&#125;, 'F18', enterHyperMode )-- 这里设置自己要使用的Hyper key,比如在Alfred中设置的快捷键(hotkey)为cmd+alt+shift+ctrl+i的话,下面的数组中就添加'i'、cmd+alt+shift+ctrl+y, 就添加'y',其他键位同理-- 1 == cmd+alt+shift+ctrl+1 -- 2 == cmd+alt+shift+ctrl+2 -- c == cmd+alt+shift+ctrl+c keys = &#123;'i','y','1','2','c'&#125;function hyperFun(keys) for i=1, #(keys) do hyper:bind(&#123;&#125;, keys[i], function() hs.eventtap.keyStroke(&#123;'cmd','alt','shift','ctrl'&#125;, keys[i]) hyper.triggered = true end) endendhyperFun(keys) 如果没有生效的话,可以把Hammerspoon软件退出重新打开,或者点击小图标Reload 大家会用vim的话,可以直接用vim编辑 大功告成,之后大家就可以在各种应用里面设置cmd+alt+shift+ctrl+?的快捷键了,终于可以摆脱Karabiner-ElementsPs:https://rakhesh.com/mac/using-hidutil-to-map-macos-keyboard-keys/ https://kalis.me/setup-hyper-key-hammerspoon-macos/]]></content>
      <categories>
        <category>Mac</category>
        <category>hammerspoon</category>
        <category>Alfred</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Programming]]></title>
    <url>%2Fblog%2F2022%2F02%2F14%2FProgramming%2F</url>
    <content type="text"><![CDATA[常用算法map() 对范围中每个值应用一个函数,并返回应用该函数的结果12map(["apple", "orange", "peach"], (item) =&gt; item.length)// [5,6,5] filter() 对范围中的每个值应用谓词(?),过滤掉谓词返回false的那些值12filter(["apple", "orange", "peach"], (item) =&gt; item.length == 5)// ["apple", "peach"] reduce() 使用给定函数合并范围中的值, 并返回一个值12345reduce(["apple", "orange", "peach"], "", (acc, item) =&gt; acc + item)// ""初始值, "appleorangepech" 结果值// acc是累积项, 从初始值开始,最后得到所有元素合并后的值["apple","orange", "peach"].reduce((acc, item) =&gt; acc+item, "123")// array.reduce(callback, initiaValue) 上面这种用法不对,应该是得自己封装吧 在高层面上,编译器或解析器将把我们编写的源代码转换成机器(或运行时)能够理解的指令. 当运行时是一台物理计算机时,转换的指令将是CPU指令; 当运行时是虚拟机时, 则有自己的指令集和工具 类型的主要优点在于正确性、不可变性、 封装、 可组合性、和可读性. 这5种优点时优秀的软件设计和行为的根本特性. 系统中总有出息混乱或者无序状态的倾向, 而上述特性则起到抗衡这种倾向的作用. 不可变性123456789// 1.4function safeDivide(): nubmer &#123; let x: number = 42 // 使用常量 const x: number = 42 if (x == 0) throw new Error("x should not be 0"); x = x - 42 // 修改常量会导致编译错误 return 42 / x //除零导致无穷大&#125; 变量被另一个并发执行的线程修改,或者被另外调用的函数悄悄修改. 一旦值发生变化, 执行检查的保证就不再有效, 如果这里使用常量就不会出现这个问题 从内存表示的角度来说,可变与不可变x没有区别. 常量性只对编译器有意义, 它是类型系统启用的一个属性当涉及并发时,不可变性特别有用,因为如果数据不可变,就不会发生数据竞争 封装封装值当是隐藏代码内部机制的功能,这里的代码可以是函数、类或者模块我们利用封装, 是因为它可以帮助我们处理复杂性: 将代码拆分为更小的组件, 每个组件只向外界公开严格的需要的项, 而其他实现细节则被隐藏并隔离起来1234567891011121314151617// 1.6 封装程度不足class SafeDivisor &#123; divisor: number = 1 // private divisor: number = 1 // 变为私有成员,外部调用修改的时候ts就不会编译 setDivisor(value: number) &#123; if (value == 0) throw new Error("value should not be 0") this.divisor = value &#125; divide(x: number): number &#123; return x / this.divisor &#125;&#125;let sd = new SafeDivisor()sd.divisor = 0 // 因为除数成员是公有的,所以检查可能被绕过修改sd.divide(42) public和private成员的内存表示是一样的 封装或信息隐藏使我们能够将逻辑和数据拆分到一个公有接口和一个非公有实现中. 在大型系统中, 这张拆分非常有帮助, 因为使用接口(或抽象)使理解一段特定代码的作用变得更加简单. 我们只需要理解组件的借口, 而不必理解其全部实现细节. 封装也有助于将非公有信息限制在一个边界内, 并保证外部代码不能修改这些信息,因为他们根本就访问不了这些信息. 封装出现在多个层次,例如,服务将其API公开为接口, 模块导出其接口并隐藏实现细节, 类只公开公有成员, 等等. 与嵌套娃娃一样, 代码两部分之间的关系越弱, 共享的信息就越少. 这样一来, 组件对其内部管理的数据能够做出的保证就得到了强化, 因为如果不经过该组件的接口, 外部代码将无法修改这些数据 可组合性1234567891011121314// 1.8 不可组合的系统function findFirstnegativeNumber(number : number[]): number | undefined&#123; for (let i of numbers) &#123; if (i &lt; 0) return i &#125; // console.error("No matching value found")&#125;function findFirestOneCharacterString(string: string[]): string | undefined &#123; for (let str of strings) &#123; if (str.length == 1) return str &#125; // console.error("No matching value found")&#125; 假设有一个新的需求: 当在不到满足条件元素时,就记录一个错误,那就需要更新两个函数, 这就很麻烦了. 12345678910111213141516171819202122// 1.10 可组合系统function first&lt;T&gt;( range: T[], p: (elem: T) =&gt; boolean): T | undefined &#123; for (let elem of range) &#123; if (p(elem)) &#123; console.log(elem); return elem &#125; &#125;&#125;function findFirstNegativeNumber( number: number[]): number | undefined &#123; return first(number, n =&gt; n &lt; 0)&#125;function findFirestOneCharacterString( string: string[]): string | undefined &#123; return first(string, n =&gt; n.length == 1)&#125; 在第10章讨论泛型算法和迭代器的时候将会看到, 我们可以使用这个函数变得更加通用. 目前, 它只操作某个类型的T的一个数组. 可以扩展这个函数, 让它遍历人意数据结构 类型系统的类型静态类型在编译时检查类型, 所以当完成变以后, 运行时的值一定有正确的类型. 另一方面, 动态类型则将类型检查推迟到运行时, 所以类型不匹配就成了运行时错误强类型系统只会做很少的(甚至不做)隐士类型转换, 而弱类型系统则允许更多隐式类型转换javascript时动态类型, typescript 时静态类型 动态类型不会在编译时施加任何类型约束. 日常交流中有时会将动态类型叫做”鸭子类型” (duck typing), 这个名称来自俗语: “如果一个动物走起来像鸭子, 叫起来像鸭子,那么它就是一只鸭子”ts中使用any关键字可以模拟动态类型 js是弱类型,ts是强类型,==运算符在ts中无法编译,会直接报错 空类型 &amp; 单元类型函数在所有代码路径上都抛出异常(throw new Error(‘error’))、程序可能执行无限循环, 或者可能导致程序崩溃. 这些都算空类型never,如果用void就会存在误导性. 这些函数不是不返回有意义的值, 而是根本不返回 单元类型是只有一个可能值的类型. 对于这种类型变量, 检查其值是没有意义的, 它只能是哪一个值. 当函数的结果没有意义时, 我们会使用单元类型void 两个取值类型. 大多数语言都提供了布尔类型, 这是一个标准的、 只有两个值的类型 数值类型的常见陷阱0.10+0.10+0.10 !== 0.30https://gauravkk22.medium.com/why-0-1-0-2-0-3-is-false-in-js-mystery-unsolved-with-solution-4f7db2755f18123456// 2.10function epsilonEqual(a: number, b: number): boolean &#123; return Math.abs(a-b) &lt;= Number.EPSILON&#125;console.log(epsilonEqual(0.1+0.1+0.1, 0.3)) // true// 因为0.3和0.30000000000000004在彼此的圆整误差内 编码文本处理文本最好用库, grapheme-splittes,能够处理自负的书写位上面这个库可帮助避免在处理字符串时最常出现的三类错误:在字符串级别而不是书写位级别操纵编码文本在字节级别而不是字符级别操纵编码文本采用错误的编码来将一个字节序列解释为文本,例如试图将UTF-16编码文本解释为UTF-8文本,或者反过来解释 以前有门课程就专门说过不要直接使用(忘了是那个方法,substring?splice?)拆分文本,也没说啥原因,应该就是这种情况 UTF-8 8位==1个字节==取决于字符(英文1, 中文3, unicode 2)但是uft-8是可变字节和uft-16一样,utf-8中的中文是3个字节,而unicode是两个字节 UTF-32 32位==4字节==1个字符所有 组合元祖类型: 元祖类型由一组类型构成,通过它们在元祖中的位置可以访问这些组成类型. 元祖提供了一种特殊的分组数据的方式, 允许我们将不同的类型的多个值作为一个值进行传递 元祖可以精确到每一个元素的类型 记录类型: 记录类型与元祖类型相似, 可将其他类型组合在一起. 但是, 元祖中安装分量值的位置来访问值, 而在记录类型中, 无名可以为分量设置名称, 并通过名称来访问值. 在不同语言中, 记录类型被称为记录或者结构 这里感觉用记录类型很麻烦,挺奇怪的,估计后面会讲type Point = {}? 枚举类型: 枚举类型的一个变量可以是提供的值和任何一个.每当我们有一小组可能的取值, 并且想要以不会导致歧义的方式表示他们时,就可以使用枚举 可选类型: Ts中用|来表示12345678910111213141516171819202122// 3.12 可选类型class Optional&lt;T&gt; &#123; private value: T | undefined; private assigned: boolean; constructor(value?: T) &#123; if (value) &#123; this.value = value; this.assigned = true; &#125; else &#123; this.value = undefined this.assigned = false &#125; &#125; hasvalue(): boolean &#123; return this.assigned &#125; getValue(): T &#123; if (!this.assigned) throw Error() return &lt;T&gt;this.value // 这是什么玩意啊? 不知道这样写意义何在 &#125;&#125; Either类型, 见 3.14.ts在发生错误时抛出异常,这是返回结构或错误的一个有效例子: 函数要么返回一个结果,要么抛出一个异常. 在某些情况下, 不能使用异常, 所以优先选择使用Either类型, 例如: 当在进程间或线程间传播错误时; 作为一种设计原则, 当错误本身算不上异常时(通常发生在处理用户输入的情况); 当调用的操作系统的API, 而这些API使用错误码时, 等等. 在这些情况中, 我们不能或不希望抛出异常,而是行为表达我们成功获得了值或者失败了, 此时最好把这种情形编码成”值或错误”, 而不是”值和错误”1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// Eitherclass Either&lt;L, R&gt; &#123; private readonly value: L | R private readonly left: boolean private constructor(value: L | R, left: boolean) &#123; this.value = value this.left = left &#125; isLeft(): boolean &#123; return this.left &#125; getLeft(): L &#123; if (!this.isLeft()) throw new Error() return &lt;L&gt;this.value &#125; isRight(): boolean &#123; return !this.left &#125; getRight(): R &#123; if (!this.isRight()) throw new Error() return &lt;R&gt;this.value &#125; static makeLeft&lt;L, R&gt;(value: L) &#123; return new Either&lt;L, R&gt;(value, true) &#125; static makeRight&lt;L, R&gt;(value: R) &#123; return new Either&lt;L, R&gt;(value, false) &#125;&#125;enum InputError &#123; NoInput, Invalid&#125;enum DayOfWeek &#123; Sunday, Monday, TuesDay&#125;type Result = Either&lt;InputError, DayOfWeek&gt;function parseDayOfWeek(input: string): Result &#123; if (input == "") Either.makeLeft(InputError.NoInput) switch (input.toLowerCase()) &#123; case "sunday": return Either.makeRight(DayOfWeek.Sunday); case "sunday": return Either.makeRight(DayOfWeek.Monday); case "sunday": return Either.makeRight(DayOfWeek.TuesDay); default: return Either.makeLeft(InputError.Invalid) &#125;&#125; 变体类型: 变体类型也称为标签联合类型, 包含任意数的基本类型的值. 标签指的是即使基本类型有重合的值,我们仍能够准确说明该值来自那个类型. 原来typescript也可以这么难 类型安全火星探测项目的类型约束123456789101112131415161718192021222324252627282930313233declare const NsType: unique symbolclass Ns &#123; readonly value: number [NsType]: void constructor(value: number) &#123; this.value = value &#125;&#125;declare const LbfsType: unique symbolclass Lbfs &#123; readonly value: number [LbfsType]: void constructor(value: number) &#123; this.value = value &#125;&#125;function LbfsToNs(lbfs: Lbfs): Ns &#123; return new Ns(lbfs.value * 4.4482216152605)&#125;function trajectoryCorrenction(momentum: Ns)&#123; if (momentum.value &lt; new Ns(2).value) &#123; console.log('momentum is too low')); &#125;&#125;function provideMonmentum() &#123; trajectoryCorrenction(LbfsToNs(new Lbfs(1.5))) // 如果这里没有Ns传入值,就会报错,比如1.5 // 必须经过Ns才行,例: new Ns(1.5)&#125; 一般来说,构造函数不应该做太繁重的工作, 而应该初始化对象的成员private一个构造函数,就只能用工厂函数调用1234567891011121314// 工厂实施约束declear const celsiusType: unique symbol// typescript中用`unique symbol`来确保有相同形状的其他对象不会被解释为这个类型的一种方式class Celsius &#123; readonly value: number [celsusType]: void private constructor(value: number) &#123; this.value = value &#125; static makeCelsius(value: number): Celsius | undefined &#123; if (value &lt; -273.15) return undefined return new Celsius(value) &#125;&#125;]]></content>
      <categories>
        <category>javascript</category>
        <category>typescript</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Read_documents]]></title>
    <url>%2Fblog%2F2021%2F10%2F14%2FRead-documents%2F</url>
    <content type="text"><![CDATA[读ts文档j]]></content>
      <categories>
        <category>red</category>
      </categories>
      <tags>
        <tag>read</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nvim_config]]></title>
    <url>%2Fblog%2F2021%2F10%2F02%2Fnvim-config%2F</url>
    <content type="text"><![CDATA[Nvim 配置安装 packer.nvim 12git clone --depth 1 https://github.com/wbthomason/packer.nvim\ ~/.local/share/nvim/site/pack/packer/start/packer.nvim]]></content>
      <categories>
        <category>nvim</category>
      </categories>
      <tags>
        <tag>nvim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2Fblog%2F2021%2F09%2F20%2Fvim%2F</url>
    <content type="text"><![CDATA[一箭双雕: C == c$ s == cl S == ^C I == ^i A == $a o == A O == ko 删除整个单词 daw: 这个命令的好处是可以用.重复执行他 :h aw 可以解读为“delete a word” 改变数字大小 and 10 and 10 set nrformates= 该命令设置10进制 操作命令 c == 修改 d == 删除 y == 复制到寄存器 g~ == 反转大小写 gu == 转换为小写 gU == 转换为大写 > ==增加缩紧 &lt; == 减小缩紧 = == 自动缩紧 ! == 使用外部程序过滤{motion}所跨越的行 重绘屏幕达到写代码不滚至最底部的方法 zz命令,太牛了,小技巧插入模式zz :normal命令 结合@q来实现更复杂的功能 qqfpRbaidu V50j :’&lt;,’&gt;normal @q or :%normal @q]]></content>
      <categories>
        <category>vim</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pubg-react]]></title>
    <url>%2Fblog%2F2020%2F03%2F04%2F%E9%87%8D%E6%9E%84react%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[看到别人的一个项目不错，而且开源，react的，很多不懂，现在看能不能重构成功吧项目名pubg-react1npx create-react-app pubg-react client用到的库，介绍 apollo-client server端开始用的最新hapi, 安装命令 yarn add @hapi/hapi这里需要注意，新版必须使用node 12.x 以上的版本，否则就会报错12345sudo npm install n -gsudo n stablePATH="$PATH" // 更新环境变量，不然还是旧版 要在node端使用es6语法，用babel实现，安装yarn add @babel/preset-env @babel/node @babel/core -D创建.babelrc 文件：123&#123; "presets": ["@babel/preset-env"]&#125; 开发环境安装nodemon yarn add nodemon -Dpackage.json:12345678&#123; "scripts": &#123; "dev": "nodemon -w src --exec babel-node src/app.js" &#125;&#125;// shell 里面使用babel-node 的话，要用npx babel-node// 注意: 先要安装@babel/node @babel/core ，不然babel-node使用的就行旧版的babel-node 6.x如果是生产环境，就不要使用babel-node https://github.com/babel/example-node-server 生产环境配置 用到的库Hapi.js 如果仅是用于返回 api接口，或者通过node调用其他网络接口socket.io 封装了HTML5的websocket，完成一次握手，就可以畅通通讯dotenv 可以轻松使用process.env. 环境变量配置项目，只要在项目目录创建.env 文件pgr 是数据库连接的工具Postgres DB, 这原来是一个作者开发的啊。]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[服务端渲染]]></title>
    <url>%2Fblog%2F2019%2F10%2F19%2F%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93%2F</url>
    <content type="text"><![CDATA[服务端渲染 开始搭建项目webpack配置123module.export = &#123; target: 'node'&#125; 这个配置项，很有必要，如果是浏览器环境打包require(&#39;path&#39;)会把他打包到build.js中，如果是服务器环境就不会把他打包到build.js中123456789const path = require('path')module.export = &#123; target: 'node', entry: './src/index.js', output: &#123; filename: 'bundle.js', path: path.resolve(__dirname, 'build') &#125;&#125; __dirname指服务器根目录 同构一套React代码，在服务端执行一次，再在客户端执行一次 普通用的是render，服务端渲染要用hydrate, 后续会讲1ReactDom.hydrate(&lt;Home/&gt;, document.getElementById('root')) 访问静态资源利用express的一个方法123import express from 'express'const app = express()app.use(express.static('public')) 以后的静态资源都会去public里面找 遇到任何错误都可以在这个网站查找https://stackoverflow.com 自动编译webpack 的自动编译很简单 加一个配置项即可--watch1webpack --config webpack.config.js --watch node 就要借助nodemon 自动执行1sudo npm i nodemon -g package.json1234567&#123; "scripts": &#123; //supervisor //也是一个第三方模块，和nodemon功能一样，但是写法不一样，下面的写法有误，不能这么用 //"start": "nodemon build &amp;&amp; node \"./build/bundle.js\"", "start": "nodemon --watch build --exec node \"./build/bundle.js\"", &#125;&#125; 使用 npm-run-all1234567&#123;"scripts": &#123; "dev": "npm-run-all --parallel dev:**", "dev:start": "nodemon --watch build --exec node \"./build/bundle.js\"", "dev:build": "webpack --config webpack.server.js --watch" &#125;,&#125; webpack 自动化升级自动化升级以后要用到stage-x提案阶段的东西就必须写入对应的功能名字，然后引入该插件，也可以用npx babel-upgrade --write自动升级，packaage.json就会自动安装该阶段的插件，自己选择使用哪个 proposal 特性的插件, 参考自 一文读懂 babel7 的配置文件加载逻辑 注意升级前的写法必须是这样 12345678910111213module.exports = &#123; ... module: &#123; rules: [&#123; test: /\.js?$/, loader: 'babel-loader', exclude: /node_modules/, options: &#123; presets: ['@babek/preset-stage-0'] // 这里可以是0-4 &#125; &#125;] &#125;&#125; 升级后遇到一个bug,就是引入插件会报错未找到，npm i之后就好了新版的写法案例 1234options: &#123; presets: ['@babel/preset-react'], // 这不是必须的 plugins: ['@babel/plugin-proposal-class-properties']&#125; 服务端渲染中 store单例化问题 这是Vue ssr指南提到的，其实原理都一样，借鉴这篇文章的理解也是可以的原文链接：避免状态单例 当编写纯客户端(client-only)代码时，我们习惯于每次在新的上下文中对代码进行取值。但是，Node.js 服务器是一个长期运行的进程。当我们的代码进入该进程时，它将进行一次取值并留存在内存中。这意味着如果创建一个单例对象，它将在每个传入的请求之间共享。 如基本示例所示，我们为每个请求创建一个新的根 Vue 实例。这与每个用户在自己的浏览器中使用新应用程序的实例类似。如果我们在多个请求之间使用一个共享的实例，很容易导致交叉请求状态污染 (cross-request state pollution)。我们遇到的是store问题123// store.jsconst store = createStore(reducer, applyMiddleware(thunk))export default store 解决方法123456789101112131415const getStore = () =&gt; &#123; return createStore(reducer, applyMiddleware(thunk))&#125;export default getStore// 使用import React from 'react'import getStore from './store.js'import &#123; Provider &#125; from 'react-redux'const App = () =&gt; &#123; return ( &lt;Provider store=&#123;getStore()&#125;&gt;&lt;/Provider&gt;)&#125; 例如我们store，初始化数据里面有Date()，这样的原始数据，就会导致问题，这个时间就只会初始化一次，而不会得到更新，所以必须使用以上方法去避免这样的问题。 遇到一个新问题，就是如果store有Date这种实时数据的话，服务端渲染之后客户端渲染就会导致差1秒，控制台就会报错，这种问题应该如何避免呢，不渲染秒确实可以，但是如果某些场景必须使用秒呢 别人的库，已经学完，可以作为参考源文件 报错总结 (node:3102) UnhandledPromiseRejectionWarning: Error: connect ECONNREFUSED 127.0.0.1:80at TCPConnectWrap.afterConnect [as oncomplete] (net.js:1117:14) 这个错误是因为服务端渲染请求的目录不一样，服务端渲染如果请求/目录表示127.0.0.1:80, 然而我没有启动这个端口的服务，所以没东西，我将/改写为http://192.168.0.2:3000/之后就好了，但是不能跨域，所以访问的时候也不能用localhost, 解决方案，上线项目应该不会遇到这个问题把，毕竟不需要用到moke数据，直接请求服务器数据就ok了，服务器数据一般都用jsonp(开启跨域，这个我还不是很清楚) Warning: Expected server HTML to contain a matching \&lt;div> in\&lt;div>. 首先这里是因为客户端代码和服务端代码不同，我如何引发这个的问题的呢，就是因为客户端多套了一层div, 而服务端没套，老师讲的客户端不套div直接会报一个错误，估计是新版修复了? 尝试本来想尝试使用async await 来实现服务端请求数据的异步操作，最后发现express(好像express也有async但是没找到怎么用)，居然不行，还是koa厉害啊，怪不得koa火了。 这里遇到个问题，不知道是babel编译没有添加async还是说什么原因，要重新开一台node服务器来验证，这个服务器改的话太麻烦了，留着当一个坑 BASH 命令bash命令]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>react</tag>
        <tag>ssr</tag>
        <tag>next</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 新特性]]></title>
    <url>%2Fblog%2F2019%2F07%2F18%2FReact-%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[项目目录待填 一些知识点SPA/MPA单页应用/多页应用MPA和SPA没有本质区别，SPA需要改造才能变为MPA,大网站都是这么搞的 PWA 渐进式网络应用浏览器不支持pwa的时候就会退化为普通的应用，所以称之为渐进式网络应用。如果浏览器支持PWA，就可以控制静态资源缓存，即便我们的设备没有联网，也可以用缓存来运行页面，提供了强大的离线访问能力，除了离线访问，还可以优化载入速度，PWA是前端近年来的革命性进化，移动端支持良好。vue官网就用了这种功能 React 新特性Context定义：Context 提供了一种方式，能够让数据在组件树中传递而不必一级一级手动传递API: createContext(defaultValue?)解决问题：编程效率 他娘的，这么简单，就是透传，和上面定义的是一个意思，在src/ticket/Candidate.jsx中有用到，很简单、很方便。 App.js:12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import React, &#123; createContext &#125; from 'react';import './App.css';const BatteryContext = createContext(); //首先是创建，默认值是找不到Provider时候使用，一般是单元测试会用到const OnlineContext = createContext();class Leaf extends React.Component &#123; render () &#123; return ( &lt;BatteryContext.Consumer&gt; //可以无限嵌套，没有先后之分，注意嵌套规则即可 &#123; battery =&gt; ( &lt;OnlineContext.Consumer&gt; &#123; online =&gt; &lt;h1&gt;Battery: &#123;battery&#125;, online: &#123;online ? '联网':'未联网'&#125;&lt;/h1&gt; &#125; // 布尔值可以这样显示 String(online) &lt;/OnlineContext.Consumer&gt; ) &#125; &lt;/BatteryContext.Consumer&gt; ) &#125;&#125;class Middle extends React.Component &#123; render () &#123; return &lt;Leaf/&gt;; &#125;&#125;class App extends React.Component &#123; state = &#123; battery: 60, online: false &#125;; render () &#123; const &#123; battery, online &#125; = this.state return ( &lt;BatteryContext.Provider value=&#123;battery&#125;&gt; &lt;OnlineContext.Provider value=&#123;online&#125;&gt; &lt;button type="button" onClick=&#123;() =&gt; this.setState(&#123;battery: battery - 1&#125;)&#125; &gt; Press &lt;/button&gt; &lt;button type="button" onClick=&#123;() =&gt; this.setState(&#123;online: !online&#125;)&#125; &gt; Online &lt;/button&gt; &lt;Middle /&gt; &lt;/OnlineContext.Provider&gt; &lt;/BatteryContext.Provider&gt; ); &#125;&#125;export default App; ContextType结合Context代码使用123456789class Leaf extends React.Component &#123; static contextType = BatteryContext render () &#123; const battery = this.context return ( &lt;h1&gt;Battery: &#123;battery&#125;&lt;/h1&gt; ) &#125;&#125; 一个Context确实挺方便，多个是否就无法使用了呢？看到4-4节的时候老师有说，确实是只能指向一个，但是可以用useContext 解决这个问题，写法还会更简单 lazy所有的细节都在注释里面 app.js1234567891011121314151617181920212223242526272829303132333435363738394041424344import React, &#123; lazy, Suspense &#125; from 'react';import './App.css';const About = lazy(() =&gt; import(/* webpackChunkName: "about" */ './About.jsx'))// 错误捕获，如果手动将about.chunk.js 右键Block request URL，就会报错，我们必须手动处理错误。// 借助 ErrorBoundary，他的实现原理就是用react的生命周期钩子，componentDidCatch// 不过页面还是会报错，老师的报错位置是控制台，我直接就是页面class App extends React.Component &#123; state = &#123; hasError: false &#125;; // componentDidCatch () &#123; // this.setState(&#123; // hasError: true // &#125;) // &#125; // ErrorBoundary的另一种写法 static getDerivedStateFromError () &#123; // 一旦遇到错误，他就会返回一个新的state数据，并合并到组件的state中 return &#123; hasError: true &#125; &#125; render () &#123; if (this.state.hasError) &#123; return ( &lt;div&gt;加载错误，可能是网络请求问题&lt;/div&gt; ) &#125; return ( &lt;div&gt; &lt;Suspense fallback=&#123;&lt;div&gt;loading&lt;/div&gt;&#125;&gt; &lt;About /&gt; &lt;/Suspense&gt; &lt;/div&gt; ); &#125;&#125;export default App; About.jsx1234567891011import React, &#123; Component &#125; from 'react'class About extends Component &#123; render () &#123; return ( &lt;div&gt;About&lt;/div&gt; ) &#125;&#125;export default About Suspense都在上面的代码里面 memo解决父组件更改,子组件重新渲染问题 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React, &#123; PureComponent, memo &#125; from 'react';import './App.css';// memo 解决方案const Foo = memo(function Foo (props) &#123; console.log(props.name) return null;&#125;)// 另一种解决方案PureComponent// 有局限性，只有传入属性的对比，如果内部发生什么变化，就么得用了// 比如传入对象就算修改，也不会更新视图。还有传入内敛callback(&lt;Foo cb=&#123;() =&gt; &#123;&#125;&#125;&gt;&lt;/Foo&gt;)，这样每次都会渲染// callback () &#123;&#125;// &lt;Foo cb=&#123;this.callback&#125;&gt;&lt;/Foo&gt;// 解决callback this指向问题 callback = () =&gt; &#123;&#125; ,这就是一个比较完美的写法了，不过又听说箭头函数优化不好。// class Foo extends PureComponent &#123;// render () &#123;// console.log(this.props.name)// return null;// &#125;// &#125;// 回调解决方案// class Foo extends React.Component &#123;// // 是否决定重新渲染// shouldComponentUpdate (nextProps, nextState) &#123;// if (nextProps.name === this.props.name) &#123;// return false// &#125;// return true// &#125;// render () &#123;// console.log(this.props.name)// return null;// &#125;// &#125;class App extends React.Component &#123; state = &#123; num: 0 &#125; render () &#123; return ( &lt;div&gt; &lt;button onClick=&#123;()=&gt;&#123;this.setState(&#123;num: this.state.num + 1&#125;)&#125;&#125;&gt;&#123;this.state.num&#125;&lt;/button&gt; &lt;Foo name="Foo"&gt;&lt;/Foo&gt; &lt;/div&gt; ) &#125;&#125;export default App; State HooksuseState所有的hooks函数都应该以use开头1234567891011121314function App (props) &#123; let [num, setNum] = useState(() =&gt; &#123; console.log('inall') return props.defaultCount || 0 &#125;) return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(num + 1)&#125;&gt; &#123;num&#125; &lt;/button&gt; &lt;/div&gt; )&#125; Effect HooksuseEffect 代替 componentDidMount, componentDidUpdate, componentWillUnmount灵活运用,就可以达到上面生命周期钩子的效果 123456789101112131415161718192021222324252627282930313233343536373839import React, &#123; useState, useEffect &#125; from 'react';import './App.css';function App (props) &#123; // let num, setNum; // let Main, setMain; let [title, setNum] = useState(0) let [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) const onResize = () =&gt; &#123; setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) &#125; useEffect(() =&gt; &#123; document.title = title &#125;) useEffect(() =&gt; &#123; window.addEventListener('resize', onResize, false) return () =&gt; &#123; //回调清理函数 console.log('remove'); window.removeEventListener('resize', onResize, false) &#125; &#125;, []) // 数组的每一项都不变,才会阻止里面的内容更改 return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(title + 1)&#125;&gt; &#123;title&#125;, &#123;size.width&#125;, &#123;size.height&#125; &lt;/button&gt; &lt;/div&gt; )&#125;export default App; Hooks 下的 Context可以说是很简单了不要滥用context, 破坏组件独立性 App.js12345678910111213141516171819202122232425262728import React, &#123; useState, createContext , useContext&#125; from 'react';import './App.css';const BatteryContext = createContext();function Foo() &#123; const title = useContext(BatteryContext) return ( &lt;div&gt;&#123;title&#125;&lt;/div&gt; )&#125;function App (props) &#123; const [title, setNum] = useState(0) return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(title + 1)&#125;&gt; Add &lt;/button&gt; &lt;BatteryContext.Provider value=&#123;title&#125;&gt; &lt;Foo /&gt; &lt;/BatteryContext.Provider&gt; &lt;/div&gt; )&#125;export default App; useMemo这是掘金看到的写法，老师的写法有错，现在用会警告，而且没有视频中的效果纠结了半小时，原来是要配合memo，听课没认真的后果。1234567891011121314151617181920212223242526272829303132333435363738394041import React, &#123; useState, useMemo &#125; from 'react';import './App.css';function Foo(props) &#123; console.log('渲染'); return ( &lt;div title=&#123;props.title&#125;&gt;&#123;props.title&#125;&lt;/div&gt; )&#125;function Coo(props) &#123; console.log('Coo'); return ( &lt;div&gt;&#123;props.coo&#125;&lt;/div&gt; )&#125;function App (props) &#123; const [title, setNum] = useState(0) const [coo, setCoo] = useState(2) const double = useMemo(() =&gt; &lt;Foo title=&#123;title&#125;/&gt;, [title]); const douCoo = useMemo(() =&gt; &lt;Coo coo=&#123;coo&#125;/&gt;, [coo]) return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(title + 1)&#125;&gt; Add &lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCoo(coo + 1)&#125;&gt; C &lt;/button&gt; &#123;double&#125; &#123;douCoo&#125; &lt;div&gt;&#123;double&#125;&lt;/div&gt; &lt;/div&gt; )&#125;export default App; 配合 memo 使用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455import React, &#123; useState, useMemo, memo, useCallback &#125; from 'react';import './App.css';const Foo = memo(function Foo(props) &#123; console.log('渲染'); return ( &lt;h1 onClick=&#123;props.onClick&#125;&gt;&#123;props.title&#125;&lt;/h1&gt; )&#125;)function App (props) &#123; const [title, setNum] = useState(0) const [lest, setLest] = useState(0) const fun = useMemo(() =&gt; &#123; // 如果是一个普通的箭头函数，每次都会是一个新的句柄，只有这样才会传入固定的句柄 return () =&gt; &#123; console.log('useMemo'); &#125; &#125;, []) // 如果useMemo返回的是函数，可以直接用useCallback，来省略顶层的函数 // 这两种写法等价 const fun = useCallback(() =&gt; &#123; console.log('useCallback') &#125;, []) // 更新状态, 依赖的两个变量都要写到状态里面，其实官方说，可以保证每次setState返回的同一个句柄 // const fun = useCallback(() =&gt; &#123; // console.log('callback') // setLest((le) =&gt; le + 1) // &#125;, []) // 另一种更新状态写法 // const fun = useCallback(() =&gt; &#123; // console.log('callback') // setLest(lest + 1) // &#125;, [lest]) const num = useMemo(() =&gt; &#123; return title * 2 &#125;, [title === 3]) // 这么写会有报错，不过可以实现 return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(title + 1)&#125;&gt; Add &lt;/button&gt;- &lt;button onClick=&#123;() =&gt; setLest(lest + 1)&#125;&gt; lest &lt;/button&gt; &lt;Foo onClick=&#123;fun&#125; title=&#123;num&#125;&gt;&lt;/Foo&gt; &lt;/div&gt; )&#125;export default App; useRefclass 的时候可以使用 String Ref, Callback Ref, CreateRefhooks 使用 useRef 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667import React, &#123; useState, PureComponent,useMemo, useCallback, useRef, useEffect &#125; from 'react';import './App.css';// 因为函数无法创建实例，所以必须用class来实现，原来hooks不能完全代替奥// const Foo = memo(function Foo(props) &#123;// console.log('渲染');// return (// &lt;h1 onClick=&#123;props.onClick&#125;&gt;&#123;props.title&#125;&lt;/h1&gt;// )// &#125;)// 用PureComponent代替memoclass Foo extends PureComponent &#123; mems () &#123; // 第一种使用场景 console.log(this.props.title); &#125; render () &#123; console.log('渲染'); return ( &lt;h1 onClick=&#123;this.props.onClick&#125;&gt;&#123;this.props.title&#125;&lt;/h1&gt; ) &#125;&#125;function App (props) &#123; const [title, setNum] = useState(0) const [lest, setLest] = useState(0) const contRef= useRef() const it = useRef() const fun = useCallback(() =&gt; &#123; console.log('callback') setLest((le) =&gt; le + 1) contRef.current.mems(); // 第一种使用场景 &#125;, [contRef]) const num = useMemo(() =&gt; &#123; return title * 2 &#125;, [title]) // 这么写会有报错，不过可以实现 useEffect(() =&gt; &#123; // 如果是在App函数中声明变量，每次都会执行这个变量，就会导致无法清除it,就必须全局创建，state好像也是可以解决 it.current = setInterval(() =&gt; &#123; // Ref的第二种使用场景 setNum(title =&gt; title +1) &#125;, 1000) &#125;, []) useEffect(() =&gt; &#123; if (num &gt;= 10) &#123; clearInterval(it.current) &#125; &#125;) return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(title + 1)&#125;&gt; Add &lt;/button&gt;- &lt;button onClick=&#123;() =&gt; setLest(lest + 1)&#125;&gt; &#123;lest&#125; &lt;/button&gt; &lt;Foo onClick=&#123;fun&#125; ref=&#123;contRef&#125; title=&#123;num&#125;&gt;&lt;/Foo&gt; &lt;/div&gt; )&#125;export default App; 自定义hooks，达到状态逻辑复用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475import React, &#123; useState, useMemo, useRef, useEffect, useCallback &#125; from 'react';import './App.css';function useFoo(count) &#123; const &#123;height, width&#125; = useSize() return ( &lt;h1&gt;&#123;count&#125;, &#123;height&#125;, &#123;width&#125;&lt;/h1&gt; )&#125;function useCount() &#123; const [title, setNum] = useState(0) const it = useRef() const num = useMemo(() =&gt; &#123; return title * 2 &#125;, [title]) // 这么写会有报错，不过可以实现 useEffect(() =&gt; &#123; it.current = setInterval(() =&gt; &#123; // Ref的第二种使用场景 setNum(title =&gt; title +1) &#125;, 1000) &#125;, []) useEffect(() =&gt; &#123; if (num &gt;= 10) &#123; clearInterval(it.current) &#125; &#125;) return [title, setNum, num]&#125;function useSize() &#123; const [size, setSize] = useState(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;); // const onResize = () =&gt; &#123; // setSize(&#123; // width: document.documentElement.clientWidth, // height: document.documentElement.clientHeight // &#125;) // &#125; const onResize = useCallback(() =&gt; &#123; // 老师也是一笔带过，没有细讲为什么要用useCallback(), 我也记不起来了。算一个坑吧 setSize(&#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125;) &#125;, []) useEffect(() =&gt; &#123; window.addEventListener('resize', onResize, false) return () =&gt; &#123; window.removeEventListener('resize', onResize, false) &#125; &#125;, [onResize]) return size&#125;function App (props) &#123; const [title, setNum, num] = useCount() const Counter = useFoo(num) const size = useSize() return ( &lt;div&gt; &lt;button onClick=&#123;() =&gt; setNum(title + 1)&#125;&gt; Add,&#123;size.width&#125;,&#123;size.height&#125; &lt;/button&gt; &#123;Counter&#125; &lt;/div&gt; )&#125;export default App; hooks 使用法则顶层调用hooks函数：不能在循环语句，条件语句或者是嵌套函数中调用hooks函数仅在函数组件和自定义hooks函数中，调用hooks函数 hooks使用问题生命周期的问题：getDerivedStateFromProps 可以用hooks代替1234567891011121314151617181920class App extends React.component &#123; state = &#123; ovflive: false &#125; static getDerivedStateFromProps(props) &#123; if (props.num &gt; 10) &#123; return &#123; ovflive: true &#125; &#125; &#125;&#125;// hooks写法function App (props) &#123; const [num, setNum] = useState(false) if (props.num &gt; 10) &#123; setNum(true) // 不用担心性能问题，这个setNum是在React操作dom之前完成的 &#125;&#125; shouldComponentUpdatehooks 代替 memo componentDidMount componentDidUpdate componentWillUnmounthooks 写法12345678910111213141516function App () &#123; useEffect(() =&gt; &#123; // componentDidMount return () =&gt; &#123; // componentWillUnmount &#125; &#125;, []); let renderCounter = useRef(0) renderCounter.current++; useEffect(() =&gt; &#123; if (renderCounter &gt; 1) &#123; // componentDidUpdate &#125; &#125;)&#125; getSnapshotBeforeUpdate componentDidCatch getDerivedStateFromError目前hooks无法实现，函数组件目前还无法取代类组件 类实例成员如何映射到hooks1234567class App &#123; it = 0;&#125;function App() &#123; const it = useRef(0) // 初始值不能传入函数&#125; hooks如何获取历史props和state了解了了解了，如果不用useRef每次组件重新渲染值都会初始化为0，只有用useRef值才能保持不变，还有就是useEffect的优先级比较低，怎么比喻呢。，写下来把(0表示最先，依次)次序有问题，下面做了修改1234567891011function Counter() &#123; const [count, setCount] = useState(0) // 0 const prevCountRef = useRef() // 0 useEffect(() =&gt; &#123; // 2 prevCountRef.current = count // 保存上一次的count值，因为ref不受重新渲染的影响，因此可以从下一次渲染中取出count &#125;) const prevCount = prevCountRef.current // 1 return &lt;h1&gt;Now: &#123;count&#125;, before: &#123;prevCount&#125;&lt;/h1&gt; // 3&#125; 上面的次序有问题，这里重新更改, useEffect 居然这么晚执行1234567891011function Counter() &#123; const [count, setCount] = useState(0) // 0 const prevCountRef = useRef() // 0 useEffect(() =&gt; &#123; // 2 prevCountRef.current = count &#125;) const prevCount = prevCountRef.current // 0 return &lt;h1&gt;Now: &#123;count&#125;, before: &#123;prevCount&#125;&lt;/h1&gt; // 1&#125; 如何强制更新一个hooks组件class中有一个forceUpdate, 不过hooks 我们可以用其他方法其代替 1234567891011121314151617function Counter() &#123; const [count, setCount] = useState(0) const [updater, setUpdater] = useState(0) function forceUpdate() &#123; setUpdater(updater =&gt; updater + 1) // 更新updater 就是间接更新了hooks组件 &#125; const prevCountRef = useRef() useEffect(() =&gt; &#123; prevCountRef.current = count &#125;) const prevCount = prevCountRef.current return &lt;h1&gt;Now: &#123;count&#125;, before: &#123;prevCount&#125;&lt;/h1&gt;&#125; ReduxRedux 三大原则单一数据源状态不可变纯函数修改数据 实现的一个todolist应用。很简单，样式以及源码全部在train-ticket的src/TodoListSoundCode目录下这里放上app.js代码部分，方便查阅123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';import './App.css';let idSeq = Date.now()const Control = memo(function Control(props) &#123; const &#123; addTodo &#125; = props const inputRef = useRef() const onSubmit = (e) =&gt; &#123; // 没有像任何子组件传递，所以就没有必要包裹callback e.preventDefault() const newText = inputRef.current.value.trim() if (newText.length === 0) &#123; return &#125; addTodo(&#123; id: ++idSeq, text: newText, complate: false &#125;) inputRef.current.value = '' &#125; return ( &lt;div className="control"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type="text" ref=&#123;inputRef&#125; className="new-todo" placeholder="what needs to be done?" /&gt; &lt;/form&gt; &lt;/div&gt; )&#125;)const TodoItem = memo(function TodoItem(props) &#123; const &#123; todo: &#123; id, text, complate &#125;, toggleTodo, removeTodo &#125; = props const onChange = () =&gt; &#123; toggleTodo(id) &#125; const onRemove = () =&gt; &#123; removeTodo(id) &#125; console.log('0'); return ( &lt;li className="todo-item"&gt; &lt;input type="checkbox" onChange=&#123;onChange&#125; checked=&#123;complate&#125; /&gt; &lt;label className=&#123;complate ? 'complate' : ''&#125;&gt;&#123;text&#125;,&#123;String(complate)&#125;&lt;/label&gt; &lt;button onClick=&#123;onRemove&#125;&gt;&amp;#xd7;&lt;/button&gt; &lt;/li&gt; )&#125;)const Todos = memo(function Todos(props) &#123; const &#123; todos, toggleTodo, removeTodo &#125; = props return ( &lt;ul&gt; &#123; todos.map(todo =&gt; &#123; return &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; toggleTodo=&#123;toggleTodo&#125; removeTodo=&#123;removeTodo&#125; /&gt; &#125;) &#125; &lt;/ul&gt; )&#125;)const LS_KEY = '$-todos_';function TodoList() &#123; const [todos, setTodos] = useState([]) const addTodo = useCallback((todo) =&gt; &#123; setTodos(todos =&gt; [...todos, todo]) &#125;, []) const removeTodo = useCallback((id) =&gt; &#123; setTodos(todos =&gt; todos.filter(todo =&gt; &#123; return todo.id !== id &#125;)) &#125;, []) const toggleTodo = useCallback((id) =&gt; &#123; setTodos(todos =&gt; todos.map(todo =&gt; &#123; return todo.id === id ? &#123; ...todo, complate: !todo.complate &#125; : todo; &#125;)) &#125;, []) // 下面两个副作用都是来实现本地数据存储的 useEffect(() =&gt; &#123; const todos = JSON.parse(localStorage.getItem(LS_KEY) || '[]') setTodos(todos) &#125;, []) useEffect(() =&gt; &#123; localStorage.setItem(LS_KEY, JSON.stringify(todos)) &#125;, [todos]) return ( &lt;div className="todo-list"&gt; &lt;Control addTodo=&#123;addTodo&#125; /&gt; &lt;Todos removeTodo=&#123;removeTodo&#125; toggleTodo=&#123;toggleTodo&#125; todos=&#123;todos&#125; /&gt; &lt;/div&gt; )&#125;export default TodoList; Dispatch 与 Action这不就是我苦苦寻找的vuex里面的解构为什么可以…dispatch的原因了吗，帅呆了奥，原来是这么写一个函数的addTodo = (payload) =&gt; dispatch(createAdd(payload))把传入的对象转换为下面这种格式，然后通过解构的方式传递给组件，帅{ addTodo: dispatch Function}123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';import './App.css';import &#123; createAdd, createSet, createRemove, createToggle&#125; from './actions'let idSeq = Date.now()// 这不就是我苦苦寻找的vuex里面的解构为什么可以...dispatch的原因了吗，帅呆了奥，原来是这么写一个函数的// addTodo = (payload) =&gt; dispatch(createAdd(payload))// 把传入的对象转换为下面这种格式，然后通过解构的方式传递给组件，帅// &#123;// addTodo: dispatch Function// &#125;function bindActionCreators(actionCreators, dispatch) &#123; const ret = &#123;&#125; for (let key in actionCreators) &#123; ret[key] = function (...args) &#123; const actionCreator = actionCreators[key] const action = actionCreator(...args) dispatch(action) &#125; &#125; return ret&#125;const Control = memo(function Control(props) &#123; const &#123; addTodos &#125; = props const inputRef = useRef() const onSubmit = (e) =&gt; &#123; // 没有像任何子组件传递，所以就没有必要包裹callback e.preventDefault() const newText = inputRef.current.value.trim() if (newText.length === 0) &#123; return &#125; addTodos(&#123; id: ++idSeq, text: newText, complate: false &#125;) inputRef.current.value = '' &#125; return ( &lt;div className="control"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type="text" ref=&#123;inputRef&#125; className="new-todo" placeholder="what needs to be done?" /&gt; &lt;/form&gt; &lt;/div&gt; )&#125;)const TodoItem = memo(function TodoItem(props) &#123; const &#123; todo: &#123; id, text, complate &#125;, remove, toggle &#125; = props const onChange = () =&gt; &#123; toggle(id) &#125; const onRemove = () =&gt; &#123; remove(id) &#125; return ( &lt;li className="todo-item"&gt; &lt;input type="checkbox" onChange=&#123;onChange&#125; checked=&#123;complate&#125; /&gt; &lt;label className=&#123;complate ? 'complate' : ''&#125;&gt;&#123;text&#125;,&#123;String(complate)&#125;&lt;/label&gt; &lt;button onClick=&#123;onRemove&#125;&gt;&amp;#xd7;&lt;/button&gt; &lt;/li&gt; )&#125;)const Todos = memo(function Todos(props) &#123; const &#123; todos, remove, toggle &#125; = props return ( &lt;ul&gt; &#123; todos.map(todo =&gt; &#123; return &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; remove=&#123;remove&#125; toggle=&#123;toggle&#125; /&gt; &#125;) &#125; &lt;/ul&gt; )&#125;)const LS_KEY = '$-todos_';function TodoList() &#123; const [todos, setTodos] = useState([]) const dispatch = useCallback((action) =&gt; &#123; const &#123; type, payload &#125; = action switch (type) &#123; case 'set': setTodos(payload) break; case 'add': setTodos(todos =&gt; [...todos, payload]) break; case 'remove': setTodos(todos =&gt; todos.filter(todo =&gt; &#123; return todo.id !== payload &#125;)) break; case 'toggle': setTodos(todos =&gt; todos.map(todo =&gt; &#123; return todo.id === payload ? &#123; ...todo, complate: !todo.complate &#125; : todo; &#125;)) break; default: &#125; &#125;, []) useEffect(() =&gt; &#123; const todos = JSON.parse(localStorage.getItem(LS_KEY) || '[]') dispatch(createSet(todos)) &#125;, [dispatch]) useEffect(() =&gt; &#123; localStorage.setItem(LS_KEY, JSON.stringify(todos)) &#125;, [todos]) return ( &lt;div className="todo-list"&gt; &lt;Control &#123; ...bindActionCreators(&#123; addTodos: createAdd &#125;, dispatch) &#125; /&gt; &lt;Todos &#123; ...bindActionCreators(&#123; remove: createRemove, toggle: createToggle &#125;, dispatch) &#125; todos=&#123;todos&#125; /&gt; &lt;/div&gt; )&#125;export default TodoList; reducer 这边问题很多啊123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204import React, &#123; useState, useCallback, useRef, useEffect, memo &#125; from 'react';import './App.css';import &#123; createAdd, createSet, createRemove, createToggle&#125; from './actions'let idSeq = Date.now()// 这不就是我苦苦寻找的vuex里面的解构为什么可以...dispatch的原因了吗，帅呆了奥，原来是这么写一个函数的// addTodo = (payload) =&gt; dispatch(createAdd(payload))// 把传入的对象转换为下面这种格式，然后通过解构的方式传递给组件，帅// &#123;// addTodo: dispatch Function// &#125;function bindActionCreators(actionCreators, dispatch) &#123; const ret = &#123;&#125; for (let key in actionCreators) &#123; ret[key] = function (...args) &#123; const actionCreator = actionCreators[key] const action = actionCreator(...args) dispatch(action) &#125; &#125; return ret&#125;const Control = memo(function Control(props) &#123; const &#123; addTodos &#125; = props const inputRef = useRef() const onSubmit = (e) =&gt; &#123; // 没有像任何子组件传递，所以就没有必要包裹callback e.preventDefault() const newText = inputRef.current.value.trim() if (newText.length === 0) &#123; return &#125; addTodos(&#123; id: ++idSeq, text: newText, complate: false &#125;) inputRef.current.value = '' &#125; return ( &lt;div className="control"&gt; &lt;h1&gt;todos&lt;/h1&gt; &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;input type="text" ref=&#123;inputRef&#125; className="new-todo" placeholder="what needs to be done?" /&gt; &lt;/form&gt; &lt;/div&gt; )&#125;)const TodoItem = memo(function TodoItem(props) &#123; const &#123; todo: &#123; id, text, complate &#125;, remove, toggle &#125; = props const onChange = () =&gt; &#123; toggle(id) &#125; const onRemove = () =&gt; &#123; remove(id) &#125; return ( &lt;li className="todo-item"&gt; &lt;input type="checkbox" onChange=&#123;onChange&#125; checked=&#123;complate&#125; /&gt; &lt;label className=&#123;complate ? 'complate' : ''&#125;&gt;&#123;text&#125;,&#123;String(complate)&#125;&lt;/label&gt; &lt;button onClick=&#123;onRemove&#125;&gt;&amp;#xd7;&lt;/button&gt; &lt;/li&gt; )&#125;)const Todos = memo(function Todos(props) &#123; const &#123; todos, remove, toggle &#125; = props return ( &lt;ul&gt; &#123; todos.map(todo =&gt; &#123; return &lt;TodoItem key=&#123;todo.id&#125; todo=&#123;todo&#125; remove=&#123;remove&#125; toggle=&#123;toggle&#125; /&gt; &#125;) &#125; &lt;/ul&gt; )&#125;)function reducer(state, action) &#123; const &#123; type, payload &#125; = action; const &#123; todos, incrementCount &#125; = state switch (type) &#123; case 'set': return &#123; ...state, todos: payload, incrementCount: incrementCount + 1 &#125; case 'add': return &#123; ...state, todos: [...todos, payload], incrementCount: incrementCount + 1 &#125; case 'remove': return &#123; ...state, todos: todos.filter(todo =&gt; &#123; return todo.id !== payload &#125;) &#125; case 'toggle': return &#123; ...state, todos: todos.map(todo =&gt; &#123; return todo.id === payload ? &#123; ...todo, complate: !todo.complate &#125; : todo; &#125;) &#125; default: return state &#125;&#125;const LS_KEY = '$-todos_';function TodoList() &#123; const [todos, setTodos] = useState([]) const [incrementCount, setIncrementCount] = useState(0) const dispatch = useCallback((action) =&gt; &#123; const state = &#123; todos, incrementCount &#125; const setters = &#123; todos: setTodos, incrementCount: setIncrementCount &#125; const newState = reducer(state, action) for (var key in newState) &#123; setters[key](newState[key]) &#125; &#125;, [todos, incrementCount]) useEffect(() =&gt; &#123; const todos = JSON.parse(localStorage.getItem(LS_KEY) || '[]') dispatch(createSet(todos)) &#125;, []) useEffect(() =&gt; &#123; localStorage.setItem(LS_KEY, JSON.stringify(todos)) &#125;, [todos]) return ( &lt;div className="todo-list"&gt; &lt;Control &#123; ...bindActionCreators(&#123; addTodos: createAdd &#125;, dispatch) &#125; /&gt; &lt;Todos &#123; ...bindActionCreators(&#123; remove: createRemove, toggle: createToggle &#125;, dispatch) &#125; todos=&#123;todos&#125; /&gt; &lt;/div&gt; )&#125;export default TodoList; 以上代码这一块编辑器提示必须依赖dispatch，否则就删除数组，但是依赖后就会出现bug，代码会进入无限循环，莫名其妙，不过老师后面的异步actions好像是可以避免这个问题，但是我没有跟进，直接进入了PWA应用1234useEffect(() =&gt; &#123; const todos = JSON.parse(localStorage.getItem(LS_KEY) || '[]') dispatch(createSet(todos))&#125;, []) PWA (Progressive Web App)渐进式网络应用 Service Worker 服务器工作线程常驻内存运行代理网络请求依赖HttpS Promise优化回调地狱async/await 语法同步化 fetch比XMLHttpRequest更简洁Promise风格 cache API支持资源的缓存系统缓存(css/scritp/image)依赖Service Worker代理网络请求 Notification API消息推送依赖用户授权适合在Service Worker中推送 删除除serviceWorker.js以外的所有文件1ls | grep -v serviceWorker.js | xargs rm 这句代码也太帅了？从来没用过哎 小技巧生成26个字母表123const alphabet = Array.from(new Array(26), (eie, index) =&gt; &#123; return String.fromCharCode(65 + index)&#125;) 通过data来进行元素的锚跳转12345&lt;div data-cate="X"&gt;X&lt;/div&gt;&lt;script&gt;document.querySelector(`[data-cate='X']`) .scrollIntoView()&lt;/script&gt; 传参如果是对象可以解构：123456789const bash = &#123; name, bash, hello&#125;return ( &lt;div &#123;...bash&#125;&gt;&lt;/div&gt;) icon小图标的&amp;#x在js中要替换为’\u’ delete操作符居然可以这样用-in运算符：src/query/Bottom.jsx123456789const toggle = useCallback((value) =&gt; &#123; const newCheckedMap = &#123;...checkedMap&#125; if (value in checkedMap) &#123; delete newCheckedMap[value] &#125; else &#123; newCheckedMap[value] = true &#125; update(newCheckedMap)&#125;, [checkedMap, update]) 今天用到了Object.assign()目前根据代码推断，作用应该等同于:123456789const data = &#123;name:1&#125;data = &#123;...data, msg: "helo"&#125;// 等同于Object.assign(data, &#123; msg: "helo"&#125;) Candidate.jsx中还写了个选项卡，很简单，很简单 没有用过的css实现的效果就是拖动到顶部的时候会变成固定定位，下一个同样属性的元素划过会替换掉。蛮神奇的123&#123; position: sticky;&#125; readonlyinput的一个属性，加了后不能填写，初步理解 日期组件很顶，以后可以用到估计common/DeteSelector.jsx 这个日期选择组件实在是帅的一批，react居然要拆这么细的组件，日期组件原来这么简单，感觉下一次做就不会有所畏惧了，结尾老师说的注意点，什么鬼，听不明白，hide？ 开发中所用到的npm安装的模块总结prop-types 校验传入属性值的类型具体在common/header.jsx 文件中使用classnames 动态类、没有这个的话可以这么写没有：1&lt;div className=&#123;['city-selector', (!show) &amp;&amp; 'hidden'].filter(Boolean).join(' ')&#125;&gt;&lt;/div&gt; 用classnames1234import classnames from 'classnames'&lt;div className=&#123;classnames('city-selector', &#123; hidden: !show &#125;)&#125;&gt;&lt;/div&gt; day.js 仅2K大小，和Moment.js一样的api，nice啊，虽然没有用过Monment urijs解析用get提交的url数据，这个居然也要库，怎么什么都要库啊，自己写不行吗。12345678910111213141516import URI from 'urijs'const &#123;dispatch&#125; = propsuseEffect(() =&gt; &#123; const queries = URI.parseQuery(window.location.search) const &#123; from, to, date, highSpeed &#125; = queries dispatch(setFrom(from)) dispatch(setTo(to)) dispatch(setDeparDate(h0(dayjs(date).valueOf()))) dispatch(setHighSpeed(highSpeed === 'true'))&#125;, []) left-pad 这个模块就11行代码，我真的服了，现在有现成的支持,String.padStart()这几集的视频没了，只能自己看源码，还行吧，挺简单的，里面操作滚动条技巧还挺厉害的，掌握原理了，我自己写还真写不出来，艾，基础太薄弱了。fuck1String(index: number).padStart(2, '0') webpack 的 MPA 多页网页设置9-2 节必须更改config/webpack.config.js下的：12345output: &#123; /* 142 */ filename: isEnvProduction /* 143 */ ? 'static/js/[name].[chunkhash:8].js' /* 144 */ : isEnvDevelopment &amp;&amp; 'static/js/build.js'&#125; 更改为: ‘static/js/[name].js’12345output: &#123; /* 142 */ filename: isEnvProduction /* 143 */ ? 'static/js/[name].[chunkhash:8].js' /* 144 */ : isEnvDevelopment &amp;&amp; 'static/js/[name].js'&#125; 应该补充的知识给组件传自定义dom这块还不知道其他用法，比如传多个dom。12345678910111213141516function Detail(props) &#123; return ( &lt;div&gt; &#123; props.children &#125; &lt;/div&gt; )&#125;function App()&#123; return ( &lt;Detail&gt; // 这里可以自己定义 &lt;span&gt;&lt;/span&gt; &lt;/Detail&gt; )&#125; for of 以及 object.keys() 的使用以前还专门记过，他娘的，怎么就忘了呢src/order/actions.js123456789101112131415const passengers = [ &#123;id: 0, ticketType: 'abult'&#125;, &#123;id: 1, child: ''&#125;]for (let passenger of passengers) &#123; const keys = Object.keys(passenger) for (let key of keys) &#123; if (!passenger[key]) &#123; return &#125; &#125; if (passenger.ticketType === 'adult') &#123; adultFound = passenger.id &#125;&#125; 结束语总体来说还是可以的，hooks比想象的要简单要好用的多 12.1 代码规范和格式化，git提交格式化，使用Prettier增强eslist的格式化能力12.2 代码部署以及PWA应用所需的，serviceWorker.js 的应用]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript]]></title>
    <url>%2Fblog%2F2019%2F06%2F11%2FTypeScript%2F</url>
    <content type="text"><![CDATA[TypeScript 学习库地址 换一套课程，上一个就是按照官方文档来的 2-4基础类型undefined 和 null是所有类型的子类型 比如：12let num: number = undefined;let num: number = null; 跳过检查any12let strOrnum: any = 'num'strOrnum = 213 联合类型|12let strOrnum: number | string = 'num'strOrnum = 2123 数字数组number[]123let arrOfNumbers: number[] = [1, 2, 3]arrOfNumbers.push(5)arrOfNumbers.push('6') //报错，必须是数字 类数组12345678function test() &#123; console.log(arguments); //arguments 就是一个类数组 // 可以用arguments.length // 但是没有数组的方法 let arr: any[] = arguments //这样会报错&#125; 元组1let user: [string, number] = ['viking', 123] interface 接口 对对象的形状(shape)进行描述对类(class) 进行抽象Duck typing (鸭子类型) 12345678interface Person &#123; name: string; age: number;&#125;let viking: Person = &#123; name: 'viking', age: 18&#125; 可选属性?1234interface Person &#123; name: string; age?: number;&#125; 只读属性readonly12345678910111213interface Person &#123; readonly id: number; name: string; age?: number;&#125;// readonly 是加在前面let obj: Person = &#123; id: 0, name: 'string', age: 18&#125;obj.id = 2 // 报错，不可修改 const 和 readonly的区别是，const是用在变量上面，readonly是用在属性上面 函数函数的构成，输入，和返回 123456// 函数声明function add(x:number, y: number): number &#123; return x + y&#125;let result = add(2, 3) 可选参数1234567function add(x:number, y: number, z?: number): number &#123; if (typeof z === 'number') &#123; return x + y + z &#125; return x + y&#125;// 可选参数，必须是最后一个，不能更改顺序 函数表达式123456const add = function add(x:number, y: number): number &#123; return x + y&#125;const add2: (x: number, y: number, z?: number) =&gt; number = add// 出现的`=&gt;`不是ES6的箭头函数，而是ts提供的写法 类 class类(Class): 定义了一切事物的抽象特点对象(Object): 类的实例面向对象(OOP): 三大特性: 封装、继承、多态封装: 数据操作细节隐藏，仅暴露对外的接口，外界调用端不需要知道细节，就可以用对外提供的接口来访问对象继承: 子类继承父类，子类除了拥有父类的所有特性外，还有一些更加具体的特性多态: 是由继承而产生的相关的不同的类，对同一个方法呢可以有不同的响应，比如猫和狗都继承自动物,但是他们分别实现了自己吃的方法，此时针对某一个实例，我们无需了解他是猫还是狗，我们可以直接调用吃方法，程序就会自动判断出如何正确执行吃方法 12345678910111213141516171819202122232425262728293031323334353637class Animal &#123; name: string; constructor(nam: string) &#123; this.name = nam &#125; run() &#123; return `$&#123;this.name&#125; is runing` &#125;&#125;// 实例化const snake = new Animal('snake')class Dog extends Animal &#123; bark() &#123; return `$&#123;this.name&#125; is barking` &#125;&#125;const xiaobao = new Dog('xiaobao')console.log(xiaobao.run());console.log(xiaobao.bark());// 重写runclass Cat extends Animal &#123; constructor (name: string) &#123; super(name) console.log(this.name); &#125; run () &#123; return 'Meow, ' + super.run() &#125;&#125;const maomao = new Cat('maomao')console.log(maomao.run());//多态：我们不用关注调用run的时候他是猫还是狗，系统会自动判断执行正确方法 类里面用到的修饰符 默认是 public有些属性或方法，不愿意对外访问就要用到private 只能在类里面访问，子类都不能访问如果希望子类可以访问，就要用到protected如果想让属性只能访问不能修改，可以用readonly静态属性(ES6也有？),不用实例也可以访问123class Animal &#123; static categoies: string[] = ['mammal','bird']&#125; 静态方法12345678class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal &#125;&#125;const snake = new Animal('li')console.log(Animal.isAnimal(snake)); 类和接口123456789101112131415161718192021interface Radio &#123; switchRadio(): void&#125;interface RadioWithBattery extends Radio &#123; checkBatteryStatus(): void&#125;class Car implements Radio &#123; switchRadio() &#123; &#125;&#125;class Cellphone implements RadioWithBattery &#123; switchRadio() &#123; &#125; checkBatteryStatus() &#123; &#125;&#125; interface 接口对对象的形状(shape)进行描述对类(class)进行抽象Duck Typing(鸭子类型) 鸭子类型：只要你走起来像鸭子,叫起来像鸭子，我就不管你是什么东西，我就可以用它来约束各种概念上毫不相关内容 枚举数字枚举123456enum Direction &#123; Up, Down, Left, Right&#125; 常量枚举123456const enum Direction &#123; Up, Down, Left, Right&#125; 枚举分两种，只有常量值可以常量枚举，计算值不能使用常量枚举不可以加const，上面讲的都是常量值，计算值后面用到了讲 泛型(最难的部分)动机，要解决什么问题(太NICE了，比那个好多了)12345function name(num:number): number &#123; return num&#125;const sr = name(123);// 如果我们要传入字符串、布尔、复杂类型，就要使用到any，那样就会导致sr常量就会丧失类型，泛型就是解决这种问题的 泛型: 是指在定义函数接口或类的时候，我们不预先指定具体类型，而是在使用的时候再指定类型的一种特征老师讲的很通透，感觉挺简单？123456789function names&lt;T&gt;(num:T): T &#123; return num&#125;const sr = names('123')// 现在不管我们传入什么，ts类型推断都会帮我们推断出常量的类型function names&lt;T, U&gt;(params:[T, U]): [U, T] &#123; return [params[1], params[0]]&#125;const sr = names(['number', 123]) //类型推断 [number, string] 更深入的用法只能传入数组12345function echoWithArr&lt;T&gt;(arg: T[]): T[] &#123; arg.length return arg&#125;const arr = echoWithArr([1, 2]) //只能传入数组 这种方法就可以传入带length属性的类型参数12345678910interface Length &#123; length: number&#125;function echoWithArr&lt;T extends Length&gt;(arg: T): T &#123; arg.length return arg&#125;const str = echoWithArr('str')const obj = echoWithArr(&#123;length: 1&#125;)const arr2 = echoWithArr([1, 2, 3]) 在类里面使用泛型为什么要用到123456789101112131415161718192021222324252627class Queue &#123; private data = [] push(item) &#123; return this.data.push(item) &#125; pop() &#123; return this.data.shift() &#125;&#125;const queue = new Queue()queue.push(1)queue.push('srt')console.log(queue.pop().toFixed());console.log(queue.pop().toFixed());// 这里就会报错，因为第二个值是string，string没有toFixed方法// 简单修改class Queue &#123; private data = [] push(item: number) &#123; return this.data.push(item) &#125; pop(): number &#123; return this.data.shift() &#125;&#125;// 这样也可以，如果需求传入更多参数，会变得很麻烦 使用泛型类12345678910111213class Queue&lt;T&gt; &#123; private data = [] push (item: T) &#123; return this.data.push(item) &#125; pop(): T &#123; return this.data.shift() &#125;&#125;const queue = new Queue&lt;number&gt;()queue.push(1)console.log(queue.pop().toFixed()); interface 泛型123456789interface KeyPair&lt;T, U&gt; &#123; key: T; value: U;&#125;let kp1: KeyPair&lt;number, string&gt; = &#123; key: 123, value: 'str'&#125; 泛型数组12let arr: number[] = [1, 2]let arr: Array&lt;number&gt; = [1, 2] 泛型描述函数123456789interface IPlus &#123; (a: number, b: number): number&#125;function plus(a:number, b: number): number &#123; return a + b&#125;const a: IPlus = plus 泛型interface 结合泛型描述函数123456789interface IPlus&lt;T&gt; &#123; (a: T, b: T): T&#125;function plus(a:number, b: number): number &#123; return a + b&#125;const a: IPlus&lt;number&gt; = plus 类型别名// type aliases12345type PlusType = (x: number, y: number) =&gt; numberfunction sum(x: number y:number): number &#123; return x + y&#125;const sum2: PlusType = sum 如果一个函数要接受参数比较复杂，比如联合类型接收一个函数，就要用到类型别名123456789type NameResolver = () =&gt; stringtype NameOrResolver = string | NameResolverfunction getName(n: NameOrResolver): string &#123; if (typeof n === 'string') &#123; return n &#125; else &#123; return n() &#125;&#125; 类型断言// type assertion1234567function ls(s: number | string) &#123; // s.length 这样会报错，因为联合类型number没有length (s as string).length //这样就ok了 (&lt;string&gt;s).length // 好像也没有比as简单。。&#125; 声明文件后缀为.d.ts的文件ts都会解析如果用到jQuery的话，直接写会报错，要声明1declare var jQuery: (selector: string) =&gt; any tsconfig.json 配置文件1234&#123; "include" : ["**/*"]&#125;// 这个字段就是告诉编译器，帮我们编译当前文件夹下的所有文件 官方也为我们准备好了声明文件比如@type/jquery就是jquery的声明文件 查看声明文件的一个网址 React + typescriptts组件，太好用了123456789101112131415161718192021import React from 'react'interface IHelloProps &#123; message?: string;&#125;// const Hello = (props: IHelloProps) =&gt; &#123;// return &lt;h2&gt;&#123;props.message&#125;&lt;/h2&gt;// &#125;// React.FC是React.FunctionComponent的别名// React.FC 内置了很多方法，很有用，目前就讲了defaultProps// ts可以直接替代以前的propTypes(类型检查)const Hello: React.FC&lt;IHelloProps&gt; = (props) =&gt; &#123; return &lt;h2&gt;&#123;props.message&#125;&lt;/h2&gt;&#125;Hello.defaultProps = &#123; message: 'Hello word'&#125;export default Hello 自定义hook必须use开头 高阶组件HOC就是一个函数，接受一个组件作为参数，返回一个新的组件 项目开始安装命令12npx create-react-app q --TypeScript //未来会弃用，使用下面的命令npx create-react-app q --template typescript 安装了classnames 插件，还要安装附属的typescript12yarn add classnames -Syarn add @types/classnames -S 代码方面倒是挺简单，样式是直接复制的12345678910type NativeButtonProps = BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLElement&gt;type AnchorButtonProps = BaseButtonProps &amp; React.AnchorHTMLAttributes&lt;HTMLElement&gt;export type ButtonProps = Partial&lt;NativeButtonProps &amp; AnchorButtonProps&gt;;// ButtonHTMLAttributes，AnchorHTMLAttributes button和a元素所有的附加属性，写起来还// 会有代码提示, 用起来效果很NICE// 此块代码的位置在项目的Button组件里面 q/src/components/Button/button.tsx:24// Partial&lt;T&gt; 把里面的属性全部变成可选属性，难道以前的属性不是可选吗？(经测试，以前的属性都是可选的，所以这个算是多余代码，没必要。当然老师的意思估计是了解把)// 为什么不直接一行解决？例如：// type AllButtonProps = Partial&lt;BaseButtonProps &amp; React.ButtonHTMLAttributes&lt;HTMLElement&gt; &amp; React.AnchorHTMLAttributes&lt;HTMLElement&gt;&gt;// 可以一行解决，还要写这么多，估计是好理解，确实 测试测试框架有很多，这次用到的是一个后起之秀JEST create react app 用的就是这个测试工具已经内置了jest测试工具12npx jest jest.test.js //用于测试npx jest jest.test.js --watch //一直运行，保存一次运行一次 ReactTestUtils 可搭配测试框架使用，比如jest，官网推荐使用React Testing Library 也算是后起之秀也可以使用Enzyme create react app 3.0已经内置了React Testing Library了 三种文件会被自动认为是测试文件 在tests文件夹下面的.js，.ts文件 使用.test.js结尾的文件 使用.spec.js结尾的文件 jest dom增加新的dom断言,这个库也已经内置了 插曲：设置npm代理(不上代理，总感觉很慢)，同时yarn没有任何设置，但是执行命令也是走的代理，挺奇怪的12345678910npm config set proxy http://127.0.0.1:10809npm config set https-proxy http://127.0.0.1:10809// 第二句不设置也行，暂时没出问题，但是还是设置上为好// 而且要配置,不然sudo执行命令的适合，不会使用代理sudo npm config set proxy http://127.0.0.1:10809sudo npm config set https-proxy http://127.0.0.1:10809// 删除代理npm config delete proxynpm config delete https-proxy// 同理sudo也要删除一遍 linux | ubuntu 设置全局代理 12345678910# 修改shell配置文件 ~/.bashrc ~/.zshrc等export http_proxy=socks5://127.0.0.1:1024export https_proxy=$http_proxy# 设置setproxy和unsetproxy 可以快捷的开关# 需要时先输入命令 setproxy# 不需要时输入命令 unsetproxyalias setproxy="export http_proxy=socks5://127.0.0.1:1024; export https_proxy=$http_proxy; echo 'HTTP Proxy on';"alias unsetproxy="unset http_proxy; unset https_proxy; echo 'HTTP Proxy off';"# 设置快捷开关这个倒是不错的想法，不过目前没有应用场景，用上倒是可以借鉴 nvm因为不能sudo执行，安装的node也不能用sudo命令访问，要通过软链接才行 123# $NVM_DIR 这些常量是.nvm的目录，后面的$(nvm version)，版本号，挺讨巧的sudo ln -s "$NVM_DIR/versions/node/$(nvm version)/bin/node" "/usr/local/bin/node"sudo ln -s "$NVM_DIR/versions/node/$(nvm version)/bin/npm" "/usr/local/bin/npm" sudo时无法使用代理 12#在/etc/sudoers中，env_reset下添加Defaults env_keep="http_proxy https_proxy ftp_proxy no_proxy 上次看的是jest测试，还是结合react的测试更有趣，让我知道了用处 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import React from 'react'import &#123; render, fireEvent &#125; from '@testing-library/react'import Button, &#123; ButtonProps, ButtonSize, ButtonType&#125; from './button'// jest.fn() 创建出一个被监控的模拟函数const defaultProps = &#123; onClick: jest.fn()&#125;// 这里用 ButtonProps 是因为会有代码提示，判断什么类型很方便const testProps: ButtonProps = &#123; btnType: ButtonType.Primary, size: ButtonSize.Large, className: 'names',&#125;const disabledProps: ButtonProps = &#123; disabled: true, onClick: jest.fn()&#125;// 分类测试describe('test Button component', () =&gt; &#123; // test 简写也可以是it it('should render the correct default button', () =&gt; &#123; const wrapper = render(&lt;Button &#123;...defaultProps&#125;&gt;Nice&lt;/Button&gt;) const element = wrapper.getByText('Nice') //测试文本 expect(element).toBeInTheDocument() //判断组件是否在文档中 expect(element.tagName).toEqual('BUTTON') //判断元素是否为BUTTON expect(element).toHaveClass('btn btn-default') //判断class 是否含有btn btn-default fireEvent.click(element) // 模拟点击 expect(defaultProps.onClick).toHaveBeenCalled() // 判断是否处罚点击事件 &#125;) it('should render the correct component based on different props', () =&gt; &#123; const wrapper = render(&lt;Button &#123;...testProps&#125;&gt;Nice&lt;/Button&gt;) const element = wrapper.getByText('Nice') expect(element).toBeInTheDocument() expect(element).toHaveClass('btn-primary btn-lg names') &#125;) it('should render a link when btnType equals link and href is provided', () =&gt; &#123; const wrapper = render(&lt;Button btnType=&#123;ButtonType.Link&#125; href="http//www.google.com"&gt;Link&lt;/Button&gt;) const element = wrapper.getByText('Link') expect(element).toBeInTheDocument() expect(element.tagName).toEqual('A') expect(element).toHaveClass('btn btn-link') &#125;) it('should render disabled button when disabled set to true', () =&gt; &#123; const wrapper = render(&lt;Button &#123;...disabledProps&#125;&gt;Nice&lt;/Button&gt;) const element = wrapper.getByText('Nice') as HTMLButtonElement // 返回一个HTMLElement，但是我们要用到disabled，而且我们认为必返回Button，所以我们可以使用类型断言，把他变成一个button expect(element).toBeInTheDocument() expect(element.disabled).toBeTruthy() fireEvent.click(element) expect(disabledProps.onClick).not.toHaveBeenCalled() // 因为是disabled属性，所以这里用到了not，表示没有被点击 &#125;)&#125;) 插曲：批量更改文件名，shell脚本文件结构 123大秧歌 - 01.mkv - 01.mkv.xls IDM/shell.sh:123456#!/bin/bashfor l in `ls 大秧歌` do mv 大秧歌/$l/`ls 大秧歌/$l` 大秧歌压缩/`ls 大秧歌/$l | sed 's/....$//' | sed 's/^/大秧歌./'`done 优化代码:1234567#!/bin/bashmkdrname='大秧歌'for l in `ls $mkdrname` do mv $mkdrname/$l/`ls $mkdrname/$l` $mkdrname压缩/`ls $mkdrname/$l | sed 's/....$//' | sed 's/^/'$mkdrname'./'`done 如果是直接命令输出脚本，则要用echo关键字比如大秧歌目录下执行命令如下:1for s in `ls`; do mv $s `echo $s | sed 's/^/大秧歌./'`; done 处理带有空格文件的时候会循环错误，一个文件有几个空格就循环几次 123456789101112for folder in `ls|tr " " "?"` do # 如果所目录的情况 folder=$&#123;folder//'?'/' '&#125; cd "$folder"done ## 先把空格用特殊符号代替，然后替换即可。 使用cd时需要添加双引号 先把空格用特殊符号代替，然后替换即可。使用cd时需要添加双引号 PS 改进后 处理带有空格的文件名 1for s in `ls|tr " " "?"`; do mv "$s" `echo $s | sed 's/..$//'`; done 研究了半天，终于搞懂了 图标Icon解决方案font 字体已经过时 svg 可以采用 Font Awesome react-fontawesome 123456789import &#123; fas &#125; from &apos;@fortawesome/free-solid-svg-icons&apos;import &#123; library &#125; from &apos;@fortawesome/fontawesome-svg-core&apos;import &#123; FontAwesomeIcon &#125; from &apos;@fortawesome/react-fontawesome&apos;library.add(fas)// fas代表了引入所有图标，然后就可以很轻松的用字符串代替了&lt;FontAwesomeIcon icon=&apos;coffee&apos;/&gt;// 或者是这样import &#123; faCoffee &#125; from &apos;@fortawesome/free-solid-svg-icons&apos;&lt;FontAwesomeIcon icon=&apos;faCoffee&apos;/&gt; Sass的each循环 创建一个With Maps 12345678910111213141516171819// _variables.scss$theme-colors: ( "primary": $primary, "secondary": $secondary, "success": $success, "info": $info, "warning": $warning, "danger": $danger, "light": $light, "dark": $dark)// Icon/_style.scss@each $key, $val in $theme-colors &#123; .icon-#&#123;$key&#125; &#123; color: $val; &#125;&#125; React中制作动画 动画间隙，这个东西具体叫什么忘记了，不过vue学过，忘了，行吧，不过这东西react的挺简单的 官网插件推荐 react-transition-group这个库用的最多 123yarn add react-transition-groupyarn add @types/react-transition-group 这个typescript的插件官网没有介绍 我人傻了，居然是classNames,我写成className 导致了子组件的className被替代，我还以为组件升级写法变了，研究半天，莫名其妙 12345678&lt;CSSTransition in=&#123;menuOpen&#125; timeout=&#123;300&#125; classNames=&apos;zoom-in-top&apos; // 致命错误classNames 不是 className appear &gt; &lt;ul className=&#123;subMenuClasses&#125;&gt;&#123;childrenComponent&#125;&lt;/ul&gt;&lt;/CSSTransition&gt; 莫名其妙的报错，findDomNode React官方的解释，没看懂 react-transition-group的解决方法是4.4.0 换种写法 挺奇怪的，为什么官方不自己封装一下，肯定有其他用处 12345678fucntion SubMenu ()&#123; const nodeRef = React.useRef(null) return ( &lt;CSSTransition nodeRef=&#123;nodeRef&#125;&gt; &lt;div ref=&#123;nodeRef&#125;&gt;&lt;/div&gt; &lt;/CSSTransition&gt; )&#125; storybookstorybook.js.org 12npx sb init安装不成功就换个节点。前面几次都没成功，换了个节点好了 12git diff查看变化，Q退出 真是醉了，搞了半天的styorbook 的props显示问题，老师解决起来很麻烦，因为用的旧版本，新版本直接集成了，谁知道居然也这么麻烦，官方文档也没提，导出的时候不能export default导出，不然就会显示寥寥无几的props，直接导出组件就行了export,还有就是默认值的问题，如果用元组enum的话，就会导致默认值是一个变量，很不好理解，目前解决办法就是用type声明，不用元组就ok了 自动完成input1234567891011121314151617// 忽略值Omit&lt;InputHTMLAttributes&lt;HTMLElement&gt;, 'size'&gt;// 目前用到的场景，继承的时候这个值和当前接口size冲突，必须改名或者这种解决// omit删除inputHTMLAttributers中的size属性export interface InputProps extends Omit&lt; React.InputHTMLAttributes&lt;HTMLElement&gt;, 'size' &gt; &#123; disabled?: boolean size?: 'lg' | 'sm' icon?: IconName prefixs?: string | React.ReactElement append?: string | React.ReactElement theme?: ThemeProps&#125;因为size属性和input默认属性冲突，所以这里要忽略 Omit&lt;&gt; input 表单，优化 课程9-3节，对应文件路径src/components/Input/*.tsx onChange如果是input表单上面用，会导致e参数是HTMLElement类型，自己增加一个类型检测就行了 1234// input.tsxexport interface InputProps extends Omit&lt;React.InputHTMLAttributes&lt;HTMLElement&gt;, 'size'&gt; &#123; onChange?: (e: React.changeEvent&lt;HTMLInputElement&gt;) =&gt; void&#125; 受控组件 Controlled Components 我的理解是有value，就是受控组件，defaultValue就是非受控组件 如果自己写的组件让别人用，同时输入以上两个参数，就会报错，所以我们必须优化代码，其实我觉得没必要 123456789// input.stories.tsximport React from &apos;react&apos;export const Input: React.FC&lt;InputProps&gt; = (props) =&gt; &#123; const &#123;...restProps&#125; = props if (&apos;value&apos; in props) &#123; // 如果有value这个值 delete restProps.defaultValue // 就删除defaultValue &#125; return &lt;&gt;&lt;input &#123;...restProps&#125;&gt;&lt;/&gt;&#125; 如果使用的时候state传入参数为undefined或者null也会上述报错，undefined 被识别为非受控组件 使用： 1234567// input.stories.tsxconst inputTemplate: Story&lt;InputProps&gt; = args =&gt; &#123; const [value, setValue] = useState() //如果这里是空，参数类型就会变成`undefined` return ( &lt;Input &#123;...args&#125; value=&#123;value&#125; onChange=&#123;e =&gt; setValue(e.target.value)&#125; /&gt; // 这样赋值就会报错，因为value类型是undefind，而e.target.value类型是string, 其二 页面改变input值也会warning非受控组件被修改问题 )&#125; 修复： 1234567891011// input.tsxconst valueDefault = (value: any) =&gt; &#123; if (value === &apos;undefined&apos; || value === null) &#123; return &apos;&apos; &#125; return value&#125;if(&apos;value&apos; in props) &#123; delete restProps.defaultValue restProps.value = valueDefalt(restProps.value) //主要代码是这里&#125; 测试的一个小bugmenu.test.tsx中94行expect(wrapper.queryByText(‘drop1’)).not.toBeVisible()报错，理所应当，因为必须要鼠标事件才会显示，以前不知道为什么没发现，写完没测试？？不应该啊 后面还有一个报错waitFor error “MutationObserver is not a constructor” with latest version 这个原因是jsdom依赖的jest版本低，可以用一个很麻烦的方法解决，另一个就是更新react-scripts，和jest来解决，我用的第二种 1234567yarn upgrade react-script@^ - 4.0.1 # 目前的最新版,此版本依赖jest 26.6.0yarn upgrade jest@^ - 26.6.0查看版本以及依赖，npm ls jsdom// 上面这种更新用法，会导致package不更新，遗留问题？，我好像遇到了，后面用，又消失了这个bug 发现一个新写法，还挺好看+简洁源文件写法：src\components\Input\input.tsx 12345678const cnames = classNames(&apos;viking-input-wrapper&apos;, &#123; [`input-size-$&#123;size&#125;`]: size, &apos;is-disabled&apos;: disabled, &apos;input-group&apos;: prepend || append, &apos;input-group-append&apos;: !!append, &apos;input-group-prepend&apos;: !!prepend&#125;)// !!双感叹号，是因为append是string类型，一个感叹号变为布尔值，另一个感叹号变为真正的true还是false，有点绕口，不知道该怎么解释。 这里是另一个ts教程笔记，弃用 安装12npm i typescript -gtsc -V 基础类型布尔值1let isDone: boolean = true 数字1let decLiteral: number = 20 字符串12let name: string = 'bob'name = 'smith' 数组123// 这两种写法等价let list: Array&lt;number&gt; = [1, 2, 3]let list: number[] = [1, 2, 3] 元组 Tuple12let x: [string, number]x= ['hello', 10] 枚举12345678910enum Color &#123; Red, Green, Blue&#125;// let c: Color = Color[2]let c: string = Color[2]console.log(c) any123let notSure: any = 4notSure = 'maybe a string instead'notSure = false 12let list: any[] = [1, true, 'free']list[1] = 100 void 123function warnUser(): void &#123; //没有返回值的函数 console.log('This i my waring message')&#125; null 和 undefined12let u: undefined = undefinedlet n: null = null never 永远不存在123456function error(message: string): never &#123; throw new Error(message);&#125;function fail() &#123; return error('something faild')&#125; object123456789declare function create(o: object | null) : void;//原始类型 非原始类型create(o: &#123;prop: 0&#125;)create(o: null)//基础类型 不行create(o: 42)create(o: 'string')create(o: false)create(o: undefined) 类型断言123let someValue: any = 'string'// let strLength: number = (&lt;string&gt;someValue).lengthlet strLength: number = (someValue as string).length 12let num: number = 3num = null 编译12tsc greeter.ts // 这么是不会报错的tsc greeter.ts --strictNullChecks //这么编译就会出错，就要用到联合类型，就不会报错了 联合类型12let num: number | null = 3num = null 接口1234interface Square &#123; color: string area: number&#125; 可选参数1234interface SquareConfig &#123; color: string width?: number&#125; 完整实例12345678910111213141516171819202122interface Square &#123; color: string area: number&#125;interface SquareConfig &#123; color?: string width?: number&#125;function createSquear(config: SquareConfig): Square &#123; let newSquear = &#123; color: 'white', area: 100 &#125; if (config.color) &#123; newSquear.color = config.color &#125; if (config.width) &#123; newSquear.area = config.width &#125; return newSquear&#125;console.log(createSquear(&#123;color: 'red'&#125;)) 只读属性,创建完成之后就不能再改变了12345678interface Point &#123; readonly x: number readonly y: number&#125;let p1: Point = &#123; x: 10, y: 20 &#125;p1.x = 2 // 报错，尝试对一个只读属性修改 泛型只读数组1234let a: number[] = [1, 2, 3, 4]let ro: ReadonlyArray&lt;number&gt; = aro[0] = 12 // 编译报错a = ro as number[] // 这样可以，类型断言 额外属性检查索引签名123456789// 这段代码要和上面的完整实例结合使用interface SquareConfig &#123; color?: string width?: number [propName: string]: any // 索引签名&#125;console.log(createSquear(&#123;color: 'red', colorus: 'names'&#125;)) 函数类型接口123456789101112131415interface SearchFunc &#123; (source: string, subString: string): boolean&#125;let mySearch: SearchFuncmySearch = function (src, sub) &#123; let result = src.search(sub) return result &gt; -1&#125;// 不使用接口实现mySearch = function (source: string, subString: string): boolean &#123; let result = src.search(sub) return result &gt; -1&#125; 索引签名123456789interface StringArray &#123; [index: number]: string&#125;let myArray: StringArraymyArray = ['Bob', 'Fred']let myStr: string = myArray[0] 遇到的问题，搞不懂，先记录下来同时拥有string和number类型的索引签名，number索引返回值必须是string索引返回的子类型，因为当用一个数字索引时，js实际会在索引到对象之前将其转换为字符串 1234567891011121314interface Animal &#123; name: string;&#125;interface Dog extends Animal &#123; breed: string;&#125;// Error: indexing with a numeric string might get you a completely separate type of Animal!interface NotOkay &#123; [x: number]: Animal;Numeric index type 'Animal' is not assignable to string index type 'Dog'. [x: string]: Dog;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-learn]]></title>
    <url>%2Fblog%2F2019%2F06%2F04%2FReact-learn%2F</url>
    <content type="text"><![CDATA[React学习笔记]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法与数据解构初识]]></title>
    <url>%2Fblog%2F2019%2F05%2F26%2F%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%84%E5%88%9D%E8%AF%86%2F</url>
    <content type="text"><![CDATA[算法与数据解构初始jest 做测试，一些简单的测试，原因是有大量的js代码，如果逐个复制到浏览器，操作麻烦，而且不方便，测试可以提供工作效率字符串，数组，正则都属于基本类型，排序，递归属于常见的算法，这个顺序是由简单到难的一个顺序]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 协议]]></title>
    <url>%2Fblog%2F2019%2F05%2F18%2FHTTP-%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[get 获取数据post 创建数据put 更新数据delete 删除应该这么做，实际上不按照方法去实现，语义存在的意义，就是希望别人用的时候，一眼就看有看出来干什么的， HTTP CODE100-199之间代表操作要持续进行，接下来要做一些其他事情才会返回给你200-299 代表操作成功300-399 代表操作重定向，有别的方式获取数据400-499 发送请求有问题，401发送请求的时候没有认证，没有权限获取资源的内容500-599 服务器出现问题 curlcurl -v www.baidu.com]]></content>
  </entry>
  <entry>
    <title><![CDATA[koa2 + vue2.5 + mongodb 开发记录]]></title>
    <url>%2Fblog%2F2019%2F05%2F06%2Fkoa2-vue2-5-mongodb-%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[后端环境搭建node使用import语法@vue/cli 耦合，他会使用babel.config.js，而不会使用.babelrc，而且在babel.config.js 中配置会报错，所以要package.json 里面这样写12345script: &#123; "start-koa": "nodemon --exec babel-node server/index.js --config-file ./.babelrc", "build-koa": "babel src --out-dir dist", "serve-koa": "node dist/server.js"&#125; –config-file [path] 指定配置文件要安装的包12345@babel/cli@babel/core@babel/node //新版本抽离出来了@babel/preset-env nodemon .babelrc123&#123; "presets": ["@babel/preset-env"]&#125; 12]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试问题]]></title>
    <url>%2Fblog%2F2019%2F04%2F19%2F%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[记录一些学习过程中遇到的面试问题 暂存死区123456let monkey = '我是美猴王';&#123; console.log(monkey); //按道理应该取外面的let，但是输出'monkey is not defined' let monkey = '我觉得还能抢救一下';&#125;console.log(monkey); ES6中规定，如果块级作用域中存在let，const声明的变量，这个变量一开始就会形成一个封闭的作用域，即使向上的作用域中存在同名的变量，也是拿不到的 生成十给按钮，每个按点击的时候弹出 1-10ES51234567891011var i = 0;for (i = 1; i &lt;= 10; i++) &#123; (function(i) &#123; var btn = document.createElement('button'); btn.innerText = i; btn.onclick = function() &#123; alert(i) &#125;; document.body.appendChild(btn); &#125;)(i)&#125; ES612345678for (let i = 1; i &lt;= 10; i++) &#123; let btn = document.createElement('button'); btn.innerText = i; btn.onclick = function() &#123; alert(i) &#125;; document.body.appendChild(btn);&#125;]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>js</tag>
        <tag>html</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动webapp]]></title>
    <url>%2Fblog%2F2019%2F04%2F12%2F%E7%A7%BB%E5%8A%A8webapp%2F</url>
    <content type="text"><![CDATA[移动webapp开发 视口viewport 标签的介绍1&lt;mate name="viewport" content="width=device-width"&gt; width=device-width 视口宽，自适应1&lt;mate name="viewport" content="height"&gt; 很少用height，基本不用1&lt;mate name="viewport" content="initial-scale=1"&gt; initial-scale=1 缩放比相当于设置width=device-width，但是用的时候都得写，因为个浏览器有bug1&lt;mate name="viewport" content="user-scalable=no"&gt; 不允许用户缩放1&lt;mate name="viewport" content="maximum-scale=1, minimum-scale=1"&gt; 最大缩放比，和最小缩放比 标准写法12&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, maximum-scale=1, minimum-scale=1"&gt;` 获取视口宽度1234567console.log(window.innerWidth);console.log(document.documentElement.clientWidth);console.log(document.documentElement.getBoundingClientRect().width);// 兼容个浏览器写法var width = document.documentElement.clientWidth || window.innerWidth// dprconsole.log(window.devicePixelRatio); Flex 布局，弹性布局这个box就为flex的container容器123.box &#123; display: flex | inline-flex&#125; flex布局属性flex-direction 决定主轴方向row: 默认值row-reverse: 主轴为水平方向，起点在右端column: 主轴水平方向变为垂直方向，起点在上column-reverse: 主轴为垂直方向，起点在下 flex-wrap 换行一条轴线排不下，是否换行nowrap: 不换行，默认值wrap: 换行wrap-reverse: 相反换行 flex-flow 简写，上面两种属性的简写123.box &#123; flex-flow: row nowrap; //默认值&#125; justify-content 属性定义了项目在主轴上的对齐方式 常用flex-start: 默认值flex-end: 右对齐center: 居中space-between: 两端对齐space-around: 每个项目两侧间隔相等 align-items 交叉轴对齐方式flex-start: 不是默认值flex-end: 交叉轴终点对其center: 中点对齐baseline: 项目的第一行文字的基线对其stretch: 默认值，项目未设置高度或设为auto，将沾满整个容器的高度 align-content 多根轴线对齐方式(多行)，如果项目只有一根轴线，则不起作用属性值和justify-content一致, 默认值为stretch 项目属性### order 属性定义项目的排列顺序，数值越小，排列越靠前，默认为0123.item-1 &#123; order: -1;&#125; flex-grow 默认值为0，类似于，栅格系统，不过更灵活123456.item-1 &#123; flex-grow: 1;&#125;.item-2 &#123; flex-grow: 2; //2的值就占用项目.item-1的二倍&#125; 如果有固定宽度，则减去这个固定宽度，等分其他空间如果两个值都为1，则总共有两份，大家都占用了2/1空间， flex-shrink 默认值为1，属性定位缩小比例，和flex-grow是相反的123.item-1 &#123; flex-shrink: 0; //不缩放该项目&#125; flex-basis 默认值为auto,项目占据的主轴空间，如果有width属性，就会覆盖width属性, 浏览器根据这个属性，计算主轴是否有多余空间flex 是前面3给的简写，不算order123.item-1 &#123; flex: 1; //相当于flex: 1 1 auto; 相当于 flex: auto&#125; align-self 默认auto, 表示继承align-items, 可覆盖align-items, 如果没有父元素，则等同于stretch属性都可以借鉴align-items 媒体查询1@media screen and (min-width: 900px) &#123;&#125; screen 屏幕类型，除了屏幕打印设备和阅读设备 默认值all(default)screen / print(打印预览，可以做简历) /speech(阅读设备，残障人士使用)1@media all and (min-width=900px) &#123;&#125; all因为是默认值，可以不写1@media (min-width=900px) &#123;&#125; 媒体查询中的逻辑与(and)或(,)非(not) 或写法：1@media screen and (min-width=1024px), (max-width:900px) &#123;&#125; 值得注意的是，或(,)之后的算是个体，也就是说，我们使用了默认值all的写法 非写法：1@media not screen and (min-width=1024px), (max-width:900px) &#123;&#125; 同理，只是前半段，或之后算一个整体 媒体特征表达max-width, min-width, width设备像素比dpr-webkit-device-pixel-ratio: 2,-webkit-max-device-pixel-ratio: 2,-webkit-min-device-pixel-ratio: 2 orientation有两个值：landscape 横屏(宽比高大)，portrait 竖屏后面还有值，几乎不用，了解即可，这里就没有记录，要看的就是3-19 媒体查询-基础(2).vep 媒体查询策略设置断点xs: &lt; 576pxsm: 576px ~ 768pxmd: 768px ~ 992pxlg: 992px ~ 1200pxxl: &gt; 1200px 12345678910@medio screen and (max-width=576px) &#123;&#125;@medio screen and (min-width=577px) and (max=768px) &#123;&#125;@medio screen and (min-width=769px) and (max=992px) &#123;&#125;@medio screen and (min-width=993px) and (max=1200px) &#123;&#125;@medio screen and (min-width=1201px) &#123;&#125; 移动端单位问题em的技巧1234.font &#123; font-size: 16px; text-indent: 2em; //这个em就会继承当前元素字体的大小，也就是2个字节，很方便啊&#125; rem主流这么写，内容就可以根据宽度自适应变化，666，公式就是：(当前页面宽度/375) * 20 这个比例，为什么是这个比例呢12345678910111213141516171819 &lt;style type="text/css" media="screen"&gt; html &#123; font-size: 20px; &#125; .box &#123; width: 2.5rem; height: 2.5rem; background: #222; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="box"&gt;&lt;/div&gt; &lt;script type="text/javascript"&gt; window.onresize = function() &#123; document.documentElement.style.fontSize = (document.documentElement.clientWidth / 375)* 20 +'px'; &#125; &lt;/script&gt; 响应开发，因为都懂，就记一些不懂的吧img图片的处理12345678img &#123; display: block; /*因为默认是inline-block;*/ /*但是这样解决会造，一行显示换行问题*/ /*最优解决*/ vertical-align: top; /*这个属性居然没用过，而且所有浏览器都支持*/ width: 100%; border: none;&#125; 以上选一即可 通用适配设计稿750px为例750px 1rem = 750 / 18.75 = 40js动态去设置font-size12345678910111213141516// document.documentElement.getBoundingClientRect().width// window.innerWidth(function() &#123; 'use str' setRemUnit() window.onresize = setRemUnit; // window.addEventListener('resize', setRemUnit); 都可以 function setRemUnit() &#123; var docEl = document.documentElement; var ratio = 18.75; var viewWidth = docEl.getBoundingClientRect().width || window.innerWidth; //兼容处理 docEl.style.fontSize = viewWidth / ratio + 'px' &#125;&#125;)(); 通用适配解决方案，解决1px边框显示过’粗’问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152(function() &#123; 'use str'; // 获取dpr var docEl = document.documentElement, viewportEl = document.querySelector('meta[name="viewport"]'), dpr = window.devicePixelRatio || 1, maxWidth = 540, minWidth = 320; dpr = dpr &gt;= 3 ? 3 : (dpr &gt;= 2 ? 2 : 1); docEl.setAttribute('data-dpr', dpr);// 自己设置dpr，后面有用处 docEl.setAttribute('max-width', maxWidth); docEl.setAttribute('min-width', minWidth); var scale = 1/dpr, content = 'width=device-width, initial-scale='+ scale +', maximum-scale='+ scale +', minimum-scale='+ scale +', user-scalable=no'; if (viewportEl) &#123; viewportEl.setAttribute('content', content) &#125; else &#123; viewportEl = document.createElement('meta'); viewportEl.setAttribute('name', 'viewport'); viewportEl.setAttribute('content', content); document.head.appendChild(viewportEl) &#125; setRemUnit() window.onresize = setRemUnit; // window.addEventListener('resize', setRemUnit); 都可以 function setRemUnit() &#123; // var docEl = document.documentElement; var ratio = 18.75; var viewWidth = docEl.getBoundingClientRect().width || window.innerWidth; //兼容处理 // 设置最大最小值，页面过大后不设置fontSize if (maxWidth &amp;&amp; (viewWidth / dpr &gt; maxWidth)) &#123; viewWidth = maxWidth * dpr; &#125; else if (maxWidth &amp;&amp; (viewWidth / dpr &lt; minWidth))&#123; viewWidth = minWidth * dpr; &#125; docEl.style.fontSize = viewWidth / ratio + 'px'; &#125;&#125;)(); 移动端事件触摸事件，手势事件，传感器事件，主要讲的是触摸事件，其他两个兼容性堪忧，而且手势事件也可以用触摸事件代替，传感器事件就是手机倾斜什么的，但是兼容性不ok 触摸事件可以非为两种：touch 事件，最早出现的，兼容性okpointer 事件 ，这个是微软出的，比较友好，但是呢实现的厂商不多，兼容性不好，但是很有意义，把鼠标事件和触摸事件统一为指针事件，不论是pc端还是移动端，只用使用pointer事件就ok了 touch 事件ontouchstart 触摸开始执行ontouchmove 移动执行ontouchend 触摸结束执行ontouchcancel 不常用，发生触摸中断的时候执行，当我们点击的时候，突然来电话，界面跳转，称之为触摸中断。系统级事件 document.ontouchstart = function () {} 这种写法不推荐，如果要兼容IE8浏览器及一下，还是用这种 document.addEventListener(&#39;touchstart&#39;, function(){}, false) 推荐写法，IE9及以上兼容。第三个参数表示冒泡，true表示捕获 touch 事件event 对象123document.addEventListener('touchstart', function(ev)&#123; console.log(ev)&#125;, false) 以上对象属性含义:altKey: false 触摸的时候是否有按住alt键，手机哪来的alt键以下三个和冒泡有关bubbles: true 目前是否是冒泡cacelBubble: false 目前是否取消冒泡cancelable: true 是否可以取消冒泡以下就讲了一下主要用到的，其他就不讲了type 知道当前什么事件，和pc端事件一样target 当前元素，什么元素响应你的changeTouches 捕获发生变化的手指，触摸列表，类数组(没有数组的方法),一般情况下都使用这个，其中一个原因是ontouchend事件以下两种捕获不到东西targetTouches 捕获到物体上的手指touches 捕获到屏幕上所有手指头 常用changeTouches123document.addEventListener('touchstart', function(ev)&#123; var touch = ev.changeTouches[0] //一般都是单指&#125;, false) changeTouches里面的属性：clientX: 可视区范围内的坐标clientY: 可视区范围内的坐标pageX 有滚动条的时候，也会把滚动条的距离算上，而不仅仅是可视区域pageYradiusX 指头的触摸大小半径radiusY 这里讲到了拖动，我没有做，明天补上，今晚记一些技巧chrome的a点击有个高亮，当时自己还是百度了好久，我晕123.a:hover &#123; -webkit-tap-highlight-color: transparent;&#125; 还有就是用transform的时候用translate3d，会开启设备的GPU加速123.backtop &#123; transform: translate3d(x, y, 0); /*会开启GPU加速*/&#125; 补：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162 &lt;style type="text/css" media="screen"&gt; html &#123; height: 2000px; &#125; .top &#123; height: 20px; width: 20px; position: fixed; bottom: 20px; right: 20px; border-radius: 50%; background: rgba(0,0,0,.3); /*transition: all .3s;*/ &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class="top" id="top"&gt; &lt;/div&gt; 122 &lt;script&gt; var docEl = document.documentElement; var topN = document.getElementById('top'); var coordinate = &#123; pageX: 0, pageY: 0 &#125; var page = &#123; pageX: 0, pageY: 0 &#125; var isTouchMove = false; topN.addEventListener('touchstart', function(ev) &#123; var changedTouches = ev.changedTouches[0] coordinate.pageX = changedTouches.pageX; coordinate.pageY = changedTouches.pageY; &#125;) topN.addEventListener('touchmove', function(ev) &#123; ev.preventDefault() isTouchMove = true; var changedTouches = ev.changedTouches[0] var x = changedTouches.pageX - coordinate.pageX + page.pageX; var y = changedTouches.pageY - coordinate.pageY + page.pageY; ev.target.style.transform = 'translate3d('+ x +'px,'+ y +'px,0)' &#125;) topN.addEventListener('touchend', function(ev) &#123; if (!isTouchMove) &#123;return&#125;; console.log('touch') var changedTouches = ev.changedTouches[0] page.pageX += changedTouches.pageX - coordinate.pageX; page.pageY += changedTouches.pageY - coordinate.pageY; isTouchMove = false &#125;) &lt;/script&gt; 移动端调试Vorlon.js多端同步工具Browsersync终端检测，navigator最好后端来做，但是前端也是可以做的 12345678var isMobile = navigator.userAgent.match(/android|iphone|ipad|ipod/i)if (isMobile) &#123; location.href = 'https://m.imooc.com'&#125; else &#123; location.href = 'https://www.imooc.com'&#125; 可以根据这段代码，加载各端自己的代码，比如响应式开发 移动开发常见问题解决html5标签兼容问题引入html5shiv.js css3 兼容问题用modernizr.js 这个库来兼容，写两套样式 click 300毫秒延迟解决原因是手机端的double click双击造成的，解决办法fastclick,很多浏览器已经解决就是给viewport添加width=device-width 文字溢出问题普通解决方法不能配合flex 布局，必须给元素套一层12345678910111213141516&lt;style type="text/css" media="screen"&gt; .text-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; white-space: normal; &#125; .flex &#123; display: flex; justify-content: center; align-items: center; &#125;&lt;/style&gt;&lt;div class="text-ellipsis flex"&gt; &lt;span&gt;文字&lt;/span&gt; //套一层就好了&lt;/div&gt; 多行文字溢出问题解决1234567891011121314151617181920&lt;style type="text/css" media="screen"&gt; .flex &#123; display: flex; justify-content: center; align-items: center; &#125; .multiline-ellipsis &#123; overflow: hidden; text-overflow: ellipsis; display: -webkit-box; -webkit-line-clamp: 3; 这个就可以控制显示几行文字 -webkit-box-orient: vertical; white-space: normal !important; word-wrap: break-word; &#125;&lt;/style&gt;&lt;div class="multiline-ellipsis flex"&gt; 文字&lt;/div&gt; javascript兼容做特性检测，不要做浏览器检测这个是fastclick.js的特性检测做法12345if ('addEventListener' in document) &#123; //这个是fastclick.js的特性检测做法 document.addEventListener('DOMContentLoaded', function() &#123; FastClick.attach(document.body) &#125;, false)&#125;; 特性检测就很简单，就是判断以下，要加window的原因是因为如果没有该元素就会报错，未定义，而挂载到window上，他就会报undefined1234567if (requestAnimateionFrom) &#123; //错误写法，如果不存在就会变成一个没有声明的变量&#125;if (window.requestAnimateionFrom) &#123; //正确做法&#125; 前缀1var requestAnimationFrame = window.requestAnimateionFrom || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || function(fn) &#123;setTimeout(fn, 16)&#125;; 移动端动画优先使用 requestAnimateionFrom, 请求动画帧css3使用transition, animation canvas 要配合setTimeout,setInterval做动画，不能用css3，而DOM动画，就可以用提到的所有 水平居中和垂直居中123456789101112水平居中：`text-align: center` 有固定宽度就可以使用`margin: 0 auto` 针对块级容器，有固定宽度`position+margin-left/translate` 以前仅用到了`margin`来解决，不过`translate`可以解决没有固定宽度，也可以实现`flex`终极解决方案垂直居中`line-height` 有固定高度可以使用，仅仅只能用于单行文字，其实配合`position+margin-top/translate` 同理`flex`终极解决方案## Zepto这里面虽然都很基础，和jQuery都差不多，不过还是能学到东西的，比如`window.onload`和`$(document).ready(function ()&#123;&#125;)`的区别，前者是页面全部加载完成，包括图片，js，css，dom,后者则是dom加载完毕，肯定是dom加载完毕更高效啊 还有事件的命名空间，1234$(document).on('click.muke', function (e) &#123; console.log('click'); $(this).off('.muke') //大概是这么写的？&#125;) 这样就仅仅会取消一个，以前老师教的是创建一个变量12345var ev;$(document).on('click', ev = function (e) &#123; console.log('click'); $(this).off(ev)&#125;) 按需加载，我觉得还是另一个老师讲的细，这里就不深究了，看那个老师的就ok，这个参考一下就好实战开始,这里就直接上vue项目了页面最大宽度640，最小宽度320设计稿为 375px 的页面，扩大两倍到750px，做标注，同时等比放大1.5倍生成宽度位1125的设计稿，在这里面切图 项目初始化完毕了，很简单，懒加载，重定向什么的 全局的样式都写在assets/less目录，这样便于管理，而且可以全局引入，其他页面都不用引入 固定定位，以前的手机兼容不好，最好使用绝对定位来模拟 目录结构src/– assets 全局文件– base 基础组件– components 公共组件– views 所有页面放的位置，一个文件夹代表一块，index为默认出口– App.vue– main.js– router.js– store.js基础组件和业务逻辑毫无瓜葛也就是说base里面的组件都可以扩展，slot插槽 用到的插件统计fastclick 解决移动端300点击延迟Vue-Awesome-Swiper vue 封装的 swiper插件，轮播jsonp 获取jsonp数据vue-lazyload 延迟加载 开发vue项目用到的技巧header 部分公共化使用slot插槽，$slots判断是否使用了该插槽，没使用就隐藏这里遇到个问题，定位问题如果前面元素不显示就会导致，最后一个元素无法右对齐，所以呢，有两种方案，第一种就是把第一个元素不用v-if判断，一直显示，另一种是用css3选择器完成，不过我觉得没必要，用到的选择器~ , 不过呢，我觉得这种方法很笨，不会用12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;!-- navbar.vue --&gt;&lt;div class="mine-navbar"&gt; &lt;div class="mine-navbar-left" v-if="$slots.left"&gt; &lt;slot name="left"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="mine-navbar-center" v-if="$slots.center"&gt; &lt;slot name="center"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;div class="mine-navbar-right" v-if="$slots.right"&gt; &lt;slot name="right"&gt;&lt;/slot&gt; &lt;/div&gt; &lt;h1 class="mine-navbar-title" v-if="title"&gt; &lt;span class="mine-navbar-text ellipsis" v-text="title"&gt;&lt;/span&gt; &lt;/h1&gt;&lt;/div&gt;&lt;style lang="less" scoped&gt;@import '~assets/less/_mixins.less';.mine-navbar &#123; display: flex; justify-content: space-between; align-items: center; height: @navbar-height; background-color: #fff; &amp;-left &#123; margin-left: 20/@r; ~ .mine-navbar-right &#123; //新增代码 position: static; &#125; &#125; &amp;-center &#123; flex: 1; margin: 0 20/@r; ~ .mine-navbar-right &#123; //新增代码 position: static; &#125; &#125; &amp;-right &#123; position: absolute; //新增代码 right: 0; display: flex; //用了绝对定位父元素的flex就会失效，所以要搞这个 justify-content: center; align-items: center; height: 100%; margin-right: 20/@r; &#125; &amp;-title &#123; position: absolute; left: 20%; right: 20%; text-align: center; display: flex; align-items: center; &#125; &amp;-text &#123; .ellipsis(); font-size: 18px; width: 100%; line-height: 1.5; &#125;&#125;&lt;/style&gt; 使用插槽 1234567891011121314151617181920&lt;template&gt; &lt;!-- 差点忘记了，这里不能用:title.加：后面调用的就是表达式了 --&gt; &lt;me-navbar title="哈哈哈"&gt; &lt;i class="iconfont" slot="left"&gt;&lt;/i&gt; &lt;div slot="center"&gt;&lt;/div&gt; &lt;i class="iconfont" slot="right"&gt;&lt;/i&gt; &lt;/me-navbar&gt;&lt;/template&gt;&lt;script&gt;import MeNavbar from 'navbar.vue'export defult &#123; name: 'homeHeader', components: &#123; MeNavbar &#125;&#125;&lt;/script&gt; props 接收效验不过我觉得把，我自己写好像没必要效验，又不是团队开发，就算是团队开发，这个东西不给别人用就没必要效验？估计是我现在还没有接触到，所以还是写一下吧，逼格？嗯，目前为止12345678910111213props: &#123; direction: &#123; type: String, default: 'horizontal', validator (value) &#123; // value就可以接收到传入的参数 // 如果返回true代表成功效验，flase失败 return [ 'horizontal', 'vertical' ].includes(value) &#125; &#125;&#125;]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发中的技巧及问题]]></title>
    <url>%2Fblog%2F2019%2F03%2F22%2F%E5%BC%80%E5%8F%91%E4%B8%AD%E7%9A%84%E6%8A%80%E5%B7%A7%E5%8F%8A%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[开发网站记录 若时光往复，我仍爱你如初 #组件化开发css不换行123&#123;white-space: nowrap;&#125; 下拉菜单的方式有3种第一种是用js改变添加css，这样导致页面的回流，和重绘问题，性能低下 第二种是用js添加class类来完成操作，相对来说不错， 第三种是最优的，就是用:hover 伪类来解决，不过IE6不支持 分离下拉菜单，组件化开发这种组件化开发思想确实很不错，可以节省很多代码结构，把类似的结构提出来，弄一个公共的样式老师将的思路很清晰本节代码 可复用html1234567&lt;div class="dropdown menu" data-dropdown="menu"&gt; &lt;div class="dropdown-toggle link"&gt; 我的慕陶&lt;i class="dropdown-arrow"&gt;&lt;/i&gt; &lt;/div&gt; &lt;ul class="dropdown-layer dropdown-left"&gt; &lt;/ul&gt;&lt;/div&gt; 复用css1234567891011121314151617181920212223242526272829.dropdown &#123; position: relative;&#125;.dropdown-toggle &#123; position: relative; z-index: 2;&#125;.dropdown-arrow &#123; display: inline-block; vertical-align: middle;&#125;.dropdown-layer &#123; display: none; z-index: 1; position: absolute;&#125;.dropdown-left &#123; left: 0; right: auto;&#125;.dropdown-right &#123; right: 0; left: auto;&#125; 封装可服用javascript1234567891011121314151617181920212223(function($) &#123; 'use strict' function dropdown(elem) &#123; var $elem = $(elem) $elem.hover(function() &#123; var $this = $(this) $this.addClass($this.data('dropdown')+'-active'); &#125;, function() &#123; var $this = $(this) $this.removeClass($this.data('dropdown')+'-active'); &#125;) &#125; $.fn.extend(&#123; dropdown: function() &#123; this.each(function() &#123; dropdown(this) &#125;) return this &#125; &#125;)&#125;)(jQuery);$('.dropdown').dropdown() 下拉图标问题用图片的方式至少会增加1次http请求 第二种方式就是把图片转化为base64，IE6-7不支持,编码后比原图大，不能缓存 纯CSS箭头，兼容IE612345678arrow-down &#123; width: 0; height: 0; border: 4px solid #535b62; border-left-color: transform; border-left-color: transform; border-bottom: none;&#125; 不过呢，IE6 不兼容transform12345678910arrow-down &#123; width: 0; height: 0; border: 4px solid #535b62; border-right-color: transform; _border-right-color: #fff; /* 兼容IE6写法。_只有IE6会识别 */ border-left-color: transform; _border-left-color: #fff; /* 兼容IE6写法。_只有IE6会识别 */ border-bottom: none;&#125; 用字体图标的技巧因为是字体的问题，所以会继承父级的line-height所以我们把字体图片的，line-height: 1就可以解决这个问题，还用旋转图标的样式因为是css3的原因，所以直接用css3的查找方式 123[class*='-active'] .dropdown-arrow &#123; transform: rotate(180deg);&#125; 动画呢，我基本都是单独写，因为感觉all老师说不高效，不过写一个利于以后的修改123.transition &#123; transition: all .3s&#125; 隐藏和显示本节代码trigger()这个jquery方法居然还可以传递事件，我服了1$('.box').trigger('hide'); 给那个元素绑定的就监听那个元素123$('.box').on('hide', function(e) &#123; console.log(e.type)&#125;) is() 这个返回true，或者false:hidden 匹配隐藏元素:visible 匹配显示元素初始化(防止多次点击),老师不知道为什么还给hidden添加data，我觉得没必要，难道不监听事件就不会绑定吗？应该不是，毕竟是链式调用1234567891011121314var anim = &#123; init: function($elem) &#123; if ($elem.is(':hidden')) &#123; $elem.data('start', 'hide') &#125; else &#123; $elem.data('start', 'show') &#125; &#125;, hide: function($elem) &#123; if($elem.data('start') === hide) return; $elem.data('start', 'hide').trigger('hide'); //... &#125;&#125; 通过事件监听的方式实现回调函数123456789101112131415161718var anim = &#123; hide: function($elem) &#123; $elem.trigger('hide'); //第一个事件 $elem.hide(); $elem.trigger('hidden'); //隐藏完之后传递的事件 &#125;&#125;$('.hide').on('click', function() &#123; anim.hide($('.box'))&#125;)$('.box').on('hide hidden',function(e) &#123; if(e.type ==== 'hide') &#123; //执行的第一个回调函数 &#125; else if(e.type === 'hidden') &#123; //执行的第二个回调函数 &#125;&#125;) css3 隐藏和显示one() 给匹配元素绑定一次事件off() 删除事件1234567891011121314151617show: function($elem) &#123; //多次点击无效 if ($elem.data('start') === 'show') return; if ($elem.data('start') === 'shown') return; //触发事件show $elem.data('start', 'show').trigger('show') //开始隐藏 $elem.show() //css3的动画原理呢，就是给个延迟，不然就没有动画效果了 setTimeout(function() &#123; $elem.removeClass('fadeOut') &#125;, 20) //监听transition 完成后触发该事件，抛出事件，外面就可以监听到，从而执行回调函数 $elem.off('transitionend').one('transitionend', function() &#123; $elem.data('start', 'shown').trigger('shown') &#125;)&#125;, 隐藏略有不同123456789101112hide: function($elem) &#123; if ($elem.data('start') === 'hide') return; if ($elem.data('start') === 'hidden') return; $elem.data('start', 'hide').trigger('hide') //因为是隐藏，所以先去掉class，执行css3动画 $elem.addClass('fadeOut') //transition完成后，执行该事件，隐藏该元素 $elem.off('transitionend').one('transitionend', function() &#123; $elem.hide() $elem.data('start', 'hidden').trigger('hidden') &#125;)&#125; 老师还讲到了浏览器对transitionend各浏览器的各种写法，以及兼容1234567891011121314151617181920212223242526(function ($) &#123; //各大浏览器的兼容，firefox和chrome一样 var transitionEndEventName = &#123; transition: 'transitionend', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd', OTransition: 'oTransitionEnd otransitionend' &#125; var transitionEnd = '', isSupport = false; for (var name in transitionEndEventName) &#123; //不存在就返回undefined if (document.body.style[name] !== undefined) &#123; transitionEnd = transitionEndEventName[name] isSupport = true; break; &#125; &#125; //如果全局存在window.mt就直接用，不存在则创建空对象 window.mt = window.mt || &#123;&#125;; window.mt.transiton = &#123; end: transitionEnd, isSupport: isSupport &#125;&#125;)(jQuery); 调用12console.log(window.mt.transition.end);console.log(window.mt.transition.isSupport); 酷，下拉呀，淡入淡出，左右动画，全部都是通用的，直接修改css即可js切换，封装的时候有一个技巧1234567$elem.stop().fadeIn(function () &#123;&#125;)//居然可以这么写。。。。$elem.stop()['fadeIn'](function () &#123;&#125;); #封装，taiquanleproxy() 这东西不但可以传参，还可以修改this指向，用处多多extend() 可以合并对象，还可以绑定jQuery方法这里干货满满123456789101112131415161718192021222324252627282930//默认配置var defaults = &#123; css3: true, js: true, animate: 'fade'&#125;;function showhide($elem, options) &#123; var mode = null; //传进来的参数和默认的对比，合并 options = $.extend(&#123;&#125;, defaults, options) //这里的transition.isSupport 是检测浏览器是否兼容css3，和js，transitionend的各浏览器兼容写法 if (options.css3 &amp;&amp; transition.isSupport) &#123; //如果css3为true，而且浏览器兼容，就直接使用css3动画 mode = css3[options.animate] &#125; else if (options.js) &#123; //不兼容css3，或者css3为false，js为true就用js动画 mode = js[options.animate] &#125; else &#123; //以上两种都不行，则执行基础隐藏显示，没有动画 mode = slide &#125; //初始化 mode.init($elem) return &#123; //返回两个方法，给外界调用 show: $.proxy(mode.show, this, $elem), hide: $.proxy(mode.hide, this, $elem) &#125;&#125;; 因为是自制行环境，所以还要将该方法暴露出去普通暴露123456789window.mt = window.mt || &#123;&#125;,window.mt.showhide = showhide//下面的是调用形式var showHide = window.mt.showhide($box, &#123; animate: 'slideUpDown'&#125;)showHide.show($box)showHide.hide($box) jQuery暴露1234567891011121314151617$.fn.extend(&#123; showHide: function (option) &#123; return this.each(function () &#123; //mode 这个很巧妙，没用值就执行if里面的语句，赋值，第二次进入就没问题了，老师很爱用data，巧妙 var $this = $(this), mode = $(this).data('showHide'); if (!mode) &#123; //判断参数是否为对象，因为接收参数不仅接受配置，还接收调用的方法 $this.data('showHide', mode = showhide($this, typeof option === 'object' &amp;&amp; option)) &#125; //传进来的参数和showhide暴露的方法对比，如果不是暴露的方法就退出，是的话就执行 if(typeof mode[option] === 'function') &#123; mode[option](); &#125; &#125;) &#125;&#125;); 用构造函数的方式重写dropdown为什么不这样写的原因123456789101112function Dropdown() &#123; this.show = function () &#123; &#125; this.hide =function () &#123; &#125;&#125;//每次实例化，都会在堆内存中开辟空间，来存放函数本体var dropdown = new Dropdown();var dropdown2 = new Dropdown();var dropdown3 = new Dropdown(); 解决this指针的几种办法1: $.proxy()1this.$elem.hover($.proxy(this.show, this), $.proxy(this.hide, this)) 2: 定义_this123456var _this = thisthis.$elem.hover(function() &#123; _this.show()&#125;, function () &#123; _this.hide()&#125;) 3: ES6 Module1this.$elem.hover(() =&gt; &#123;this.show()&#125;, () =&gt; &#123;this.hide()&#125;) 冒泡是从匹配元素的DOM结构向上冒泡12345678&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 单例化抛出一个方法，执行的时候每次都会创建该实例，浪费内存，所以单例化123456789101112131415161718$.fn.extend(&#123; dropdown: function(option) &#123; return this.each(function() &#123; //单例化，就是给该DOM元素绑定data属性，一旦赋值，就不会继续创建 var dropdown = $(this).data('dropdown'), options = $.extend(&#123;&#125;, Dropdown.DEFAULTS, typeof option === 'object' &amp;&amp; option); //判断是否data赋值 if (!dropdown) &#123; //这里面写法还真是省位置。 $(this).data('dropdown', dropdown = new Dropdown(this, options)) &#125; //判断是否为方法，有可能使用组件的人，传进来一个别的值，不是我们要抛出的事件，那就会返回undefined if (typeof dropdown[option] === 'function') &#123; dropdown[option]() &#125; &#125;) &#125;&#125;) 动画条算是完成了，很nice，很全面，很完美，总结一下transition.js 解决兼容问题1234567891011121314151617181920212223(function ($) &#123; var transitionEndEventName = &#123; transition: 'transitionend', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd', OTransition: 'oTransitionEnd otransitionend' &#125; var transitionEnd = '', isSupport = false; for (var name in transitionEndEventName) &#123; if (document.body.style[name] !== undefined) &#123; transitionEnd = transitionEndEventName[name] isSupport = true; break; &#125; &#125; window.mt = window.mt || &#123;&#125;; window.mt.transiton = &#123; end: transitionEnd, isSupport: isSupport &#125;&#125;)(jQuery); 抛出了两个方法，mt.transition.end 为判断各浏览器之间transitionend的兼容问题mt.transition.isSupport 判断浏览器是否支持CSS3属性，不支持返回false index.js 动画逻辑123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183var transition = window.mt.transitonfunction init($elem, hiddenCallback) &#123; if ($elem.is(':hidden')) &#123; $elem.data('start', 'hidden') if (typeof hiddenCallback === 'function') &#123; hiddenCallback(); &#125; &#125; else &#123; $elem.data('start', 'shown') &#125;&#125;function show($elem, callback) &#123; if ($elem.data('start') === 'show') return; if ($elem.data('start') === 'shown') return; $elem.data('start', 'show').trigger('show') callback()&#125;function hide($elem, callback) &#123; if ($elem.data('start') === 'hide') return; if ($elem.data('start') === 'hidden') return; $elem.data('start', 'hide').trigger('hide') callback()&#125;var slide = &#123; init: function($elem) &#123; if ($elem.is(':hidden')) &#123; $elem.data('start', 'hide') &#125; else &#123; $elem.data('start', 'show') &#125; &#125;, show: function($elem) &#123; show($elem, function() &#123; $elem.show() $elem.trigger('shown') &#125;) &#125;, hide: function($elem) &#123; hide($elem, function() &#123; $elem.hide() $elem.trigger('hidden') &#125;) &#125;&#125;;var css3 = &#123; _init: function($elem, className) &#123; $elem.addClass('transition') init($elem, function() &#123; $elem.addClass(className) &#125;) &#125;, _show: function($elem, className) &#123; show($elem, function() &#123; $elem.show() setTimeout(function() &#123; $elem.removeClass(className) &#125;, 20) $elem.off(transition.end).one(transition.end, function() &#123; $elem.data('start', 'shown').trigger('shown') &#125;) &#125;) &#125;, _hide: function($elem, className) &#123; hide($elem, function() &#123; $elem.addClass(className) $elem.off(transition.end).one(transition.end, function() &#123; $elem.hide() $elem.data('start', 'hidden').trigger('hidden') &#125;) &#125;) &#125;, fade: &#123; init: function($elem) &#123; css3._init($elem, 'fadeOut') &#125;, show: function($elem) &#123; css3._show($elem, 'fadeOut') &#125;, hide: function($elem) &#123; css3._hide($elem, 'fadeOut') &#125; &#125;, slideUpDown: &#123; init: function($elem) &#123; $elem.height($elem.height()) css3._init($elem, 'slideUpDown') &#125;, show: function($elem) &#123; css3._show($elem, 'slideUpDown') &#125;, hide: function($elem) &#123; css3._hide($elem, 'slideUpDown') &#125; &#125;&#125;;var js = &#123; _hide: function($elem, mode) &#123; hide($elem, function() &#123; $elem.stop()[mode](function() &#123; $elem.data('start', 'hidden').trigger('hidden') &#125;) &#125;) &#125;, _show: function($elem, mode) &#123; show($elem, function() &#123; $elem.stop()[mode](function() &#123; $elem.data('start', 'shown').trigger('shown') &#125;) &#125;); &#125;, _customInit: function($elem, options) &#123; var style = &#123;&#125; for (var ops in options) &#123; style[ops] = $elem.css(ops); &#125; $elem.data('style', style) init($elem, function() &#123; $elem.css(options) &#125;) &#125;, fade: &#123; init: function($elem) &#123; init($elem) &#125;, show: function($elem) &#123; js._show($elem, 'fadeIn') &#125;, hide: function($elem) &#123; js._hide($elem, 'fadeOut') &#125; &#125;, slideUpDown: &#123; init: function($elem) &#123; init($elem) &#125;, show: function($elem) &#123; js._show($elem, 'slideDown') &#125;, hide: function($elem) &#123; js._hide($elem, 'slideUp') &#125; &#125;, slideRight: &#123; init: function($elem) &#123; js._customInit($elem, &#123; 'width': 0, 'padding-left': 0, 'padding-right': 0 &#125;) &#125;, show: function($elem) &#123; $elem.show() show($elem, function() &#123; $elem.stop().animate($elem.data('style'), function() &#123; $elem.data('start', 'shown').trigger('shown') &#125;) &#125;) &#125;, hide: function($elem) &#123; hide($elem, function() &#123; $elem.stop().animate(&#123; 'width': 0, 'padding-left': 0, 'padding-right': 0 &#125;, function() &#123; $elem.hide() $elem.data('start', 'hidden').trigger('hidden') &#125;) &#125;) &#125; &#125;&#125;;var defaults = &#123; css3: true, js: true, animate: 'slideUpDown'&#125;; 我日了狗了，_这东西还得转译，不然后面语法全错这里没什么好讲的，都很简单，通俗易懂。_约定俗成内部使用 上面是js和css3动画，这里就是判断浏览器使用哪种动画1234567891011121314151617181920function showhide($elem, options) &#123; var mode = null; //合并传进来的配置，和我们默认配置 options = $.extend(&#123;&#125;, defaults, options) //判断配置中是否开启css3, 如果开启判断浏览器是否兼容css3 if (options.css3 &amp;&amp; transition.isSupport) &#123; mode = css3[options.animate] &#125; else if (options.js) &#123; //如果不兼容则查看配置是否开启js，如果开启则使用 mode = js[options.animate] &#125; else &#123; //最后的情况就是使用最简单的方式，没有动画 mode = slide &#125; //每个定义的属性都有一个自己的init初始化方法 mode.init($elem) //返回两个show，和hide方法，便于调用 return &#123; show: $.proxy(mode.show, this, $elem), hide: $.proxy(mode.hide, this, $elem) &#125;&#125;; 接下来就是把该方法暴露出去，供外部使用，因为上面的所有方法都是定义在自制行函数里面jQuery方式暴露12345678910111213141516171819$.fn.extend(&#123; showHide: function(option) &#123; //因为有可能返回的是一个集合，所以这里使用each便利，很nice return this.each(function() &#123; var $this = $(this), mode = $(this).data('showHide'); //单例化，上面有讲 if (!mode) &#123; $this.data('showHide', mode = showhide($this, typeof option === 'object' &amp;&amp; option)) &#125; //抛出方法调用方式$('.dropdown').showHide(&#123;options&#125;) //抛出方法调用方式$('.dropdown').showHide('show') //抛出方法调用方式$('.dropdown').showHide('hide') if (typeof mode[option] === 'function') &#123; mode[option](); &#125; &#125;) &#125;&#125;); 其他抛出方式12345678window.mt = window.mt || &#123;&#125;,window.mt.showhide = showhide// 调用方式 有几个就要调用几次，还是jQuery的方式方便var showHide = window.mt.showhide($box, &#123;animate: 'slideUpDown'&#125;)showHide.show($box)showHide.hide($box) anim.js 重写dropdown动画123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108(function($) &#123; 'use strict' function Dropdown(elem, option) &#123; this.$elem = $(elem) //这里我本来写的$('.dropdown-layer') 直接获取所有了，自己还没找到。。 this.$layer = this.$elem.find('.dropdown-layer') //这里的class我们自己写了，这里样式变通用了，而且也可以控制动画 this.activeClass = option.active + '-active' //全局绑定option this.option = option //把很多代码放到初始化代码里面，我们称之为初始化，其实就是进来加载的代码，这下终于懂了 this.init() &#125; Dropdown.prototype = &#123; init: function() &#123; //因为是ES5的方式写代码，外面最好获取一下this，很方便 var _this = this //这里就调用了`index.js` 初始化操作，顺带传参 this.$layer.showHide(this.option) //老师还配置了多个事件触发的方式 if (this.option.event === 'click') &#123; this.$elem.on('click', function(e) &#123; //这里是我自己拓展的，就是展开一个标签后，关闭另一个标签 //以前是查错了，就说怎么老是不对，查父元素肯定是显示的呀。。 //_this.$elem.siblings().is(':visible') 。。错误的写法 _this.$allelem = _this.$elem.siblings().find('.dropdown-layer:visible') if (_this.$allelem) &#123; //哈哈哈，很不错，这个呢就是根据打开元素关闭标签 _this.Allhide() &#125; //这里click，的点击判断，如果显示了再点击就是隐藏，老师没写，我加的，还行把 if (_this.$layer.is(':hidden')) &#123; //吓我一跳，这里是调用的自己的show，我就说吗 _this.show(); &#125; else &#123; _this.hide(); &#125; //阻止冒泡，不然会触发document的click事件 e.stopPropagation(); &#125;) //别的地方点击隐藏元素 $(document).on('click', function() &#123; _this.hide() &#125;) &#125; else &#123; //hover 方式的动画 //这里的$.proxy() 这给东西不但可以改变this指向，还可以传参(第三个参数) this.$elem.hover($.proxy(this.show, this), $.proxy(this.hide, this)) &#125; &#125;, show: function() &#123; var _this = this //老师加了给延迟，duowan用的就是这个方法，还要17173， 不知道谁炒谁的 if (this.option.delay) &#123; this.time = setTimeout(function() &#123; _this.$elem.addClass(_this.activeClass); _this.$layer.showHide('show') &#125;, this.option.delay) &#125; else &#123; //添加class this.$elem.addClass(this.activeClass); //这里也是调用的`index.js`抛出的方法 this.$layer.showHide('show') &#125; &#125;, hide: function() &#123; if (this.option.delay) &#123; clearTimeout(this.time) &#125; //和show一个原理 this.$elem.removeClass(this.activeClass); this.$layer.showHide('hide') &#125;, Allhide: function() &#123; //写click事件多出来的方法 this.$elem.siblings().removeClass(this.activeClass); this.$allelem.showHide('hide') &#125; &#125; //function 就是对象，所以可以这么写 Dropdown.DEFAULTS = &#123; event: 'hover', css3: true, js: true, animate: 'slideUpDown', active: 'menu', delay: 0 &#125; // window.mt.Dropdown = Dropdown $.fn.extend(&#123; dropdown: function(option) &#123; return this.each(function() &#123; var dropdown = $(this).data('dropdown'), options = $.extend(&#123;&#125;, Dropdown.DEFAULTS, typeof option === 'object' &amp;&amp; option); //单例化 if (!dropdown) &#123; //这里不但给dropdown重置值，还给data-dropdown设置值，巧妙。 $(this).data('dropdown', dropdown = new Dropdown(this, options)) &#125; //传入字符串这里处理，如果是暴露的方法就执行相应逻辑 if (typeof dropdown[option] === 'function') &#123; dropdown[option]() &#125; &#125;) &#125; &#125;)&#125;)(jQuery) 接下来就是调用了123$('.dropdown').dropdown(&#123; //anim.js暴露出来的方法没有使用，这里就仅仅只是传参 animate: 'fade'&#125;) 按需加载1234567891011121314151617181920212223242526272829303132//这里通过我们index.js中抛出的事件，达到我们执行回调的方法，老师还在`anim.js`中接收，//然后抛给`.dropdown`//简单写一下，如果遇到问题，可以加到`anim.js`的init初始化方法中//this.$layer.on('show shown hide hidden', function(e) &#123;// _this.$elem.trigger(e.type)//&#125;)//我觉得吧，可以写，但没必要，让代码更复杂了//按需加载$('.dropdown-layer').on('show', function(e) &#123; var html ='', $this = $(this), load = $(this).data('load') //判断`data-load`是否有值，没有则直接返回，不是我们按需加载的对象 if (!load) return //判断是否有`data-loader` 有就表示获取过值了，不执行该方法 if (!$(this).data('loader')) &#123; //异步操作，但是天猫不是用的异步。直接加载了给js文件，不清楚 $.getJSON('test/'+load, function(json, textStatus) &#123; //通过json结构便利赋值 $.each(json, function (index) &#123; //html模板 html += `&lt;li&gt;&lt;a href="###" target="_blank" class="menu-item"&gt;$&#123;json[index].title&#125;&lt;/a&gt;&lt;/li&gt;` &#125;) //赋值 $this.html(html) // 添加`data-loader`状态，防止多次获取 $this.data('loader', true) &#125;); &#125;&#125;) html 结构123456&lt;li class="menu nav-site-service dropdown fl"&gt; &lt;a href="###" target="_blank" class="dropdown-toggle link transition"&gt;联系客服&lt;i class="dropdown-arrow iconfont transition"&gt;&amp;#xe798;&lt;/i&gt;&lt;/a&gt; &lt;ul class="dropdown-layer dropdown-right" data-load="dropdown.json"&gt; &lt;!-- &lt;li&gt;&lt;a href="###" target="_blank" class="menu-item"&gt;买家客服&lt;/a&gt;&lt;/li&gt; --&gt; &lt;!-- &lt;li&gt;&lt;a href="###" target="_blank" class="menu-item"&gt;卖家客服&lt;/a&gt;&lt;/li&gt; --&gt; &lt;/ul&gt; 搜索功能组件化trim() 这是js原生的，去除字符串两边的空白 搜索框自动完成onkeyup事件 keyup 兼容好，但是必须做一些约束，比如鼠标粘贴复制不会触发，键盘的一些上下键还可以触发 oninput事件 不兼容IE6,7,8,但是好用。。。 异步的方式就是为了避免回调123456789101112131415161718192021222324252627//回调$inputbox.on('input', function () &#123; $.ajax(&#123; //这里的接口是请求，淘宝的数据，因为我们没数据 url: "https://suggest.taobao.com/sug?code=utf-8&amp;q="+$inputbox.val()+"&amp;_ksTS=1553601277970_353&amp;callback=jsonp354&amp;k=1&amp;area=c2c&amp;bucketid=12", dataType: "jsonp", success: function (data) &#123; console.log(data); &#125; &#125;)&#125;)//异步$inputbox.on('input', function () &#123; var url = "https://suggest.taobao.com/sug?code=utf-8&amp;q="+$inputbox.val()+"&amp;_ksTS=1553601277970_353&amp;callback=jsonp354&amp;k=1&amp;area=c2c&amp;bucketid=12"; $.ajax(&#123; //这里的接口是请求，淘宝的数据，因为我们没数据 url: url, timeout: 1, //超时 dataType: "jsonp", //跨域 &#125;).done(function (data) &#123; console.log(data); &#125;).fail(function (err) &#123; console.log(err); &#125;).always(function () &#123; console.log('Why'); &#125;)&#125;) 如果页面不是UTF8,是别的，输入内容提交就会出错乱码encodeURIComponent()1var url = "https://suggest.taobao.com/sug?code=utf-8&amp;_ksTS=1553601277970_353&amp;callback=jsonp354&amp;k=1&amp;area=c2c&amp;bucketid=12&amp;q=" + encodeURIComponent($inputbox.val()); 正则去除文本中的&lt;b&gt;标签:过&lt;b&gt;生日&lt;/b&gt;的&lt;b&gt;礼物&lt;/b&gt;变成纯文本123function removeHtmlTags(str) &#123; return str.replace(/&lt;(?:[^&gt;'"]|"[^"]*"|'[^']*')*&gt;/g, '')&#125; search.js 代码都写了注释，逻辑通了都很简单，EZ，接下来是改写下面的操作，应该是封装把搜索框完成，没有键盘上下键盘的绑定，其他功能齐全123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081(function ($) &#123; 'use strict' var $search = $('.search'), $form = $search.find('.search-form'), $inputbox = $search.find('.search-inputbox'), $btn = $search.find('.search-btn'), $layer = $search.find('.search-layer'); //验证操作 // $btn.on('click', function () &#123; // //判断是否输入为空，空则不提交 // if ($inputbox.val().trim() === '') &#123; // return false // &#125; // &#125;) //新的验证操作 //比click好的地方就是可以监听layer下拉框，如果点击提交是空也不行 $form.on('submit', function () &#123; if ($inputbox.val().trim() === '') &#123; //这是我自己拓展的，仿天猫的，酷 $inputbox.addClass('background-glint') $inputbox.off('animationend').one('animationend', function () &#123; $inputbox.removeClass('background-glint') &#125;) return false &#125; &#125;) //获取焦点，显示下拉 $inputbox.on('focus', function () &#123; $layer.show() &#125;).on('click', function() &#123; //阻止冒泡，还可以这样？ return false &#125;) //document绑定click事件，点击全局就隐藏菜单，用blur 加延迟也可以实现 $(document).on('click', function () &#123; $layer.hide() &#125;) //绑定input事件，内容改变就获取值，不兼容IE9 以下 $inputbox.on('input', function () &#123; var url = "https://suggest.taobao.com/sug?code=utf-8&amp;_ksTS=1553601277970_353&amp;callback=jsonp354&amp;k=1&amp;area=c2c&amp;bucketid=12&amp;q="+ encodeURIComponent($inputbox.val()); $.ajax(&#123; //这里的接口是请求，淘宝的数据，因为我们没数据 url: url, // timeout: 1, //超时 dataType: "jsonp", //跨域 &#125;).done(function (data) &#123; //成功回调 var html = '', dataNum = data.result.length, numMax = 9; //自定义显示条目 if (dataNum === 0) &#123; //没有数据就直接退出 $layer.hide().html(''); return &#125; for (var i = 0; i &lt; dataNum; i++) &#123; //循环遍历数据 if (numMax &lt;= i) &#123; //自定义显示条目 break &#125; html += '&lt;li class="search-layer-item text-ellipsis"&gt;'+data.result[i][0]+'&lt;/li&gt;' &#125; $layer.html(html).show() //拼接的字符串显示到DOM元素上 &#125;).fail(function (err) &#123; $layer.hide().html('') console.log(err); &#125;).always(function () &#123; console.log('Why'); &#125;) &#125;) //因为用的是事件委托，可以不用写到会到里面 $layer.on('click', 'li', function() &#123; $inputbox.val(removeHtmlTags($(this).html())); $inputbox.parent().submit() &#125;) // 这个呢就是清除字符串中的`&lt;b&gt;`标签 function removeHtmlTags(str) &#123; return str.replace(/&lt;(?:[^&gt;'"]|"[^"]*"|'[^']*')*&gt;/g, '') &#125;&#125;)(jQuery) search-fun.js 不封装还顺的很，封装了感觉好麻烦123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174(function ($) &#123; 'use strict' //数据缓存 var cache = &#123; data: &#123;&#125;, count: 0, addData: function (key, data) &#123; if (!this.data[key]) &#123; this.data[key] = data; this.count++ &#125; &#125;, readData: function (key) &#123; return this.data[key] &#125;, deleteDataByKye: function (key) &#123; //通过键删 delete this.data[key]; this.count--; &#125;, deleteDataByOrder: function (num) &#123; //通过顺序删除 var count = 0; for (var p in data) &#123; if (count &gt;= num) &#123; break; &#125; count++; this.deleteDataByKye(p) &#125; &#125; &#125; function Search($elem, options) &#123; this.options = options; this.$elem = $elem; this.$form = this.$elem.find('.search-form'); this.$input = this.$elem.find('.search-inputbox'); // this.btn = $elem.find('.search-btn') this.$layer = this.$elem.find('.search-layer'); var _this = this //submit 也可以，click也可以 // this.$form.on('submit', $.proxy(this.submit, this)) //提交验证 this.$elem.on('click', '.search-btn',$.proxy(this.submit, this)) //用户配置是否开启自动完成，我的天啊，这下面都是这个自动完成的代码，不要这功能为什么不单独写一个提交验证。。。 if(options.autocomplete) &#123; this.autocomplete() &#125; &#125; Search.DEFAULTS = &#123; autocomplete: false, url: 'https://suggest.taobao.com/sug?code=utf-8&amp;_ksTS=1553601277970_353&amp;callback=jsonp354&amp;k=1&amp;area=c2c&amp;bucketid=12&amp;q=', css3: true, js: true, animate: 'fade' &#125; Search.prototype = &#123; autocomplete: function () &#123; var time = null, _this = this; this.$input .on('input', function () &#123; //减少服务器压力，vue那个老师很常用这个，不过自动完成就会有延迟，个人感觉 clearTimeout(time); //获取延迟 time = setTimeout(function () &#123; _this.getData(); &#125;, 200) &#125;) .on('focus', $.proxy(this.showLayer, this)) //获取焦点显示 .on('click', function () &#123; //阻止事件冒泡 return false &#125;) //点击全局隐藏自动完成下拉菜单 $(document).on('click', $.proxy(this.hideLayer, this)) //初始化动画方法`index.js` case/js目录下的文件 this.$layer.showHide(this.options) &#125;, submit: function () &#123; var _this = this //getInputVal() 这个方法是处理字符串的，去除前后空白，因为两处用到，所以封装 if (this.gitInputVal() === '') &#123; //这是我自己拓展的，仿天猫的，酷 this.$input.addClass('background-glint') this.$input.off('animationend').one('animationend', function () &#123; _this.$input.removeClass('background-glint') &#125;) return false &#125; //click事件才要手动提交，submit事件如果还是手动提交，会重复执行很多次 this.$form.submit() &#125;, getData: function () &#123; var _this = this //转码，页面不是utf8，输入东西提交会乱码 var url = encodeURIComponent(this.gitInputVal()); //如果没有输入内容，则直接，不能这么写，不然我的默认样式就没了,解决了。 // if (url === '') &#123; // return _this.$elem.trigger('errEvent'); // &#125; //解决上面的问题 if (url === '') &#123; return _this.$elem.trigger('errEvent', [_this.$layer]); &#125; //如果读到缓存数据，直接返回不执行后面的了 if (cache.readData(url)) &#123; //读取缓存，并返回 return this.$elem.trigger('successEvent', [cache.readData(url), _this.$layer]); &#125; //如果有新的请求，就会停止以前的请求，来直接完成新的。这个ajax的abort()以前好像都没听过。我服了 if (this.jqXHR) this.jqXHR.abort() this.jqXHR = $.ajax(&#123; //这里的接口是请求，淘宝的数据，因为我们没数据 url: this.options.url + url, // timeout: 1, //超时 dataType: "jsonp", //跨域 &#125;).done(function (data, $layer) &#123; //数据缓存，添加缓存 cache.addData(url, data) //抛出成功事件，向外传输数据要用数组的形式 _this.$elem.trigger('successEvent', [data, _this.$layer]); &#125;).fail(function (err) &#123; _this.$elem.trigger('errEvent', [_this.$layer]); &#125;).always(function () &#123; //这个回调时不管是成功还是失败都会执行，所以这时候清空这个方法，这里清空了，上面的判断呢？这个还有待研究 _this.jqXHR = null &#125;) &#125;, showLayer: function () &#123; // if(this.$layer.children().length === 0) &#123; return // console.log('s'); // &#125;; // `index.js` 的显示动画 this.$layer.showHide('show') &#125;, hideLayer: function () &#123; // `index.js` 的隐藏动画 this.$layer.showHide('hide') &#125;, gitInputVal: function () &#123; // 处理input输入的字符串的方法 return this.$input.val().trim() &#125;, setInput: function (val) &#123; //处理下拉框点击后字符串转换的问题，有些字符串自带html标签，这里要通过正则删除 this.$input.val(removeHtmlTags(val)) function removeHtmlTags(str) &#123; return str.replace(/&lt;(?:[^&gt;'"]|"[^"]*"|'[^']*')*&gt;/g, '') &#125; &#125; &#125; $.fn.extend(&#123; //这里就多了个接收参数 search: function(option, $layer) &#123; return this.each(function() &#123; var search = $(this).data('search'), $this = $(this), options = $.extend(&#123;&#125;, Search.DEFAULTS, typeof option === 'object' &amp;&amp; option); if (!search) &#123; $($this).data('search', search = new Search($this, options)) &#125; // var mode = new Dropdown(this, option) if (typeof search[option] === 'function') &#123; search[option]($layer) &#125; &#125;) &#125; &#125;)&#125;)(jQuery) 调用代码123456789101112131415161718192021222324252627282930313233343536373839404142434445var html = '', htmlload = $('.search-layer').html();$('.search').search(&#123; //初始化 autocomplete: true,&#125;) .on('successEvent', function (e, data, $layer) &#123; //这个方法是处理获取的数据，便利后返回html元素标签结构 html = createHeaderLyaer(data, $layer) //如果有值则显示html， if (html) &#123; $layer.html(html) $(this).search('showLayer', $layer) &#125; else &#123; $layer.html('') $(this).search('hideLayer', $layer) &#125; &#125;) .on('click', 'li', function() &#123; //每个li绑定点击事件，点击的时候就会提交数据，不用a标签，我一直以为用的是a标签。。 //这个方法主要做的是把点击后的元素内容放到input的val值上面，还用这用正则处理了内容 $('.search').search('setInput', $(this).html()) // $('.search-form').submit() //提交验证，这里是可以通过验证的，所以是一个提交操作 $('.search').search('submit') &#125;).on('errEvent', function (e, $layer) &#123; //这个是手动抛出一个事件，主要是错误的时候抛出，确实，如果是错误抛出，我这里逻辑还有问题，我没有把他用作错误处理，应该再写一个事件来处理这个事情，以为他再ajax出错的时候也调用了，和我的逻辑想错，这个问题这里暂不做处理 $layer.html(htmlload) &#125;) function createHeaderLyaer(data, $layer) &#123; //成功回调 var html = '', dataNum = data.result.length, numMax = 9; //自定义显示条目 if (dataNum === 0) &#123; //没有数据就直接退出 return '' &#125; for (var i = 0; i &lt; dataNum; i++) &#123; //循环遍历数据 if (numMax &lt;= i) &#123; //自定义显示条目 break &#125; html += '&lt;li class="search-layer-item text-ellipsis"&gt;'+data.result[i][0]+'&lt;/li&gt;' &#125; return html &#125; 手动完成购物车，我服了。。完成了，用的是前面下拉的动画组件 focus区域结构12345678910111213141516category 左侧 a.category-title i ul.category-list li.doropdown div.dropdown-toggle a.dropdown-link i div.dropdown-layer dl.category-details.clearfix dt.category-details-title a.category-details-title-link dd.category-details-item a.linkcarousel 幻灯片focus-sidebar focus html结构1234567891011div.focus-sidebar.fr div.focus-news div.focus-news-head h2.focus-news-title.fl a.link.fr div.focus-news-body p.text-ellipsis a.link strong div.focus-service div.focus-ad 便捷服务1234div.focus-service a.fl.focus-service-item i.iconfont.focus-service-icon span.focus-service-text 幻灯片页面结构123456789div.slider div.slider-container div.slide-item a img ol.slider-indicator-wrap li.fl.slider-indicator a.slider-control-left a.slider-control-right 幻灯片这里用了给技巧，左右滑动第一种滑动是很简单的：比如向左滑动，切换的时候把下一张图片放置到-100%的位置，因为是瞬间的，人眼是看不到的，然后开始上一个元素向右运动，当前元素进入，造成一个从左边出来的假象，右滑动一个道理，没写的时候脑子还真像不过来。。。123456789101112// 初始位置，去除transition是因为这里的动画必须是瞬间的，所以必须清楚this.$items.eq(index).removeClass(this.transitionClass).css('left', -1 * direction * this.itemWidth)// 动画开始，var self = thissetTimeout(function () &#123; self.$items.eq(self.curIndex).move('to', direction * self.itemWidth) //这里添加是因为我们仅清除了 index的动画，curIndex没有清楚动画 self.$items.eq(index).addClass(self.transitionClass).move('to', 0) //如果写到外面会有bug self.curIndex = index&#125;, 20) mongoose命令12345show dbs // 所有数据库use imooc // 连接该库，没有则创建show tables // 查询该库的 表/集合 db // 当前所在数据库]]></content>
  </entry>
  <entry>
    <title><![CDATA[重学jQuery API]]></title>
    <url>%2Fblog%2F2019%2F03%2F16%2F%E9%87%8D%E5%AD%A6jQuery%2F</url>
    <content type="text"><![CDATA[本来看jQuery源码的，发现不是现阶段看的东西，最好还是把jquery api查看一下 api开始看起.add()将匹配元素添加到集合中1$('.j').add('.name').css(&#123;'background': 'red'&#125;) //会给匹配到的.j .name都添加背景色 .addBack()这个就是将前面匹配的元素组合到一起1$('.j').find('p').addBack().addClass('background');//给匹配到的P元素添加class，匹配到的.j class也添加class .addClass()顾名思义添加class可以接收一个字符串，或者一个回调函数，1234$('.j').addClass(function (index, currentClass) &#123; return 'item-' + index //currentClass就是当前元素的Class，这里面的this代表元素本身，chrome只能看到元素，firefox可以看到元素的属性和方法，如果用ES6的箭头函数则this代表window对象&#125;) .after()给匹配元素集合中插入参数所指定的内容1234$('.inner').after(function () &#123; return '&lt;div&gt;' + this.className + '&lt;/div&gt;'&#125;);//可以接收一个函数，或者直接传参，有函数操作起来多样性this和上面一样 .ajaxComplete()请求完成时注册一个回调函数，和start很像1234$(document).ajaxComplete(function() &#123; console.log('s') $( ".log" ).text( "Triggered ajaxComplete handler." );&#125;); .ajaxError()Ajax请求失败，触发该回调函数 .ajaxSend()ajax发送请求前执行 .ajaxStart()ajax发送刚开始执行 .ajaxStop()ajax发送完成后执行 append()和after() 好像啊，一样的？匹配到的元素后添加 appendTo匹配到的元素前 .attr()获取匹配元素的属性或设置属性的值 选择器模板123456789101112&lt;div class="hom" wot="cn"&gt; use name&lt;/div&gt;&lt;div class="hom" wot="cn n"&gt; use name&lt;/div&gt;&lt;div class="hom" wot="cnnnbbb-n"&gt; use name&lt;/div&gt;&lt;div class="hom" wot="cn-youcan"&gt; use name&lt;/div&gt; [name|=value]可以匹配到上面12$('div[wot|=cn]'//可以匹配到cn-开头的 [name*=value]1//只要是包含cn的，都可以匹配到 [name$=value]1value结尾的 [name~=value]12以空格间隔的cn n [name=value]1绝对匹配 [name$=value]12 tab 开发$.extend()可以使用深度拷贝，但是本节用法好像就是普通合并？直接=赋值好像也可以？ $.parseJSON()1接收一个json字符串，返回解析后的javascript对象 .siblings()匹配元素的其他同级元素 .trigger()手动触发事件 有个事件冒泡bug，是这个解决的阻止事件冒泡 防抖处理向量向量： Vab = Pb -Pa二维向量叉乘公式：a(x1, y1) b(x2,y2) = x1y2 - x2*y1 用叉乘法判断点在三角形内 学习视频：逐行分析jQueryjQuery学习版本：2.0.3 第一节匿名函数自执行1234567(function () &#123; var a = 10; function $() &#123; alert(a) &#125; windows.$ = $ //暴露出去&#125;)() js继承机制用构造函数生成的实例对象，有一个缺点，那就是无法共享属性和方法 123456789101112131415161718192021222324function Dog(name) &#123; this.name = name this.sg = '犬科'&#125;var s = new Dog('大毛')var s2 = new Dog('二毛')s2.sg = '猫科'console.log(s) //犬科//犬科的方法无法继承function Dog(name) &#123; this.name = name&#125; Dog.prototype = &#123; sg = '猫科'&#125;var s = new Dog('大毛')var s2 = new Dog('二毛')s2.sg = '猫科'console.log(s) //猫科//写在原型上的就会被继承//s2实现了继承 第四节匿名函数自执行123(function (window) &#123;&#125;)(window) 之所以传入window有两个原因: 可以提快window的查找速度 压缩代码后，有利于代码压缩如下：1(function(e)&#123;&#125;)(window) 接收的window会被替换为e 接收undefined123(function (window, undefined) &#123;&#125;)(window) 接收一个形参，undefined，防止被外部修改因为undefined非关键字，非保留字，所以低版本浏览器bug可以修改，IE8一下浏览器都有这个bug一下是修改undefined例子：12345678910var undefined = 15;(function () &#123; var a; // 如果a没有值则为a赋值. 但因为undefined被重写了，所以这句根本执行不到。 console.log(a, undefined); if (a === undefined) &#123; a = 'b'; &#125; console.log(a);&#125;)(); 参考文章: 为什么要传入 undefined 第五节jQuery设计原理12345678910111213function jQuery () &#123; return new jQuery.prototype.init()&#125; jQuery.prototype = &#123; init: function () &#123; &#125;, css: function () &#123; console.log('nice') &#125; &#125;jQuery.prototype.init.prototype = jQuery.prototypejQuery().css() 第七节 为什么要把constructor重新指向的原因： 12345678function Arr() &#123;&#125;Arr.prototype = &#123; name = &apos;hhh&apos;&#125;var a1 = new Arr()console.log(a1.constructor) //Object() 因为这样写会把prototype赋值一个新的对象而这样写就不会123456function Arr () &#123;&#125;Arr.prototype.name = &apos;hhh&apos;var a1 = new Arr()console.log(a1.constructor) //Arr() 这样写就不会改变constructor不过对象的方式比较方便，常用所以改下成下面的写法1234567function Arr() &#123;&#125;Arr.prototype = &#123; constructor: Arr, name: &apos;hhh&apos;&#125;var a1 = new Arr()console.log(a1.constructor) //Arr()]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack 4配置]]></title>
    <url>%2Fblog%2F2019%2F03%2F08%2Fwebpack-4%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 配置 更新后的配置，目前再用的，以前的废弃了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185const path = require('path');const devMode = process.env.NODE_ENV !== 'production'// const devMode = trueconst MiniCssExtractPlugin = require("mini-css-extract-plugin");const HtmlWebpackPlugin = require('html-webpack-plugin');const webpack = require('webpack');module.exports = &#123; entry: &#123; index: './src/pages/index/index.js', // main: './src/pages/page1/main.js' &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: './src/pages/index/index.html', filename: 'index.html', inject: true, hash: true, chunks: ['vendor','common','runtime','index'], minify: process.env.NODE_ENV !== "production" ? false : &#123; removeComments: true, // collapseWhitespace: true, removeAttributeQuotes: true, &#125; &#125;),/* new HtmlWebpackPlugin(&#123; template: './src/pages/page1/main.html', filename: 'main.html', inject: true, hash: true, chunks: ['vendor','common','runtime','main'], minify: process.env.NODE_ENV !== "production" ? false : &#123; removeComments: true, // collapseWhitespace: true, removeAttributeQuotes: true, &#125; &#125;),*/ new webpack.ProvidePlugin(&#123; $: 'jquery', jQuery: 'jquery' &#125;) ], output: &#123; filename: devMode ? 'js/[name].[hash:8].js': 'js/[name].[chunkhash:8].js', chunkFilename: devMode ? 'js/[name].[hash:8].js': 'js/[name].[chunkhash:8].js', path: path.resolve(__dirname, '../dist'), publicPath: './' &#125;, resolve: &#123; alias: &#123; // '@': resolve('src'), '@': path.resolve(__dirname, '../src/'), '~node': path.resolve(__dirname, '../node_modules/'), '~css': path.resolve(__dirname, '../src/css/'), // 'common': resolve('src/common') &#125; &#125;, optimization: &#123; runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125;, utils: &#123; // 抽离自己写的公共代码，common这个名字可以随意起 chunks: 'initial', name: 'common', // 任意命名 minSize: 0, // 只要超出0字节就生成一个新包 minChunks: 2 &#125; &#125; &#125; &#125;, module: &#123; rules: [ &#123; test: /\.(less|css)$/, use: [ &#123; //因为只有style-loader有热更新，所以这么写 loader: devMode ? 'style-loader' : MiniCssExtractPlugin.loader, options: devMode ? &#123; sourceMap: true, &#125; : &#123; publicPath: '../' &#125; &#125;, &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', sourceMap: true, plugins: [ require('postcss-preset-env')() ] &#125; &#125;, &#123; loader: 'less-loader', options: &#123; sourceMap: true &#125; &#125; ], &#125;, &#123; test: /\.(gif|png|jpe?g|svg)$/i, use: [ &#123; loader: 'url-loader', // loader: 'file-loader', options: &#123; limit: 8192, name: '[name].img.[hash:5].[ext]', outputPath: 'img', &#125; &#125;, &#123; loader: "image-webpack-loader", options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: '65-90', speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125; &#125; &#125; ] &#125;, &#123; test: /\.(woff|woff2|eot|ttf|otf|svg)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: 'css/font/[name].font.[hash:6].[ext]', &#125; &#125; ] &#125;, &#123; test: /\.html$/, use: [ &#123; //raw-loader是修改html更新页面，而且必须这么写，不然两个一起用会出现bug，如果只用raw-loader页面就没办法处理Img了 loader: 'html-loader?config=raw-loader', options: &#123; attrs: ['img:src', 'img:data-src'], &#125; &#125;, ] &#125;, &#123; //这里也是踩坑了，必须webpack这么写，然后.babelrc 才会被处理 test: /\.js$/, use: [ &#123; loader: 'babel-loader' &#125; ] &#125; ] &#125;,&#125;; .babelrc1234&#123; "presets": ["@babel/preset-env"], "plugins": [["@babel/plugin-transform-runtime", &#123; "corejs": 2 &#125;]]&#125; webpack.dev.js 主要就是更新了路径把，因为目录全部迁移到build了123456789101112131415const merge = require('webpack-merge');const common = require('./webpack.common.js');const path = require('path');module.exports = merge(common, &#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: path.resolve(__dirname, '../src/pages/assets'), publicPath: '/', hot: true, // compress: true, // overlay: true &#125;&#125;); webpack.prod.js12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667const merge = require('webpack-merge');const common = require('./webpack.common.js');const path = require('path');const CleanWebpackPlugin = require('clean-webpack-plugin');const OptimizeCSSAssetsPlugin = require("optimize-css-assets-webpack-plugin");const HtmlWebpackPlugin = require('html-webpack-plugin');// const UglifyJsPlugin = require("uglifyjs-webpack-plugin");const TerserPlugin = require('terser-webpack-plugin');const MiniCssExtractPlugin = require("mini-css-extract-plugin");// const Purifycss = require('purifycss-webpack')const PurgecssPlugin = require('purgecss-webpack-plugin')const glob = require('glob-all')const copyWebpackPlugin = require("copy-webpack-plugin");const PATHS = &#123; src: path.join(__dirname, '../src')&#125;module.exports = merge(common, &#123; mode: 'production', optimization: &#123; minimizer: [ //这个可以支持es6语法，不过用babel打包后也可以支持？，没测试，当时是babel没设置好，出现了一点bug new TerserPlugin(), new OptimizeCSSAssetsPlugin(&#123;&#125;) ] &#125;, plugins: [ new CleanWebpackPlugin(['dist/*'],&#123; root: path.resolve(__dirname, '../'), //根目录 verbose: true, //开启在控制台输出信息 dry: false, &#125;), new MiniCssExtractPlugin(&#123; filename: "css/[name].[contenthash:8].css", chunkFilename: "css/[name].[contenthash:8].css", &#125;), //拷贝静态文件，这个其实还要再改的，我没弄，不过这个改起来很方便 new copyWebpackPlugin([&#123; from: path.resolve(__dirname, "../src/assets"), to: './assets', // ignore: ['.*'] &#125;]), new copyWebpackPlugin([&#123; from: path.resolve(__dirname, "../src/pages/assets"), to: './', ignore: ['.*'] &#125;]), // new Purifycss(&#123; // paths: glob.sync([ // path.join(__dirname, '../src/pages/*/*.html'), // path.join(__dirname, '../src/pages/*/*.js') // ]), // purifyOptions: &#123; // whitelist: ['slick.less','slick-theme.less'] // &#125; // &#125;), //css的去重，以前用的purifycss，好像不更新了，这个是新版，后面有个白名单，正则匹配，就是不管里面的class命名的代码 new PurgecssPlugin(&#123; paths: glob.sync(`$&#123;PATHS.src&#125;/pages/*/*`, &#123; nodir: true &#125;), //白名单css，正则匹配css whitelistPatterns: [/^(slick)/] &#125;), ]&#125;); package.json12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&#123; "name": "shop", "version": "1.0.0", "description": "", "main": "webpack.common.js", "scripts": &#123; "dev": "cross-env NODE_ENV=development webpack-dev-server --host 0.0.0.0 --config build/webpack.dev.js", "build": "cross-env NODE_ENV=production webpack --config build/webpack.prod.js" &#125;, "repository": &#123; "type": "git", "url": "git+https://github.com/DemoorBug/shop.git" &#125;, "keywords": [], "author": "", "license": "ISC", "bugs": &#123; "url": "https://github.com/DemoorBug/shop/issues" &#125;, "homepage": "https://github.com/DemoorBug/shop#readme", "devDependencies": &#123; "@babel/core": "^7.3.4", "@babel/plugin-transform-runtime": "^7.3.4", "@babel/preset-env": "^7.3.4", "@babel/runtime": "^7.3.4", "@babel/runtime-corejs2": "^7.3.4", "babel-loader": "^8.0.5", "clean-webpack-plugin": "^1.0.1", "copy-webpack-plugin": "^5.0.0", "cross-env": "^5.2.0", "css-loader": "^2.1.0", "eslint": "^5.15.1", "file-loader": "^3.0.1", "glob-all": "^3.1.0", "html-loader": "^0.5.5", "html-webpack-plugin": "^3.2.0", "image-webpack-loader": "^4.6.0", "imagemin": "^6.1.0", "imagemin-gifsicle": "^6.0.1", "imagemin-mozjpeg": "^8.0.0", "imagemin-optipng": "^6.0.0", "imagemin-pngquant": "^7.0.0", "imagemin-svgo": "^7.0.0", "imagemin-webp": "^5.0.0", "img-loader": "^3.0.1", "less": "^3.9.0", "less-loader": "^4.1.0", "mini-css-extract-plugin": "^0.5.0", "optimize-css-assets-webpack-plugin": "^5.0.1", "postcss-cssnext": "^3.1.0", "postcss-loader": "^3.0.0", "postcss-preset-env": "^6.6.0", "purgecss-webpack-plugin": "^1.4.0", "purify-css": "^1.2.5", "purifycss-webpack": "^0.7.0", "raw-loader": "^1.0.0", "style-loader": "^0.23.1", "terser-webpack-plugin": "^1.2.3", "uglifyjs-webpack-plugin": "^2.1.2", "url-loader": "^1.1.2", "webpack": "^4.29.6", "webpack-cli": "^3.2.3", "webpack-dev-server": "^3.2.1", "webpack-merge": "^4.2.1" &#125;, "dependencies": &#123; "bootstrap": "^3.4.1", "jquery": "^3.3.1", "lodash": "^4.17.11", "minireset.css": "0.0.4", "normalize.css": "^8.0.1", "slick-carousel": "^1.8.1" &#125;, "browserslist": [ "&gt; 1%", "last 2 versions", "not ie &lt;= 8" ]&#125; webpack.common.js 后面的都弃用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157const path = require('path');const devMode = process.env.NODE_ENV !== 'production'// const devMode = trueconst MiniCssExtractPlugin = require("mini-css-extract-plugin");const HtmlWebpackPlugin = require('html-webpack-plugin');module.exports = &#123; //入口文件依据目录随时添加 entry: &#123; index: './src/pages/index/index.js', main: './src/pages/page1/main.js' &#125;, plugins: [ //HtmlWebpackPlugin这个也是依据入口文件随时添加，我这样写很麻烦，要弄个自动化的 new HtmlWebpackPlugin(&#123; template: './src/pages/index/index.html', filename: 'index.html', inject: true, hash: true, chunks: ['vendor','common','runtime','index'], minify: process.env.NODE_ENV !== "production" ? false : &#123; removeComments: true, // collapseWhitespace: true, removeAttributeQuotes: true, &#125; &#125;), new HtmlWebpackPlugin(&#123; template: './src/pages/page1/main.html', filename: 'main.html', inject: true, hash: true, chunks: ['vendor','common','runtime','main'], minify: process.env.NODE_ENV !== "production" ? false : &#123; removeComments: true, // collapseWhitespace: true, removeAttributeQuotes: true, &#125; &#125;), ], output: &#123; filename: devMode ? 'js/[name].[hash:8].js': 'js/[name].[chunkhash:8].js', chunkFilename: devMode ? 'js/[name].[hash:8].js': 'js/[name].[chunkhash:8].js', path: path.resolve(__dirname, '../dist'), publicPath: './' &#125;, optimization: &#123; runtimeChunk: 'single', splitChunks: &#123; cacheGroups: &#123; vendor: &#123; // 抽离第三方插件 test: /node_modules/, // 指定是node_modules下的第三方包 chunks: 'initial', name: 'vendor', // 打包后的文件名，任意命名 // 设置优先级，防止和自定义的公共代码提取时被覆盖，不进行打包 priority: 10 &#125;, utils: &#123; // 抽离自己写的公共代码，common这个名字可以随意起 chunks: 'initial', name: 'common', // 任意命名 minSize: 0, // 只要超出0字节就生成一个新包 minChunks: 2 &#125; &#125; &#125; &#125;, module: &#123; rules: [ &#123; test: /\.css$/, use: [ &#123; loader: devMode ? 'style-loader' : MiniCssExtractPlugin.loader, options: &#123; sourceMap: true, //单独给css里面的路径设置规则，防止和html里面的img路径冲突 publicPath: '../' &#125; &#125;, &#123; loader: 'css-loader', options: &#123; sourceMap: true &#125; &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', sourceMap: true, plugins: [ require('postcss-preset-env')() ] &#125; &#125; ], &#125;, &#123; test: /\.(gif|png|jpe?g|svg)$/i, use: [ &#123; loader: 'url-loader', options: &#123; limit: 8192, name: '[name].img.[hash:5].[ext]', outputPath: 'img', &#125; &#125;, &#123; loader: "image-webpack-loader", options: &#123; mozjpeg: &#123; progressive: true, quality: 65 &#125;, optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: '65-90', speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125; &#125; &#125; ] &#125;, &#123; test: /\.(woff|woff2|eot|ttf|otf|svg)$/, use: [ &#123; loader: 'file-loader', options: &#123; name: 'css/font/[name].font.[hash:6].[ext]', &#125; &#125; ] &#125;, &#123; test: /\.html$/, use: [ &#123; loader: 'html-loader', options: &#123; attrs: ['img:src', 'img:data-src'], &#125; &#125; ] &#125; ] &#125;, &#125;; webpack.dev.js12345678910const merge = require('webpack-merge');const common = require('./webpack.common.js');module.exports = merge(common, &#123; mode: 'development', devtool: 'inline-source-map', devServer: &#123; contentBase: './dist', hot: true, &#125;&#125;); webpack.prod.js1234567891011121314151617181920212223242526272829303132333435363738394041424344const merge = require(&apos;webpack-merge&apos;);const common = require(&apos;./webpack.common.js&apos;);const path = require(&apos;path&apos;);const CleanWebpackPlugin = require(&apos;clean-webpack-plugin&apos;);const OptimizeCSSAssetsPlugin = require(&quot;optimize-css-assets-webpack-plugin&quot;);const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);const UglifyJsPlugin = require(&quot;uglifyjs-webpack-plugin&quot;);const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);const Purifycss = require(&apos;purifycss-webpack&apos;)const glob = require(&apos;glob-all&apos;)const copyWebpackPlugin = require(&quot;copy-webpack-plugin&quot;);module.exports = merge(common, &#123; mode: &apos;production&apos;, optimization: &#123; minimizer: [ new UglifyJsPlugin(&#123; //处理js压缩 cache: true, parallel: true, sourceMap: true // set to true if you want JS source maps &#125;), new OptimizeCSSAssetsPlugin(&#123;&#125;) //压缩css ] &#125;, plugins: [ new CleanWebpackPlugin([&apos;dist/*&apos;]), //去除dist目录 new MiniCssExtractPlugin(&#123; //提取css filename: &quot;css/[name].[contenthash:8].css&quot;, chunkFilename: &quot;css/[name].[contenthash:8].css&quot; &#125;), new copyWebpackPlugin([&#123; //这个可以提取静态文件，以后还会增加 from: path.resolve(__dirname, &quot;../src/assets&quot;), to: &apos;./assets&apos;, ignore: [&apos;.*&apos;] //排除目录 &#125;]), new Purifycss(&#123; //tree shaking css paths: glob.sync([ path.join(__dirname, &apos;../src/*.html&apos;), path.join(__dirname, &apos;../src/*.js&apos;) ]) &#125;), ]&#125;);]]></content>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2Fblog%2F2019%2F03%2F03%2Fgit%2F</url>
    <content type="text"><![CDATA[新电脑创建后快速使用 git博客怎么没了？ 1234567cd ~ //切换到根目录ssh-keygen -t rsa -C "demoorbug@gmail.com"cd .sshcat id_rsa.pub // 将打印出来的复制到 github.com&gt;settings&gt;SSH and GPG Keys&gt;New SSHkeygit config --global user.name "DEBUG"git config --global user.email "demoorbug@gmail.com" 本地项目替换线上项目1234567//下载压缩包解压后进入，更改后git add .git commit -m 'New'git remote add origin git@github.com:DemoorBug/shop.gitgit pullgit push -u origin master -f // -f force是强制的意思 创建项目12345678mkdir shop //创建shop文件夹cd shopgit init //初始化项目touch README.md //创建初始化项目文件git add .git commit -m "shop" //本次提交信息简介git remote add origin git@github.com:DemoorBug/shop.gitgit push -u origin master //-u代表了关联本地分支和线上分支的master分支，以后就可以直接git push了 查看 remote 以及删除重新添加方法 12git remote -vgit remote remove &lt;name&gt; 分支12345git checkout -b index-redux //创建分支git push origin index-redux //推送到线上，没有就创建git checkout mastergit merge origin/index-redux // 合并分支git push 查看分支 12git branch -a // 或git branch 删除分支 12git branch -d index-redux // 删除本地分支git push origin --delect index-redux // 删除远程分支 撤销 commit这样就成功的撤销了你的 commit注意，仅仅是撤回 commit 操作，您写的代码仍然保留。 1git reset --soft HEAD^ HEAD^的意思是上一个版本，也可以写成 HEAD~1如果你进行了 2 次 commit，想都撤回，可以使用 HEAD~2 options–mixed意思是：不删除工作空间改动代码，撤销 commit，并且撤销 git add . 操作这个为默认参数,git reset –mixed HEAD^ 和 git reset HEAD^ 效果是一样的。 –soft不删除工作空间改动代码，撤销 commit，不撤销 git add . –hard删除工作空间改动代码，撤销 commit，撤销 git add . 如果是注释写错了可以1git commit --amend // 就会进入编辑模式 拉取线上代码1git clone git@github.com:DemoorBug/pubg-api.git // 项目地址 win10 系统激活 打开“MSDOS”窗口，在此界面中，依次输出以下命令：slmgr.vbs /upk 复制以上命令，并在MSDOW 窗口中右击以粘贴此命令，按回车进行确定，显示:“已成功卸载了产品密钥”； 接着输入以下命令：slmgr /ipk W269N-WFGWX-YVC9B-4J6C9-T83GX 显示:“成功的安装了产品密钥”； 继续输入以下命令：slmgr /skms zh.us.to，显示:“密钥管理服务计算机名成功的设置为zh.us.to”； 下来输入以下命令：slmgr /ato，显示:“成功的激活了产品”；]]></content>
  </entry>
  <entry>
    <title><![CDATA[商城网站开发记录]]></title>
    <url>%2Fblog%2F2019%2F03%2F03%2F%E5%95%86%E5%9F%8E%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[依照官方webpack 4配置webpack官方 官方的文档很详细，看起来轻松多了今天看到Production （生产）明天继续]]></content>
  </entry>
  <entry>
    <title><![CDATA[URL]]></title>
    <url>%2Fblog%2F2019%2F01%2F23%2FURL%2F</url>
    <content type="text"><![CDATA[网址收集.ico 在线转换 网址mackdown在线编辑 目前用的在线编辑最新浏览器升级 无穷无尽的设计可能 图标压缩OwlCarousel2 轮播插件PNG JPG..压缩SVG图片压缩图标库icomooniconfontHACKbrowserhackscaniuseshouldiprefix HTML5标签支持支持IE6-IE8CSS3媒体查询兼任IE6-IE8主动性检测兼容问题 防御性编程在线压缩 贝塞尔曲线线上编写代码测试，提问ICON图标下载江江推荐的二次元网站 响应式框架BootstrapFoundation 结构语义化，移动设备优先，完全可以定制Semantic UI 命名非常的语义化PureCss 非常轻量级 功能性网站一个不用注册就可以接收邮件的网站]]></content>
  </entry>
  <entry>
    <title><![CDATA[javascript]]></title>
    <url>%2Fblog%2F2019%2F01%2F13%2Fjavascript%2F</url>
    <content type="text"><![CDATA[Arrayconcat()用于连接两个或多个数组copyWithin() es6复制元素到指定位置array.copyWithin(复制到指定目标索引,[起始位置，[停止位置]])12var arrs = [1, 2, 3, 4, 5]arrs.copyWithin(2,0,2) entries() es6给数组添加键值对,返回一个可迭代对象没有参数1234var arrs = [1, 2, 3, 4, 5];for (let i of arrs.entries()) &#123; console.log(i)&#125; every()和some() 一直，不过有不同，some位置下面有写1234let ages = [30,32,43,52];ages.every((age) =&gt; &#123; return age &gt; 1&#125;) 如果全部满足条件就返回true，负责一个不满足就会终止返回falsefilter()过滤，可以直接使用every的案例，结果就是过滤后的值12let ages = [30, 32, 43, 52];ages.filter((age) =&gt; age &lt; 31) //[30] find() es6接收函数，检测条件为true时，直接返回，接下来就不会继续执行12let ages = [30, 32, 43, 53];ages.find((age) =&gt; age == 32) //32 findIndex() es6返回索引，没有就是-112let ages = [30, 32, 43, 53];ages.findIndex((a) =&gt; return a == 30) //结果返回索引0 fill()填充12let arrs = [30, 32, 43, 52];arrs.fill('i', 0, 1) forEach()循环12let ages = [30, 32, 43, 52];ages.forEach((age, index) =&gt; console.log(age, index)) from() es6处理带有length属性的对象，或可迭代对象，返回数组12Array.from([2, 1, 3, 5, 6], (arr) =&gt; arr + 1) //案例中数组用new Set([2, 1, 3, 5, 6])这种方式，Set还没看，不清楚 includes() es6感觉像是find的简单用法？这个方法可以替代indexOf()12let ages = [30, 32, 43, 52];ages.includes(30) //true,这个是es6方法，比indexOf强大 indexOf()返回查询的值，没有就是-1，好处在于以前的浏览器兼容12let ages = [30, 32, 43, 52];ages.indexOf(30) //返回索引位置0，没有就是-1 isArray()判断对象是否为数组12let ages = [30, 32, 43, 52];Array.isArray(ages) //true join()把数组转换为字符串，接收一个参数，通过什么符合组合12let ages = [30, 32, 43, 52];ages.join('') //30324352 keys() es6将数组转换为可迭代对象(Iterator)，可以通过for…of处理1234let ages = [30, 32, 43, 52];for (let i of ages.keys()) &#123; console.log(i) //0, 1, 2, 3返回索引&#125; lastIndexOf()不常用，就是从最后一个开始检索字符串1indexOf() //的反转用法 map()感觉和from()很类似12let ages = [30, 32, 43, 52];ages.map((age) =&gt; age + 1) //[31, 32, 44, 53] pop()删除数组最后一个元素，并返回删除了那个元素，改变原数组12let ages = [30, 32, 43, 52];ages.pop() //52 push()数组末尾添加元素12let ages = [30, 32, 43, 52];ages.push(23) //返回数组length 5 reduce()他可以办到的forEach也可以，用这个逼格？还有高级用法12let ages = [30, 32, 43, 52];ages.reduce((total, age, index, arr) =&gt; total+age) //结果为30+32+43+52总和 reduceRight()和reduce是一样的，不过是从末尾开始reverse()颠倒数组顺序12let ages = [30, 32, 43, 52]; ages.reverse() //修改原数组 shift()删除并返回数组的第一个元素，和pop()兄弟12let ages = [30, 32, 43, 52];ages.shift() //返回删除的值30，改变原数组 slice()截取数组并返回新的数组，不改变原数组1ages.slice(2) //从第二个值开始截取， some()和every()区别在于，every有一个条件不符直接退出，some会查找到返回true为止，否则停止sort()可以让数组顺序依据字母顺序排序，默认升序，文档后面介绍很详细12let ages = ['c', 'a', 'd', 'b'];ages.sort() //还可以添加规则，数字的排序好像还要处理，字母的降序可以用reverse() splice()添加或删除，改变原数组12let ages = [1, 2, 3, 4, 5];ages.splice(2, 1, '5','1'); //[1, 2, '5', '1', 4 , 5] toString()将数组转换为字符串，返回结果12let ages = [1, 2, 3, 4, 5];ages.toString(); //1,2,3,4,5 join()更灵活 unshift()数组开头添加 是push的兄弟valueOf()返回原始数组，用于调试]]></content>
  </entry>
  <entry>
    <title><![CDATA[webpack]]></title>
    <url>%2Fblog%2F2019%2F01%2F06%2Fwebpack%2F</url>
    <content type="text"><![CDATA[webpack版本更迭社区投票官方文档 模块化开发方爷,图虫 js模块化1. 命名空间库名.类别名.方法名123456var NameSpace = &#123;&#125;NameSpace.type = NameSpace.type || &#123;&#125;NameSpace.type.method = function () &#123;&#125; 2. COMMONJS诞生于node社区，只能在服务器端使用一个文件为一个模块通过module.exports 暴露模块接口通过require就可以引入模块 因为commonjs运行在服务端，他的require是同步执行的同步执行http://wiki.commonjs.org/wiki/Modules/1.1.1 3. AMD/CMD/UMDAMD全称Async Module Definition使用define定义模块使用require加载模块比较著名的库RequireJs依赖前置，提前执行123456789101112131415define( //模块名 "alpha", //依赖 ["require", "exports", "beta"], //模块输出 function (require, exports, beta) &#123; exports.verb = function () &#123; return bata.verb(); //Or: //Create missing node module:'beta' return require("beta").verb() &#125; &#125;) CMD通用模块定义Common Module Definition一个文件一个模块使用define定义模块使用require加载模块产物SeaJs尽可能懒执行 12345678910// 所有模块都通过define定义define(function (require, exports, module) &#123; var $ = require('jquery'); var Spinning = require('./spinning'); //通过exports对外提供接口 exports.doSomething = ... //或者通过module.exports 提供整个接口 module.exports = ...&#125;) UMDUniversal Module Definition通用解决方案三个步骤 判断是否支持AMD 判断是否支持CommonJs 如果都没有使用全局变量 4. es moduleEcmaScript Module一个文件一个模块export / import1import &#123; name as myNamed, named &#125; from 'src/mylib' 这样的写法和这个貌似是一样的1import &#123; name : myNamed, named &#125; from 'src/mylib' 拿到全部方法，mylib可以使用他1import * as mylib from 'src/mylib' 只是加载进来，没有任何引用1import 'src/mylib' export, export default export, export default 均可到处常量，函数，文件，模块等 export 一个文件可以有多个， export default一个文件只能有一个 通过export方式导出，在导入时要加{},export default 则不用 export 能直接导出变量表达式，export default则不行12345678910main.jsexport const mapNict = 'map'export const name = function () &#123; console.log('name')&#125;export default &#123; name: function () &#123; console.log('defalut') &#125;&#125; 导入步骤12345678910111213141516app.jsimport &#123; mapNict, name &#125; from './main.js'import m from './main.js'console.log(mapNict); //mapname() //namem.name() //defaultimport * as myname from './main.js'myname.default.name() //defaultconsole.log(myname.mapNict) //mapmyname.name() //name 5. Webpack支持 AMD(RequireJs) //只需要一些了解 ES Modules(推荐的) //主流 CommonJs //主流 Css模块化这点没看，以后有需要回来看吧，感觉没什么用 核心概念1. Entry 代码的入口 打包的入口 单个或多个可以直接是一个文件123module.exports = &#123; entry: './index.js'&#125; 还可以是一个数组123module.exports = &#123; entry: ['index.js', 'vendor.js']&#125; 还可以是一个对象12345module.exports = &#123; entry: &#123; index: 'index.js' &#125;&#125; 2. Output 输出 打包成的文件(bundle) 一个或多个 自定义规则 融合CDN一个123456module.exports = &#123; entry: 'index.js', output: &#123; filname: 'index.min.js' &#125;&#125; 多个1234567891011module.exports = &#123; entry: &#123; index: 'index.js', vendor: 'vendor.js' &#125;, output: &#123; filname: '[name].min.[hash:5].js' &#125; //自定义规则[name]表示entry的name //[hash:5] webpack打包过程中出现的md5码&#125; 3. loaders靠loaders处理其他类型的文件处理文件转化为模块处理css的loader12345678910module.exports = &#123; module: &#123; rules: [ &#123; test: /\.css$/, use: 'css-loader' &#125; ] &#125;&#125; 常用loader编译相关babel-loader、ts-loader样式相关style-loader、css-loader、less-loader、postcss-loader文件相关file-loader、url-loader 4. plugins压缩代码，混淆，代码分割参与打包整个过程打包优化和压缩配置编译时的变量极其灵活1234567891011121314151617181920212223242526272829const webpack = require('webpack')module.exports = &#123; plugins: [ new webpack.optimize.UglifyJsPlugin() //压缩混淆 ]&#125;```js常用Plugins优化相关CommonsChunkPlugin UglifyjsWebpackPlugin //压缩混淆功能相关ExtractTextWebpackPlugin //打包成单独css文件HtmlWebpackPlugin //帮助生成htmlhotModuleReplacementPlugin //模块热更新CopyWebpackPlugin //拷贝文件名词：Chunk 代码块。Bundle 打包过以后的Module 模块# 编译ES6/7## **1. Babel**使用Babel安装最新版```jsnpm install babel-loader@8.0.0-beta.0 @babel/core 普通版本1npm install --save-dev babel-loader babel-core 2. Babel-presets(针对语法)es2015es2016es2017env 一个汇总，包含15-17，以及最近的自定义的babel-preset-react //和React相关的babel-preset-stage 0-3 //还没有发布的 安装的是最新的loader就可以使用这一句1npm install @babel/preset-env --save-dev 安装的是普通版本 1npm install babel-preset-env --save-dev targets 可以指定那些语法编译，那些语法不编译targets.browsers 指定浏览器，还可以指定nodejs版本12targets.browsers: 'last 2 versions' //指定浏览器最后的两个版本targets.browsers: '&gt; 1%' 大于全球占有率1的浏览器都可以支持 数据从github的browserslist项目获得Can I use 3. Babel Polyfill(针对函数和方法)GeneratorsetMapArray.fromArray.prototype.includes全局垫片，会对全局污染为开发应用准备，写一个网站写vue就不能用Polyfill1npm install babel-polyfill --save import “babel-polyfill” —jswebpack.config.js12345678910111213141516171819202122232425262728module.exports = &#123; entry : &#123; app: './app.js' &#125;, output : &#123; filename: '[name].[hash:8].js' &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: [ ['@babel/preset-env', &#123; targets: &#123; browsers: ['&gt; 1%', 'last 2 versions'] &#125; &#125;] ] &#125; &#125;, exclude: '/node_modules' &#125; ] &#125;&#125; 4. Babel Runtime Transform(针对函数和方法)局部垫片为开发框架准备不会污染全局12npm install babel-plugin-transform-runtime --save-devnpm install babel-runtime --save 不知道@babel这种安装方式是为什么？12npm install @babel/plugin-transform-runtime --save-devnpm install @babel/runtime --save 这种方法无法实现，不知道为什么，打包后只有2.6k大小找到解决方法了，增加{ “corejs”: 2 }12345678&#123; "presets": [["@babel/env", &#123; "targets": &#123; "browsers" : ["last 2 versions"] &#125; &#125;]], "plugins": [["@babel/plugin-transform-runtime", &#123; "corejs": 2 &#125;]]&#125; 提取公用代码1. 减少代码冗余 提高加载速度 CommonsChunkPlugin 插件提取公用代码。内置插件 webpack.optimize.CommonsChunkPlugin 配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#123; plugins: [ new weback.optimize.CommonsChunkPlugin(option) ]&#125;```jsoptions配置是什么样的呢：- options.name or options.names - name names 表示Chunk的名称- options.filename 打包之后的名称- options.minChunks - 可以是一个数字也可以是一个函数还可以是一个特殊的值Infinity - 当他是数字的时候，表示为你要提取代码的出现次数最小是多少 - Infinity 这个值的时候他不会把任何代码打包进去 - 还可以是一个函数，可以自定义你的逻辑- options.chunks 提取代码范围，需要在那几个代码中去提取- options.children 是不是在entry的子模块中或者你的所有模块中- options.deepChildren 是不是在entry的子模块中或者你的所有模块中- options.async 会创建一个异步的工作代码流需要把webpack安装到本地，因为这个插件是webpack自带的```jsvar webpack = require('webpack')var path = require('path')module.exports = &#123; entry: &#123; 'pageA': './src/pageA', 'pageB': './src/pageB', 'vendor': 'lodash' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), filename: '[name].bundle.js', chunkFilename: '[name].chunk.js' &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; //打包自己写的公用代码 name: 'common', minChunks: 2, chunks: ['pageA','pageB'] //有bug，这样可以解决 &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; //打包lodash names: ['vendor', 'manifest'], //vendor打包的是lodash,manifest打包的是webpack公用代码 minChunks: Infinity &#125;) ]&#125; 代码分割和懒加载可以通过两种方式懒加载 1. webpack methods require.ensure([],callback, [errorCallback], chunkName) [] : dependencies 加载进来并不会执行 callback errorCallback 可以省略的第三个参数 chunkName require.include([])只接受一个参数，但是不执行 当你的子模块都依赖一个第三方模块，就可以把第三方模块放到父模块里面 123456789101112131415161718require.include('./moduleA.js') //提取公共代码，subPageA和subPageB都引用了moduleA.jsrequire.ensure(['./subPageA'], function () &#123; //打包subPageA var _ = require('./subPageA')&#125;, 'subPageA')require.ensure(['./subPageB'], function () &#123; //打包subPageB var _ = require('./subPageB')&#125;, 'subPageB')require.ensure(['lodash'], function () &#123; //打包lodash var _ = require('lodash') _.join(['1', '2'], '3')&#125;, 'vendor')export default 'pageA' 2. ES 2015 Loader spec12345import(/* webpackChunkName: 'subpageA' */'./subPageA').then(function(subPageA) &#123; console.log(subPageA)&#125;)/* webpackChunkName: 'subpageA' */是webpack支持的魔法函数 pageA.js12345678910import * as _ from 'lodash'import(/* webpackChunkName: 'subpageA' */'./subPageA').then(function(subPageA) &#123; console.log(subPageA)&#125;)import(/* webpackChunkName: 'subpageB' */'./subPageB').then(function(subPageA) &#123; console.log(subPageB)&#125;)export default 'pageA' 3. 如果我们想把异步加载进来模块的代码进行提取，除了require.include(‘./moduleA.js’) ，还可以用webpack.config.js完成1234567891011121314151617181920212223242526272829303132333435363738var webpack = require('webpack')var path = require('path')module.exports = &#123; entry: &#123; 'pageA': './src/pageA', 'pageB': './src/pageB', 'vendor': 'lodash' &#125;, output: &#123; path: path.resolve(__dirname, './dist'), publicPath: './dist/', filename: '[name].bundle.js', chunkFilename: '[name].chunk.js' &#125;, plugins : [ new webpack.optimize.CommonsChunkPlugin(&#123; //打包lodash async: 'async-common', //处理异步加载进来的代码 children: true, //entry模块的子模块 minChunks: 2 &#125;), new webpack.optimize.CommonsChunkPlugin(&#123; //打包lodash names: ['vendor', 'manifest'], minChunks: Infinity &#125;) ] // plugins: [ // new webpack.optimize.CommonsChunkPlugin(&#123; //打包自己写的公用代码 // name: 'common', // minChunks: 2, // chunks: ['pageA','pageB'] //有bug，这样可以解决 // &#125;), // new webpack.optimize.CommonsChunkPlugin(&#123; //打包lodash // names: ['vendor', 'manifest'], // minChunks: Infinity // &#125;) // ]&#125; 处理css1. style-loader创建标签，如何把css放到html中 style-loaderstyle-loader/urlstyle-loader/useable style-loader1234567891011121314151617181920212223242526272829var path = require('path')module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.css/, use: [ &#123; loader: 'style-loader' //这种常用 //loader: 'style-loader/url' //这种方法比较小众，大家了解就好了 &#125;, &#123; loader: 'css-loader' //这种常用 //loader: 'file-loader' //这种方法比较小众，大家了解就好了，这里还要安装file-loader &#125; ] &#125; ] &#125;&#125; style-loader/useable123456789101112131415module: &#123; rules: [ &#123; test: /\.css/, use: [ &#123; loader: 'style-loader/useable' &#125;, &#123; loader: 'css-loader' &#125; ] &#125; ] &#125; app.js 1234import base from './css/base.css' base.use() //引入base.unuse() //删除 配置选项 options insertAt(插入位置) insertInto(插入到dom) singleton(是否使用一个style标签) transform (转化，浏览器环境下，插入页面前)webpack.config.js1234567891011121314151617181920module: &#123; rules: [ &#123; test: /\.css/, use: [ &#123; loader: 'style-loader', options: &#123; insertInto: '#app', singleton: true, transform: './css.transform.js' &#125; &#125;, &#123; loader: 'css-loader' &#125; ] &#125; ]&#125; css.transform.js1234module.exports = function (css) &#123; console.log(css) return css&#125; 2. css-loader如何让js一个import引入css怎么使用呢，去官方看，老师教的那个minimze已经弃用了中文官网还是很久之前的文档，所以这里是英文的css-loader配置选项 options alias (解析的别名) importLoader (@import) Minimze(是否压缩) modules (启用css-modules) 3. css-modules css模块化 :local 可以给定一个本地的样式 :global 可以给定一个全局的样式 compose 可以继承一段样式 compose … from path 从某一个文件引入样式 less cass 3-12节很简单只需要安装所需要的loader12npm install less-loader less --save-devnpm install sass-loader node-sass --save-dev 编译less123456789101112131415161718192021222324252627282930313233var path = require('path')module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: [ &#123; loader: 'style-loader', options: &#123; singleton: true, &#125; &#125;, &#123; loader: 'css-loader' &#125;, &#123; loader: 'less-loader' &#125; ] &#125; ] &#125;&#125; 提取css1. extract-loader 2. ExtractTextWebpackPlugin 主流安装1npm install extract-text-webpack-plugin 123456789101112131415161718192021222324252627282930313233343536373839404142var path = require('path')var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &#123; loader: 'style-loader', options: &#123; singleton: true, &#125; &#125;, use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'less-loader' &#125; ] &#125;) &#125; ] &#125;, plugins: [ new ExtractTextWebpackPlugin(&#123; filename: '[name].min.css' &#125;) ]&#125; 提取出来的文件要自己引入到页面 PostCSS安装 ：12345postcsspostcss-loaderAtuoprefixer //帮助你写各个浏览器之间的前缀postcss-cssnano //帮助我们压缩csspostcss-cssnext //使用最新的css语法：CSS Variables, custom selectors, calc() npm:1npm install postcss postcss-loader autoprefixer cssnano postcss-cssnext 本节的代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var path = require('path')var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &#123; loader: 'style-loader', options: &#123; singleton: true, &#125; &#125;, use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'postcss-loader', //引入的位置必须是css-loader之后，less预处理语音之前 options: &#123; ident: 'postcss', //表明后面的插件是给postcss使用的 plugins: [ // require('autoprefixer')(), require('postcss-cssnext')() //这个里面包含了autoprefixer ] &#125; &#125;, &#123; loader: 'less-loader' &#125; ] &#125;) &#125; ] &#125;, plugins: [ new ExtractTextWebpackPlugin(&#123; filename: '[name].min[hash:5].css' &#125;) ]&#125; browserslist:所有插件共用package.json1234"browserslist": [ "&gt;= 1%", "last 2 versions"] .browserslistrc postcss-importpostcss-urlpostcss-assets后面会讲到 Tree ShakingWebpack.optimize.uglifyJs12345var webpack = require('webpack')plugins: [ new webpack.optimize.UglifyJsPlugin() ] lodash 要借助别的插件才可以完成Tree Shaking12npm install babel-plugin-lodash --save-devnpm install babel-loader babel-core babel-preset-env webpack.config.js12345678910111213141516module: &#123; rules: [ &#123; test: /\.js$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['env'], plugins: ['lodash'] &#125; &#125; ] &#125; ]&#125; 新建了个ces文件夹，明天里面搞 找到问题了，如果用babel 6就要安装1npm install babel-loader@7 babel-core babel-preset-env css-loader@1 //css-loader是上节用的 安装babel 71npm install babel-loader @babel/core @babel/preset-env css-loader //新版本方便 本节代码123456789101112131415161718192021222324252627282930313233var path = require('path')var webpack = require('webpack')module.exports = &#123; entry: &#123; app: './index.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'], plugins: ['lodash'] &#125; &#125; &#125; ] &#125;, plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; names: ['manifest'], //manifest打包的是webpack公用代码 minChunks: Infinity &#125;), new webpack.optimize.UglifyJsPlugin() //Tree Shaking，Webpack.optimize.uglifyJs ]&#125; CSS Tree ShakingPurify CSS很多打包工具都可以用，比如gulp针对webpack，purifycss-webpack options paths: glob.sync([]) npm install glob-all --save-dev //处理多路径 1npm install purifycss-webpack glob-all 新版本还要安装purify-css1npm install purify-css 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071var path = require('path')var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')var webpack = require('webpack')var Purifycss = require('purifycss-webpack')var glob = require('glob-all')module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &#123; loader: 'style-loader', options: &#123; singleton: true, &#125; &#125;, use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'postcss-loader', //引入的位置必须是css-loader之后，less预处理语音之前 options: &#123; ident: 'postcss', //表明后面的插件是给postcss使用的 plugins: [ require('autoprefixer')(), // require('postcss-cssnext')() //这个里面包含了autoprefixer ] &#125; &#125;, &#123; loader: 'less-loader' &#125; ] &#125;) &#125;, &#123; test: /\.js$/, use: &#123; loader: 'babel-loader', options: &#123; presets: ['env'], plugins: ['lodash'] &#125; &#125;, exclude: '/node_modules' &#125; ] &#125;, plugins: [ new ExtractTextWebpackPlugin(&#123; filename: '[name].min[hash:5].css' &#125;), new Purifycss(&#123; paths: glob.sync([ path.join(__dirname, './*.html') //本节代码 ]) &#125;), new webpack.optimize.UglifyJsPlugin() ]&#125; 文件处理1. 图片处理css中引入的图片file-loader 自动合成雪碧图，减少http请求postcss-sprites 压缩图片img-loader小图片可以使用Base64编码url-loader 字体文件 第三方js库 CDN地址 首先安装前面所提到的模块12npm install file-loader url-loader img-loader postcss-sprites//放到一起安装会出错?有毒,多安装两遍就好了，postcss-sprites单独安装 新版本还要安装1npm install imagemin imagemin-mozjpeg 研究了一小时的bug，原来是我的图片有问题，哔了狗，500px下的图片。。。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var path = require('path')var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')var imagemin = require('imagemin');module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &#123; loader: 'style-loader', options: &#123; singleton: true &#125; &#125;, use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'less-loader' &#125; ] &#125;) &#125;, &#123; test: /\.(jpe?g|png|gif|svg)$/, use: [ /*&#123; // file-loader 把图片打包 loader: 'file-loader', options: &#123; name: '[name].img.[hash:5].[ext]', outputPath: 'assets', publicPath: 'assets' &#125; &#125;*/ &#123; //可以将图片转换为bash64编码格式，厉害了，而且配置项和file-loader一样 loader: 'url-loader', options: &#123; limit: 10000, name: '[name].img.[hash:5].[ext]', outputPath: 'assets', publicPath: 'assets' &#125; &#125;, &#123; loader: "img-loader", options: &#123; plugins: [ require("imagemin-mozjpeg")(&#123; quality: 30 // the quality of zip &#125;) ] &#125; &#125; ] &#125; ] &#125;, plugins: [ new ExtractTextWebpackPlugin(&#123; filename: '[name].min.css' &#125;) ]&#125; 需要另外安装1npm i imagemin-webp imagemin-svgo imagemin-mozjpeg imagemin-pngquant imagemin-optipng imagemin-gifsicle imagemin cwebp-bin 其中webp打包的时候报过一个错12ERROR in ./src/css/base.lessModule build failed: ModuleBuildError: Module build failed: Error: spawn /mnt/f/webpack/4-1/node_modules/cwebp-bin/vendor/cwebp ENOENT 安装cwebp-bin解决1npm i cwebp-bin 使用images-webapack-loader 12345678910111213141516171819202122&#123; loader: "image-webpack-loader", options: &#123; mozjpeg: &#123; quality: 30 &#125;, // optipng.enabled: false will disable optipng optipng: &#123; enabled: false, &#125;, pngquant: &#123; quality: '65-90', speed: 4 &#125;, gifsicle: &#123; interlaced: false, &#125;, webp: &#123; // 转换为webp格式文件 quality: 60 &#125; &#125;&#125; 没搞懂webp是干什么的好像webp没什么用啊，头疼 2019年3月8日02:15:55 说一下搭建webpack 4 中使用image-webpack-loader遇到的坑：安装这个插件的时候我退出了一下导致很多类似于上面的*-bin文件没有安装，而且卸载这个插件重新安装也不会装这些东西，不知道是什么坑,解决办法就是去别的目录重新执行此命令看少装了什么，重新npm i 安装即可 imagemin-pngquant 压缩png图片嗯，bug出现的问题是npm安装的时候我退出了，要安装个什么pngquant-bin,前面那个webp-bin也是我自己退出了，毕竟以前没遇到过这种问题1npm i pngquant-bin 还有就是压缩图片还要用上file-loader,url-loader postcss-sprites 雪碧图这个是postcss的一个雪碧图插件1234567891011&#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: [ require('postcss-sprites')(), //雪碧图 //Atuoprefixer 帮助你写各个浏览器之间的前缀 require('postcss-cssnext')() //使用最新的css语法，这个里面包含了autoprefixer ] &#125;&#125; 本节代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192var path = require('path')var ExtractTextWebpackPlugin = require('extract-text-webpack-plugin')var imagemin = require('imagemin');module.exports = &#123; entry: &#123; app: './src/app.js' &#125;, output: &#123; path: path.resolve(__dirname, 'dist'), publicPath: './dist/', filename: '[name].bundle.js' &#125;, module: &#123; rules: [ &#123; test: /\.less$/, use: ExtractTextWebpackPlugin.extract(&#123; fallback: &#123; loader: 'style-loader', options: &#123; singleton: true &#125; &#125;, use: [ &#123; loader: 'css-loader' &#125;, &#123; loader: 'postcss-loader', options: &#123; ident: 'postcss', plugins: [ require('postcss-sprites')(), // require('postcss-sprites')(), require('postcss-cssnext')() ] &#125; &#125;, &#123; loader: 'less-loader' &#125; ] &#125;) &#125;, &#123; test: /\.(gif|png|jpe?g|svg)$/i, use: [ /*&#123; // file-loader 把图片打包 loader: 'file-loader', options: &#123; name: '[name].img.[hash:5].[ext]', outputPath: 'assets', publicPath: 'assets' &#125; &#125;*/ &#123; //可以将图片转换为bash64编码格式，厉害了，而且配置项和file-loader一样 loader: 'url-loader', options: &#123; limit: 100, name: '[name].img.[hash:5].[ext]', outputPath: 'assets', publicPath: 'assets' &#125; &#125;, &#123; loader: "img-loader", options: &#123; /*plugins: [ // require("imagemin-mozjpeg")(&#123; //压缩jpg // quality: 60 // the quality of zip // &#125;), // require("imagemin-webp")(&#123; //压缩为webp // quality: 80 // the quality of zip // &#125;) ]*/ plugins: [ require("imagemin-pngquant")(&#123; quality: [0.6, 0.7] &#125;) ] &#125; &#125; ] &#125; ] &#125;, plugins: [ new ExtractTextWebpackPlugin(&#123; filename: '[name].min.css' &#125;) ]&#125; 字体文件file-loader 这个或 url-loader 都可以很简单，新加配置项这个就是这部分添加的，完整文件参考上面1234567891011121314&#123; test: /\.(eot|svg|ttf|woff?)$/, use: [ &#123; loader: 'url-loader', options: &#123; limit: 1000, name: '[name].font.[hash:6].[ext]', outputPath: 'assets', publicPath: 'assets' &#125; &#125; ]&#125; 第三方库webpack.providePluginimports-loaderwindow全局注入npm模块12345plugins: &#123; new webpack.ProvidePlugin(&#123; $: &apos;jquery&apos; //这里的模块就可以全局注入， &#125;)&#125; 如果npm没有安装这个模块，但是本地有，就可以这样12345678910module: &#123; rules: [ resolve: &#123; alias: &#123; jquery$: path.resolve(__dirname, &apos;src/jquery.min.js&apos;) //这个$不知道干啥的 &#125; &#125; ]&#125; webpack 处理 html文件自动生成HTML , 场景优化HtmlWebpackPlugin 插件简介 options template 这个项目的模板文件所在位置，我们的html就在根目录 filename 指定输出目录，目录，文件名，都可以 minify 是否压缩生成html文件 chunks 指定entry的chunk，不然的话多页面应用就会把所有的加进来 inject 这个默认是true，改为false就是手动插入 安装 HtmlWebpackPlugin1npm install html-webpack-plugin --save-dev webpack.config.json 文件写入12345678910111213var HtmlWebpackPlugin = require('html-webpack-plugin') //头部引入plugins: [ new HtmlWebpackPlugin(&#123; filename: 'index.html', //目录，文件名，都可以 template: './index.html', //这个项目的模板文件所在位置，我们的html就在根目录 //inject: false ,//这个默认是true，改为false就是手动插入 chunks: ['app'], //指定entry的chunk，不然的话多页面应用就会把所有的加进来 minify: &#123; //借助了第三方实现html-minify collapseWhitespace: true //去除空格 &#125; &#125;)] //顺便还要去除，output中的路径，因为index文件到同级目录了，所以就不用增加这段代码了 123output: &#123; ~~publicPath: './dist/',~~&#125;, HTML中引入的图片 html-loader options 选项 attrs: [img: src] img表示html标签，右边表示属性 安装html-loader1npm install html-loader index.html：1&lt;img src="" data-src=""&gt; webpack.config.json:123456789101112131415module: &#123; rules: [ &#123; test: /\.html$/, use: [ &#123; loader: 'html-loader', options: &#123; attrs: ['img:src', 'img:data-src']//默认是img:src,如果有其他需求可以增加 &#125; &#125; ] &#125; ]&#125; 更改，删除的地方webpack.config.js1234output: &#123; publicPath: '/' //修改为根路径&#125;//其他的publicPath全部删除即可，这一个就ok了，以前因为没有打包index.html所以才很麻烦 即使没有html-loader,还可以用require的方式引入图片1&lt;img src='$&#123;require("./src/assets/imgs/2.jpg)"&#125;' alt="图片2"&gt; 配合优化(提前载入webpack加载代码，减少http请求)inline-manifest-webpack-plugin 把webpack生成的代码插入页面，和html-loader配合的时候会有bug，所以就学习第二种 html-webpack-inline-chunk-plugin 通过这个插件可以选择各种各样的chunk，然后插入到页面中 1npm install html-webpack-inline-chunk-plugin --save-dev 1npm install babel-loader @babel/core @babel/preset-env --dev webpack.config.js123456789101112131415module: &#123; rules: [ &#123; //位置是最顶部，不知道放到后面会有影响不 test: /\.js$/, use: [ &#123; loader: 'babel-loader', options: &#123; presets: ['@babel/preset-env'], &#125; &#125; ] &#125; ]&#125; 1234567891011var HtmlWebpackPlugin = require('html-webpack-plugin')var HtmlInlinkChunkPlugin = require('html-webpack-inline-chunk-plugin')plugins: [ new webpack.optimize.CommonsChunkPlugin(&#123; name: 'manifest' &#125;), new HtmlInlinkChunkPlugin(&#123; inlineChunks: ['manifest'] &#125;), ] 5-1 搭建开发环境 webpack watch mode12webpack -watchwebpack -w 安装一个自动清除目录的工具1npm install clean-webpack-plugin webpack.config.js12345var CleanWebpackPlugin = require('clean-webpack-plugin')plugins: [ new CleanWebpackPlugin(['dist']) //这里是要清除的目录] 使用webpack -w1webpack -w --progress --display-reasons --color progress 运行的过程 webpack-dev-server官方提供的开发服务器 live reloading 项目变化帮你刷新浏览器 打包文件？NO 是在运行的内存中，所以还是需要自己打包 路径重定向 没有理解 https 支持 浏览器中显示编译错误，很有用 接口代理 模块热更新 不刷新浏览器的情况下，更新代码，这个厉害了 配置 devServer inline contentBase port historyApiFallback https proxy hot 模块热更新，还要写额外代码 openpage 指定最先打开的页面 lazy 启动的时候不会打包任何东西，只有访问的时候才会打包 overlay 遮罩，错误提示 开始使用 安装webpack-dev-server1npm install webpack-dev-server@2 //3以上需要webpack@4支持，所以这里要降级 webpack.config.js12345module.exports = &#123; devServer: &#123; port : 9001 //指定端口 &#125;&#125; package.json123"scripts" : &#123; "start:dev": "webpack-dev-server --open"&#125; 命令行执行1npm run start:dev 不配置package.json，可以这样1./node_modules/.bin/webpack-dev-server 原来package.json script里面找模块是从node_modules中查找的，这是npm的查找规则决定的 1234567module.exports = &#123; devServer: &#123; // inline: false, //目前用不到 // historyApiFallback: true, //嗯，目前用不到，用到再说 port: 9001 &#125;,&#125; Proxy 代理远程接口请求自己集成了http-proxy-middleware options target 指定代理地址 changeOrigin 改变源，到你的url headers 增加http请求头， logLevel 帮助调试，显示代理情况 pathRewrite 帮助重定向 使用webpack.config.js123456789101112131415module.exports = &#123; devServer: &#123; proxy: &#123; '/comments' : &#123; //匹配地址，凡是遇到/comments的都会被转为下面的路径 target: 'https://m.weibo.com', changeOrigin: true &#125; &#125; &#125;, plugins: [ new webpack.ProvidePlugin(&#123; $: 'jquery' //这里的模块就可以全局注入 &#125;) ]&#125; app.js123456789101112$.get('/comments/hotflow', &#123; //微博评论接口，这里$.get自然是jquery了 id : 4331316696337556, mid : 4331316696337556, max_id_type : 0&#125;, function(data) &#123; console.log(data.data.data) //到这里就可以结束了，下面的只是插入页面 var msg = data.data.data for (var i = 0 ; i &lt; msg.length; i++) &#123; console.log(msg[i].text) $('.pl').append("&lt;div&gt;" + msg[i].text + "&lt;div/&gt;") &#125;&#125;) 其他配置项headers app.js12345$.get('/msg/index', &#123; format: 'cards'&#125;, function (data) &#123; console.log(data)&#125;) 以上写法，微博会有验证，无法通过，可以用proxy发送头信息12345678910111213module.exports = &#123; devServer: &#123; proxy: &#123; '/' : &#123; //匹配地址，凡是遇到/comments的都会被转为下面的路径 target: 'https://m.weibo.com', changeOrigin: true , headers: &#123; //发送头信息，这里的cookie是微博的验证 'Cookie': 'ALF=1550807798; SCF=Ajv5Mdqcv9zNmq8TEe8b9Jd5bIERX_ZZAEkFyb_x_x5DdNtQFxGLsekcUUeJ5LOavTb_ruqz1FbarpstC8U9w8o.; SUB=_2A25xQ4KVDeRhGeVJ41IW8i7Kwj-IHXVSzy7drDV6PUJbktAKLU7lkW1NT8d4sQ6RoEu17F8RbjIXYg74GYrrPENl; SUBP=0033WrSXqPxfM725Ws9jqgMF55529P9D9WFe-YDR22UIh60JG0EfcL8h5JpX5K-hUgL.FoeN1h5Neo5c1Ke2dJLoIEYLxKnL1heLB.BLxKMLB-eL1K2LxK-LBo5LBo8bUCH81FHWSb-ReCH8SC-4eEHWx5tt; SUHB=0LcilU3V_eaMdU; SSOLoginState=1548219077; MLOGIN=1; _T_WM=60e134ae82c5c5d1a5652f6a212d78f0; WEIBOCN_FROM=1110003030; XSRF-TOKEN=4d3335; M_WEIBOCN_PARAMS=luicode%3D10000011%26lfid%3D100505102803%26uicode%3D10000011%26fid%3D102803' &#125; &#125; &#125; &#125;&#125; pathRewrite1234567891011121314module.exports = &#123; devServer: &#123; proxy: &#123; '/' : &#123; //直接匹配/ target: 'https://m.weibo.com', changeOrigin: true , pathRewrite: &#123; '^/comments' : '/api/comments' //把/comments的地址都替换，不过我的这个案例没用使用，和前面app.js例子会出问题 &#125; &#125; &#125; &#125;,&#125; Module Hot Reloading模块热更新保持应用的数据状态节省调试时间样式调试更快 devServer,已经集成，直接使用123devServer: &#123; hot: true&#125; 除此之外还要使用webpack.HotModuleReplacementPlugin想清晰看到模块的相对路径可以使用webpack.NamedModulesPlugin 1234plugins: [ new webpack.HotModuleReplacementPlugin() new webpack.NamedModulesPlugin()] 如果js需要热加载，就要自己去写规则，vue，angular这种框架的loader都写好了，自己写页面感觉没必要 module.hot module.hot.accept module.hot.decline app.js123if (module.hot) &#123; //简单的用法，引入其他模块还要增加代码 module.hot.accept()&#125; express+webpack-dev-middlewareSource Map调试主要就是帮你定位代码的位置，比如打包后就变成一行，启用Devtool就可以定位到要调试代码的位置插件(更加灵活):12webpack.SouceMapDevToolPluginwebpack.EvalSourceMapDevToolPlugin DevtoolDevelopment(开发环境使用) options eval eval-source-map cheap-eval-source-map cheap-module-eval-source-map Production(生产环境下) options source-map hidden-source-map nosource-source-map 每个选项的生成时间都不同 css使用source-map注意除了开启source-map之外，每个css-loader都要启用options.sourceMap = true 使用source-mapwebpack.config.js12345module.exports = &#123; //devtool: 'eval', 这个速度最快但是看到的文件不够清晰，会带有webpack自己的代码 //devtool: 'source-map', //这个虽然耗时，不过还行 devtool: 'cheap-module-source-map' //感觉这个和source-map区别不大，估计还没遇到问题把&#125; 如果开启最小化代码new webpack.optimize.UglifyJsPlugin()就会出现问题，课程是暂时注释 css用到的loader都要开启sourceMap123456&#123; loader: 'css-loader', options: &#123; sourceMap: true &#125;&#125; 有个style-loader的bug，就是开启singleton: true 开启sourceMap还是不行，新版style-loader已经修复，我没有这个问题 Eslint 检查代码格式所需要的插件1234eslinteslint-loadereslint-plugin-html 处理html里面的scripteslint-friendly-formatter 友好的看到输出错误 配置webpack config.eslintrc.*package.json 中的 eslintConfig使用那种方式验证eslintJavaScript Standard Style需要的插件12345eslint-config-standardeslint-plugin-promiseeslint-plugin-standardeslint-plugin-importeslint-plugin-node 如果不使用这个插件可以去github搜eslint-config-xxx eslint-loader使用注意 options.failOnWarning 设为true，如果有错误就不会通过编译 options.failOnError 定义验证错误不会通过编译 options.formatter options.outputReport devServer.overlay 开启后就可以在浏览器中看到错误 开始使用安装需要的模块1npm install eslint eslint-loader eslint-plugin-html eslint-friendly-formatter --save-dev 增加配置代码webpack.config.js1234567891011121314151617181920212223module: &#123; rules: [ &#123; test: /\.js$/, use: [ &#123; loader: 'babel-loader', //include: [path.resolve(__dirname, 'src')], //exclude: [path.resolve(__dirname, 'src/lib')] options: &#123; presets: ['@babel/preset-env'] &#125; &#125;, &#123; //必须添加到babel-loader之后 loader: 'eslint-loader', options: &#123; formatter: require('eslint-friendly-formatter') &#125; &#125; ], &#125; ]&#125; .eslintrc.js12345678910111213141516module.exports = &#123; root: true, //表面自己是根目录 extends: 'standard', //使用standard的标准 plugins: [], env: &#123; //环境 browser: true, //浏览器环境 node: true //node环境 &#125;, globals: &#123; $: true &#125;, rules: &#123; //可以覆盖standard的标准，自定义自己的规则 //indent: ['error', 4] //将缩进自定义为4个空格 //'eol-last': ['error', 'never'] //结尾需要换行取消 &#125;&#125; 安装standard所需模块1npm install eslint-config-standard eslint-plugin-promise eslint-plugin-node eslint-plugin-import eslint-plugin-standard --save-dev 个人觉得这个显示到html页面上的错误有点难看，不知道vue-cli使用的是什么 开发环境和生产环境需求分析：开发环境模块热更新sourceMap接口代理代码规范检查生产环境提取公用代码压缩混淆文件压缩或Base64 编码去除无用的代码 共同点同样的入口同样的代码处理(loader处理) 所有loader同样的解析配置 开发和打包的一致性 如何区分呢就是webpack-merge webpack.dev.conf.js //开发环境webpack.prod.conf.js //生产环境webpack.common.conf.js //共同点]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ss]]></title>
    <url>%2Fblog%2F2018%2F12%2F22%2Fss%2F</url>
    <content type="text"><![CDATA[bbr+kcptun+ss 搭建（ubuntu14）kcptun 待验证 1. bbr 开启可以有效提高网速sudo apt-get update //更新源sudo apt-get upgrade //升级系统 2. 开启bbr 下载内核 wget http://kernel.ubuntu.com/~kernel-ppa/mainline/v4.14.12/linux-image-4.14.12-041412-generic_4.14.12-041412.201801051649_amd64.deb 内核安装-dpkg -i linux-image-4.*.deb 查看内核版本dpkg -l | grep linux-image 删除旧内核,除4.*版本外全部删除即可 apt-get purge 旧内核 更新grub系统引导文件并重启 update-grub 重启服务器 reboot 3. 开机后开启bbr 查看内核 ≥ 4.9 uname -r 执行 echo &quot;net.core.default_qdisc=fq&quot; &gt;&gt; /etc/sysctl.conf echo &quot;net.ipv4.tcp_congestion_control=bbr&quot; &gt;&gt; /etc/sysctl.conf 保存生效 sysctl -p 执行 sysctl net.ipv4.tcp_available_congestion_control sysctl net.ipv4.tcp_congestion_control 如果结果都有bbr，证明内核已开启bbr 执行 lsmod | grep bbr 看到 tcp_bbr 模块即说明 bbr 已启动 还可以继续安装kcptun，不过上面的足以日常使用，不喜欢折腾的就不用搞 4. 搭建ss 安装 apt install python3-pip pip3 install setuptools pip3 install distribute pip3 install shadowsocks 添加ss配置文件 vi /etc/shadowsocks.json12345678&#123;&quot;server&quot;:&quot;替换为你服务器ip地址&quot;, &quot;server_port&quot;:端口,&quot;local_port&quot;:1080,&quot;password&quot;:&quot;密码&quot;,&quot;timeout&quot;:600,&quot;method&quot;:&quot;aes-256-cfb&quot;&#125; 将里面的内容为中文的部分替换为相应的值 开启ss服务 ssserver -c /etc/shadowsocks.json -d start 到这里就可以结束了，后续的我自己没搞定，参考 5. kcptun配置 安装kcptun mkdir kcptun cd kcptun wget https://github.com/xtaci/kcptun/releases/download/v20170904/kcptun-linux-amd64-20170904.tar.gz tar zxvf kcptun-linux-amd64-20170904.tar.gz rm -f kcptun-linux-amd64-20170904.tar.gz 6. 开启 kcptun 服务 ./server_linux_amd64 -t &quot;服务器ip:shadowsocks设置的端口&quot; -l &quot;:4001&quot; --key 密码 --log 4001.log &amp; &amp; 表示后台运行 7. 本地配置 下载相对应的客户端文件。（如上面server安装的是v20170904的kcptun，client就下载对应版本的） 下载地址 新建文件client.json 123456789101112131415161718192021&#123;&quot;localaddr&quot;: &quot;:1082&quot;, //避免与本机占用的端口冲突即可&quot;remoteaddr&quot;: &quot;your server ip : kcptun 端口号&quot;, //对于上述配置是 x.x.x.x:4001&quot;key&quot;: &quot;kcptun密码&quot;, //server上kcptun设置的密码&quot;crypt&quot;: &quot;aes&quot;,&quot;mode&quot;: &quot;fast2&quot;,&quot;conn&quot;: 1,&quot;mtu&quot;: 1350,&quot;sndwnd&quot;: 512,&quot;rcvwnd&quot;: 512,&quot;nocomp&quot;: false&#125; 新建start.bat内容如下 client_windows_amd64.exe -c client.json 将kcptun的文件client_windows_amd64.exe和新建的文件放到同一目录之下 之前使用的方法这种是一键安装1wget xiaofd.github.io/ruisu.sh &amp;&amp; bash ruisu.sh 更换内核： 查看内核 uname -r 安装新内核 sudo apt-get install linux-image-extra-3.13.0-24-generic 卸载其他内核 查看系统现有内核 dpkg -l|grep linux-image 卸载列出的其他内核 sudo apt-get purge linux-image-3.16.0-36-generic linux-image-extra-3.16.0-36-generic 更新grub系统引导文件并重启 sudo update-grub sudo reboot 速锐操作命令123456789service serverSpeeder start #启动service serverSpeeder stop #停止service serverSpeeder reload #重新加载配置service serverSpeeder restart #重启service serverSpeeder status #状态service serverSpeeder stats #统计service serverSpeeder renewLic #更新许可文件service serverSpeeder update #更新chattr -i /serverspeeder/etc/apx* &amp;&amp; /serverspeeder/bin/serverSpeeder.sh uninstall -f #卸载 shadowsocks启动1234567sudo ssserver -c /etc/shadowsocks.json -d start后台运行：ssserver -c /etc/shadowsocks.json -d start后台停止：ssserver -c /etc/shadowsocks.json -d stop前台运行：ssserver -c /etc/shadowsocks/config.json 问题ubuntu 16出现的问题 Command “python setup.py egg_info” failed with error code 问题12pip install setuptoolspip install distribute 我用这条命令之前还用了很多命令1234567apt-get remove python*apt-get install python python-pip// 如果pip用不了，则可以这样用python -m pip install 软件名// 或python -m pip install --upgrade --force pip // 这条命令好像式升级来着 pip升级后Import Error:cannot import name main解决方案方法11vi /usr/bin/pip3 将原来的from pip import main 改为 from pip._internal import main]]></content>
      <categories>
        <category>ss</category>
      </categories>
      <tags>
        <tag>ubuntu</tag>
        <tag>ss</tag>
        <tag>速锐</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vuesenior]]></title>
    <url>%2Fblog%2F2018%2F12%2F13%2Fvuesenior%2F</url>
    <content type="text"><![CDATA[vue全家桶+SSR+Koa2全栈开发美团网项目地址：vue全家桶+SSR+Koa2全栈开发美团网 安装vue-clivue脚手架创建项目环境123npm install -g @vue/clivue -Vvue create 项目名称 查看项目remote12git remote -vgit remote remove &lt;name&gt; git 本地创建目录命令12345678910线上创建项目mkdir 项目名称cd 项目名称git init vi README.mdgit add README.mdgit commit -m "上传简介"git remote add origin git@github.com:DemoorBug/vuesenior.gitgit push -u origin master -u代表了关联本地分支和线上分支的master分支，以后就可以直接git push了 Koa2学习首先要装一个脚手架，我以前学node的时候老师用的express，今年这个koa2最火koa-generator安装1npm install -g koa-generator 创建项目123koa2 project 默认是用这个引擎安装的想用e js引擎koa2 -e project 运行项目123cd projectnpm installnpm run dev async和await语法这就是prmis，的一个写法，很简单 koa2中间件中间件一直是我没搞懂的 koa2_api 大致理解就是一个环，先进来，在出去都可以执行到我，比如执行顺序是这样的:m1m2m3出去的执行顺序是这样的:m3m2m1 所以谁前谁后执行无所谓，出去的时候还会自我检查，我的优先级会被提高 中间件代码 1234567891011function pv (ctx) &#123; global.console.log('pv')&#125;module.exports = function() &#123; return async function(ctx, next) &#123; pv(ctx) await next() global.console.log('pv end') &#125;&#125; koa路由cookiesctx.cookies.set(‘pvd’, Math.random())ctx.cookies.get(‘pvd’) mongoose123which 搜索命令的命令。搜索命令所在路径及别名which mongod mongoose中文文档 研究了一下windows下的mongodb启动，这里总结一下键入的命令1mongod --dbpath "f:\mo\data" --logpath "f:\mo\log\db.log" --install --serviceName "mongodb" --logappend --directoryperdb 这里面的启动名字是mongodb1net start mongodb 我看有些人的教程直接是12.\mongod --dbpath="E:\MongoDB\data"net start MongoDB 但是我不可以这样写,会报错，这里的MongoDB，是默认名字吗？有待证实 搞明白了，MongoDB是默认名字，net start 也是windows独有的 关闭服务123mongouse admindb.shutdownServer() 发送post请求1curl -d "name=haimeimei&amp;age=27" http://localhost:3000/users/addPerson -d post请求 读数据123const result = await Person.findOne(&#123; name: ctx.request.body.name &#125;) 写数据要创建实例1234new Person(&#123; name: ctx.request.body.name, age: ctx.request.body.age&#125;) 更新数据12345const result = await Person.where(&#123; name: ctx.request.body.name &#125;).update(&#123; age: ctx.request.bdoy.age &#125;) 删除数据123const result = await Person.where(&#123; name: ctx.request.body.name &#125;).remove() Redis安装教程服务端用session来保持用户状态，浏览器用cookie保存session，服务器把session种植到cookie中然后下次访问的时候cookie就会带着session过来，进而达到身份认证的过程 安装中间件1npm i koa-generic-session koa-redis 操作Redis方法1234redis-clikeys *get key Redis可以直接存储数据，不用配合session也行12345678910const Redis = require('koa-redis')const Store = new Redis().clientrouter.get('/fix',async function(ctx) &#123; const st = await Store.hset('fix', 'name', Math.random()) ctx.body = &#123; code: 0 &#125;&#125;) Redis 查看12keys *hget fix name Nuxt.js 是做vue ssr的一个框架 是基于vue2这个框架做的 包含了vue Router vue本身不带路由，是通过插件的方式支持，Nuxt.js整合了这些 Nuxt.js将Router的配置设置的很简单，甚至你可以不配置就可以用 可以支持vuex vuex是一个跨组件的管理工具 支持Vue Server Renderer ssr,整合 支持vue-meta html meta管理 Nuxt生命周期 Incoming Request l浏览器发出请求 检查有没有 nuxtServerInit 如果有的话就执行这个函数store action middleware 中间件是跟路由相关，可以实现你想要的功能，都可以在这里完成 validate() 配合高级动态路由去做一些验证，比如说是不是允许跳到这个页面来，如果没有得到我的校验，就跳走之类的， asyncData() &amp; fetch() 获取数据 asyncData() 是用来获取渲染vue组件的 fetch() 通常是用来修改vuex的 Render 最后一步就是渲染 Navigate 如果要是有这个的话，会发起一个非(色沃)的路由他会重新循环3-6的内容，如果发起的是一个新的路由，这个时候就从第一部开始循环1-6 Nuxt.js安装Nuxt.js安装1vue init nuxt-community/koa-template . 今天研究了半天的bug，这玩意安装不成功呀1npm install jquery@latest 更新到最新版本 Nuxt.js官方安装，以前不支持koa，现在官方就可以自己支持Nuxt官网 1npx create-nuxt-app 安装的时候会有选项，可以选koa，不过这个koa是不支持import写法 创建即配置，异步获取创建及配置vue里面是用mounted()方法发出ajax请求，但是这个不会在服务器端执行，只在浏览器端执行，而asyncData()可以在服务端渲染，这样得到的数据更利于seo Nuxtjs里面使用模板是要用到layout1234export default &#123; layout: &apos;search&apos;, data () &#123;&#125;&#125; SSR的作用，就是页面闪动的时候，ssr就可以做到 环境准备与项目安装 6-2 6-1略过用babel编译文件，这样就可以用import写法了123456789package.json 的dev后面增加babel编译--exec babel-node.babelrc 增加babel配置文件&#123; "presets": ["es2015"]&#125;npm install babel-preset-es2015 支持sass编译1npm i sass-loader node-sass --save-dev 我也是醉了，安装sass后，lang=&quot;scss&quot; 写成这样的，差点被坑了 nuxt.config.jsbuild,添加这个，增加缓存，不知道什么鬼1cache: ture 这个东西在我的代码里，会导致element-ui 字体文件请求不到，会报错暂时只能将这个代码去除了 首页开发真正做业务的时候要先想再做需求分析： 模板设计 复用 组件设计 如何拆分组件 数据结构设计 接口设计 今天遇到了一个bug，就是@import引入css文件报错，最后就是我也不知道为什么引入header.scss这个文件就会报错，测试了一下午，原因就是写新代码没有创建新分支，所以导致了这种问题，不然直接切换分支，好像也不行，好像又可以，以后先要创建分支再写代码了，bug所在位置，components/public/header/topBar.vue: @import “@/assets/css/public/header.sass”;我再去测试一下是文件内容错误还是命名错误还是误认为是文件夹了，因为里面有个header文件夹 mdzz，后缀也是scss，而且header.scss内容也有问题，我TM也是醉了，搞我呢，一下午白忙 开发搜索模块搜索这个模块，原理特简单判断是否获取焦点，是否有内容即可完成搜索框return 是否焦点 &amp;&amp; 是否有内容 //常规搜索return 是否焦点 &amp;&amp; !是否有内容 //热门搜索还有要注意的是，没有焦点后搜索框就会瞬间消失，a链接就点不上了，所以要给个延迟数据：12345678910111213data () &#123; return &#123; isFocus: false, search: '', hotPlace: ['热门搜索', 'nice'], searchDate: ['哈哈2哈哈1', '也没2有那么1', '搜索2吗1', '北京1烤鸭', '偶是1'], searchList: [], show: true, number: 0, what: false, hidone: false &#125;&#125; 搜索框热门搜索出现逻辑代码:1234567891011121314151617computed: &#123; isHotPlace () &#123; return this.isFocus &amp;&amp; !this.search &#125;, isSearchList () &#123; return this.isFocus &amp;&amp; this.search &#125;&#125;,methods: &#123; focus () &#123; this.isFocus = true &#125;, blur () &#123; setTimeout(() =&gt; &#123; this.isFocus = false &#125;,200) &#125;, 搜索框代码：1234567891011121314151617181920212223watch: &#123; search () &#123; if (!this.search) &#123; this.searchList = [] return &#125; if (this.what) &#123; return &#125; const result = [] this.searchDate.forEach((value, index) =&gt; &#123; if (value.indexOf(this.search) &gt; -1) &#123; result.push(value) &#125; &#125;) /*和这层代码没关系*/ for (let i = 0; i &lt; this.searchList.length; i++) &#123; this.$refs[i][0].className = '' &#125; this.number = 0 /*-------------*/ this.searchList = result &#125; 搜索框的down 和 up事件操控逻辑写了很多冗余代码12345678910111213141516171819202122232425262728293031323334353637383940numberSerace () &#123; // 点击键盘down执行事件，写的很乱，不过功能还可以 if (!this.search) return this.what = true this.hidone = true if (this.number &gt;= this.searchList.length) &#123; this.number = 0 &#125; for (let i = 0; i &lt; this.searchList.length; i++) &#123; this.$refs[i][0].className = '' &#125; this.$refs[this.number][0].className = "msg" this.search = this.searchList[this.number] setTimeout(() =&gt; &#123; this.what = false &#125;, 200) this.number++ &#125;, upSerace () &#123; //点击键盘up执行事件 if (!this.search) return this.what = true if (this.hidone) &#123; this.number-- &#125; this.hidone = false this.number-- if (this.number &lt; 0) &#123; this.number = this.searchList.length-1 &#125; for (let i = 0; i &lt; this.searchList.length; i++) &#123; this.$refs[i][0].className = '' &#125; this.$refs[this.number][0].className = "msg" this.search = this.searchList[this.number] setTimeout(() =&gt; &#123; this.what = false &#125;, 200) 搜索框全代码地址：github地址 7-8左侧边栏实现原理首先是结构布局123456789101112&lt;div&gt; &lt;dl&gt; &lt;dt&gt;全部分类&lt;/dt&gt; &lt;dd&gt;&lt;i&gt;图标标签i&lt;/i&gt;美食&lt;span&gt;&gt;箭头标签&lt;/span&gt;&lt;/dd&gt; &lt;/dl&gt; &lt;div&gt; 这个div就是用来存放弹出内容的，是实时渲染，就是获得数据然后渲染，方便到爆 &lt;template&gt; 这个标签控制循环，不然外面就要套一层，冗余 &lt;h4&gt;&lt;/h4&gt; &lt;span&gt;&lt;/span&gt; &lt;/template&gt; &lt;/div&gt;&lt;/div&gt; 方法部分的实现原理分析： this.menu.filter((item) =&gt; item.type==this.kind)[0].child 比对this.kind来获取想应数据，filter是什么？ this.kind = e.target.querySelector(‘i’).className 获取当前鼠标对应的元素，赋值给this.kind1234 this._timer = setTimeout(() =&gt; &#123; this.kind= '' &#125;, 150)这块代码延迟，可以在鼠标进入右侧边栏的时候有个反应时间，来让右侧响应标签取消这个定时器，从而达到可以防止鼠标到弹出框，弹出框就消失的问题 本节源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;template&gt; &lt;div class="m-menu"&gt; &lt;dl class="nav" @mouseleave="mouseleave"&gt; &lt;dt&gt;全部分类&lt;/dt&gt; &lt;dd v-for="(item, index) of menu" :key="index" @mouseenter="enter"&gt; &lt;i :class="item.type"/&gt;&#123;&#123; item.name &#125;&#125;&lt;span class="arrow"/&gt; &lt;/dd&gt; &lt;/dl&gt; &lt;div v-if="kind" class="detail" @mouseleave="Eenter" @mouseenter="Emousele"&gt; &lt;template v-for="(item, index) of curdetail"&gt; &lt;h4 :key="index"&gt;&#123;&#123; item.title &#125;&#125;&lt;/h4&gt; &lt;span v-for="v of item.child" :key="v"&gt;&#123;&#123; v &#125;&#125;&lt;/span&gt; &lt;/template&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; kind: '', menu: [&#123; type: 'food', name: '美食', child: [&#123; title: '美食', child: ['代金券','饮品','火锅','自助餐'] &#125;] &#125;, &#123; type: 'takeout', name: '外卖', child: [&#123; title: '外卖', child: ['美团','饿了么','百度外卖','自助餐'] &#125;] &#125;] &#125; &#125;, computed: &#123; curdetail () &#123; return this.menu.filter((item) =&gt; item.type==this.kind)[0].child &#125; &#125;, methods: &#123; mouseleave () &#123; this._timer = setTimeout(() =&gt; &#123; this.kind= '' &#125;, 150) &#125;, enter (e) &#123; console.log(e.target) this.kind = e.target.querySelector('i').className &#125;, Emousele () &#123; clearTimeout(this._timer) &#125;, Eenter () &#123; this.kind = '' &#125; &#125;&#125;&lt;/script&gt; 自己写的另一个列表源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;template&gt; &lt;section class="m-istyle"&gt; &lt;dl @mouseover="moue"&gt; &lt;dt&gt;有格调&lt;/dt&gt; &lt;dd :class="&#123;active:kind==='all'&#125;" kind="all" keyword="景点"&gt;全部&lt;/dd&gt; &lt;dd :class="&#123;active:kind==='part'&#125;" kind="part" keyword="美食"&gt;约会聚餐&lt;/dd&gt; &lt;dd :class="&#123;active:kind==='spa'&#125;" kind="spa" keyword="丽人"&gt;丽人SPA&lt;/dd&gt; &lt;dd :class="&#123;active:kind==='movie'&#125;" kind="movie" keyword="电影"&gt;电影演出&lt;/dd&gt; &lt;dd :class="&#123;active:kind==='travel'&#125;" kind="travel" keyword="旅游"&gt;品质出游&lt;/dd&gt; &lt;/dl&gt; &lt;ul class="ibody"&gt; &lt;li v-for="(item, index) of curdetail" :key="index" style="height: auto"&gt; &lt;el-card&gt; &lt;img :src="item.img"&gt; &lt;ul class="cbody"&gt; &lt;li class="title"&gt;&#123;&#123; item.title &#125;&#125;&lt;/li&gt; &lt;li class="pos"&gt; &lt;span v-for="(item, index) of item.pos" :key="index"&gt;&#123;&#123; item &#125;&#125;&lt;/span&gt; &lt;/li&gt; &lt;li class="price"&gt;￥&lt;em&gt;&#123;&#123; item.price &#125;&#125;&lt;/em&gt;&lt;span&gt;/起&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/el-card&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/section&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data () &#123; return &#123; kind: 'all', artistic: [&#123; type: 'all', child: [&#123; title: '木北造型（崇文门新世界店）', img: '//p1.meituan.net/wedding/8d26f93de654d433b17774e60a1fc5bd1028431.jpg@240w_180h_1e_1c_1l|watermark=1&amp;&amp;r=2&amp;p=9&amp;x=2&amp;y=2&amp;relative=1&amp;o=20|368w_208h_1e_1c', pos: ['亲子场景酒店','发票推荐','亲子酒店点评'], price: '685' &#125;, &#123; title: '北京新侨诺富特饭店', img: '//p1.meituan.net/dnaimgdark/42487acaeaa40e3a97b41443f75566142443096.jpg@368w_208h_1e_1c', pos: ['亲子场景酒店','亲子酒店','房量充足'], price: '536' &#125;] &#125;, &#123; type: 'part', child: [&#123; title: '分米鸡 DM Chicken（合景·摩方店）', img: '//p1.meituan.net/msmerchant/a361a5683dcfc8db85d61f15639f9bfd61437.jpg@368w_208h_1e_1c', pos: ['分米鸡10DM套餐1份，有赠品'], price: '308' &#125;, &#123; title: 'COSTA COFFEE（东方新天地店）', img: '//p0.meituan.net/merchantpic/b5bc200ff96056aa58e2441c37b0097d58192.jpg@368w_208h_1e_1c', pos: ['巧克力酥卷小美式，建议单人使用'], price: '18' &#125;] &#125;, &#123; type: 'spa', child: [&#123; title: '魅贝克美发沙龙（崇文门新世界店）', img: '//p0.meituan.net/wedding/15570fc8c02870c37c21d4d250489cf9212844.jpg@240w_180h_1e_1c_1l|watermark=1&amp;&amp;r=2&amp;p=9&amp;x=2&amp;y=2&amp;relative=1&amp;o=20|368w_208h_1e_1c', pos: ['魅贝克美发沙龙（崇文门新世界店）'], price: '282' &#125;, &#123; title: 'TONI&amp;GUY（东方广场店）', img: '//p0.meituan.net/wedding/bdfdfa650660bc9c4b06c6a95f50492132697.jpg@240w_180h_1e_1c_1l|watermark=1&amp;&amp;r=2&amp;p=9&amp;x=2&amp;y=2&amp;relative=1&amp;o=20|368w_208h_1e_1c', pos: ['TONI&amp;GUY（东方广场店）'], price: '896' &#125;] &#125;, &#123; type: 'movie', child: [&#123; title: '金泉港IMAX国际影城', img: '//p0.meituan.net/poi/c2b482474377fc31a8311f46055f40b0442616.png@368w_208h_1e_1c', pos: ['免押金,可停车,有情侣座,儿童票,有WIFI,IMAX厅,杜比全景声厅,4DX厅'], price: '43' &#125;, &#123; title: '中影国际影城(丰台千禧街店)', img: '//p1.meituan.net/deal/__29661209__6853522.jpg@368w_208h_1e_1c', pos: ['免押金,可停车,有情侣座,儿童票,可刷卡,休息区,中国巨幕厅,60帧厅'], price: '19.9' &#125;] &#125;, &#123; type: 'travel', child: [&#123; title: '新鲜酒店', img: '//p1.meituan.net/tdchotel/3a2020cce42f452cb089eb274b67d6d18153330.jpg@368w_208h_1e_1c', pos: ['新客超值优惠','酒店套餐','亲子酒店'], price: '358' &#125;, &#123; title: '北京商旅智选北京INN公寓', img: '//p1.meituan.net/tdchotel/7d2e528c129d1376224df99dac1d3b382809929.jpg@368w_208h_1e_1c', pos: ['新客超值优惠','酒店套餐','亲子酒店'], price: '404' &#125;] &#125;] &#125; &#125;, computed: &#123; curdetail () &#123; return this.artistic.filter((item) =&gt; item.type==this.kind)[0].child &#125; &#125;, methods: &#123; moue (e) &#123; let dom = e.target let tag = dom.tagName.toLowerCase() if (tag == 'dd') &#123; this.kind = dom.getAttribute('kind') &#125; &#125; &#125;&#125;&lt;/script&gt;&lt;style lang="scss"&gt; @import "@/assets/css/index/artistic.scss";&lt;/style&gt; 8-1注册这章就是介绍接口的设计，很重要把，对于后台来说 user表 areas表 menu表 city表 username pasword email 接口/users/signup/users/signin/users/verify/users/exit/users/getUser 这一章涵盖太多不知道的东西了，必须要搞明白，为什么这么写，实现的是什么功能，再开始继续，把每一个代码都记录下来，不管是百度还是什么 nodemailer 控制邮箱的一个应用npm install nodemailer axios教程创建一个axios实例axios.create({ baseURL:}) passport 权限认证中间件，本地用户登陆，第三方登陆passport教程 这个老师写了一大堆错误，简直逻辑不同，根本无法用，然后老师一笔带过，简直就是误人子弟我自己解决了所有遇到的问题这节可以去看代码的编写，很简单接口代码实现笔记：users.js本节项目地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182import Router from 'koa-router' //路由import Redis from 'koa-redis' //redis数据库，主要是提交验证码的时候写入验证码数据import nodeMailer from 'nodemailer' //发邮件的appimport User from '../dbs/models/users.js' //mongooseimport Passport from './utils/passport.js' //自动登陆？import Email from '../dbs/config.js' //配置文件import axios from './utils/axios.js' //跨平台请求let router = new Router(&#123; //这个页面放到/users下 prefix: '/users'&#125;)let Store = new Redis().clientrouter.post('/signup', async (ctx) =&gt; &#123; //注册 const &#123; username, password, email, code &#125; = ctx.request.body //解构赋值 if (code) &#123; //判断是否输入code const saveCode = await Store.hget(`nodeMailer:$&#123;username&#125;`,'code') const saveExpire = await Store.hget(`nodeMailer:$&#123;username&#125;`,'expire') if (code === saveCode) &#123; //判断是否和redis数据库的code生成的验证码一致 if (new Date().getTime-saveExpire&gt;0) &#123; //判断是否和redis数据库时间过期 ctx.body = &#123; code: -1, msg: '验证码过期，请重新尝试' &#125; return false &#125; &#125; else &#123; //saveCode 错误执行 ctx.body = &#123; code: -1, msg: '请填写正确的验证码 ' &#125; return false &#125; &#125; else &#123; //不存在code ctx.body= &#123; code: -1, msg: '请填写验证码' &#125; return false &#125; let user = await User.find(&#123; //查询mongodb数据库 username &#125;) if (user.length) &#123; //如果有用户，提示报错 ctx.body = &#123; code: -1, msg: '已被注册' &#125; return &#125; let nuser = await User.create(&#123; //写入mongodb数据库，这里是创建一个实例 username, password, email &#125;) if (nuser) &#123; //写入成功执行 let res = await axios.post('/users/signin', &#123;username, password&#125;) //自动登陆？大概吧 if (res.data &amp;&amp; res.data.code === 0) &#123; ctx.body = &#123; code: 0, msg: '注册成功', user: res.data.user &#125; &#125; else &#123; ctx.body = &#123; code: -1, msg: 'error' &#125; &#125; &#125; else &#123; ctx.body = &#123; code: -1, msg: '注册失败' &#125; &#125;&#125;)router.post('/signin', async (ctx, next) =&gt; &#123; //自动登陆？ return Passport.authenticate('local', function(err, user, info, status) &#123; if (err) &#123; ctx.body = &#123; code: -1, msg: err &#125; &#125; else &#123; if (user) &#123; ctx.body = &#123; code: 0, msg: '登录成功', user &#125; return ctx.login(user) &#125; else &#123; ctx.body = &#123; code: 1, msg: info &#125; &#125; &#125; &#125;)(ctx, next)&#125;)router.post('/verify', async (ctx, next) =&gt; &#123; //验证码接口 let username = ctx.request.body.username //用户名 const saveExpire = await Store.hget(`nodeMailer:$&#123;username&#125;`,'expire') if (saveExpire &amp;&amp; new Date().getTime-saveExpire&lt;0) &#123; ctx.body = &#123; code: -1, msg: '验证请求过于频繁，1分钟一次' &#125; return false &#125; let transporter = nodeMailer.createTransport(&#123; host: Email.smtp.host, port: 587, secure: false, auth: &#123; user: Email.smtp.user, pass: Email.smtp.pass &#125; &#125;) let ko = &#123; code: Email.smtp.code(), expire: Email.smtp.expire(), email: ctx.request.body.email, user: ctx.request.body.username &#125; let mailOptions = &#123; from: `"您的邮件"&lt;$&#123;Email.smtp.user&#125;&gt;`, to: ko.email, subject: '《demoorbug》注册码', html: `您的验证码是$&#123;ko.code&#125;` &#125; await transporter.sendMail(mailOptions, (error, info) =&gt; &#123; if (error) &#123; return console.log('error') &#125; else &#123; //写入redis数据库 Store.hmset(`nodeMailer:$&#123;ko.user&#125;`, 'code', ko.code, 'expire', ko.expire, 'email', ko.email) &#125; &#125;) ctx.body = &#123; code: 0, msg: '验证码已发送，可能会有延迟，有效期1分钟' &#125;&#125;)router.get('/exit', async (ctx, next) =&gt; &#123; await ctx.logout() if (!ctx.isAuthenticated()) &#123; code: 0 &#125; else &#123; ctx: -1 &#125;&#125;)router.get('/getUser', async (ctx) =&gt; &#123; if(ctx.isAuthenticated()) &#123; const &#123;username, email&#125; = ctx.session.passport.user ctx.body = &#123; user: username, email &#125; &#125; else &#123; ctx.body = &#123; user: '', email: '' &#125; &#125;&#125;)export default router 目前就学习到/verify接口，前面的接口bug都已经解决，这段还没有解决，因为我感觉是有问题的代码，后面可以深入一下这个地方，多注意下，有问题就回来解决: register.vue 的验证码函数和提交函数的编写register.vue文件地址123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566methods: &#123; //验证码函数 sendMsg () &#123; let namePass let emailPass if(this.timerid) &#123; return false &#125; this.$refs['ruleForm'].validateField('name', (valid) =&gt; &#123; //validateField这是饿了么组件自带的方法，应该是。查询name是否有值，没有值，则valid返回提示的值，比如name不输入提示"请输入昵称" namePass = valid &#125;) this.statusMsg = '' //验证码的双向绑定数据 if(namePass) &#123; // return false &#125; this.$refs['ruleForm'].validateField('email', (valid) =&gt; &#123; //和上面同理 emailPass = valid &#125;) if (!namePass &amp;&amp; !emailPass) &#123; //如果都填写了，则不会赋值就为空所以是false,要取反 this.$axios.post('/users/verify', &#123; //可以直接用$axios是因为nuxtjs内置了 username: encodeURIComponent(this.ruleForm.name), 用户名转换为字符串 email: this.ruleForm.email &#125;).then((&#123;status, data&#125;) =&gt; &#123; //回调函数，解构赋值 if (status === 200 &amp;&amp; data &amp;&amp; data.code === 0) &#123; let count = 60; console.log('1') this.statusMsg = `验证码已发送,剩余$&#123;count--&#125;秒` this.timerid = setInterval(() =&gt; &#123; //定时器刷新 this.statusMsg = `验证码已发送,剩余$&#123;count--&#125;秒` if (count === 0) &#123; this.statusMsg = '' clearInterval(this.timerid) &#125; &#125;, 1000) &#125; else &#123; this.statusMsg = data.msg &#125; &#125;) &#125; &#125;, register () &#123; this.$refs['ruleForm'].validate((valid) =&gt; &#123; //饿了么组件自带的方法,全部验证通过valid = true if (valid) &#123; this.$axios.post('/users/signup', &#123; username: window.encodeURIComponent(this.ruleForm.name), password: CryptoJs.MD5(this.ruleForm.pwd).toString(), email: this.ruleForm.email, code: this.ruleForm.code &#125;).then((&#123;status, data&#125;) =&gt; &#123; if (status ===200) &#123; if (data &amp;&amp; data.code ===0) &#123; // this.error = data.msg location.href = '/login' &#125; else &#123; this.error = data.msg &#125; &#125; else &#123; this.error = `服务器出错，错误码: $&#123;status&#125;` &#125; setTimeout(() =&gt; &#123; this.error = '' &#125;, 1500) &#125;) &#125; &#125;) &#125;&#125; index 的一些修改备注index.js地址 12345678910111213141516171819202122232425262728293031import mongoose from 'mongoose' //mongooseimport bodyParser from 'koa-bodyparser' //unkownimport session from 'koa-generic-session' //sessionimport Redis from 'koa-redis' //redisimport json from 'koa-json' //格式化jsonimport dbConfig from './dbs/config'import passport from './interface/utils/passport.js' import users from './interface/users'app.keys= ['debug', 'keyskeys'] //unkownapp.proxy = true //unkownapp.use(session(&#123; //session key: 'debug', prefix: 'debug:uid', store: new Redis()&#125;))app.use(bodyParser(&#123; extendTypes: ['json', 'form', 'text']&#125;))app.use(json()) //格式化diamagneticmongoose.connect(dbConfig.dbs, &#123; //mongodb地址？应该是 useNewUrlParser: true&#125;)app.use(passport.initialize()) //unkownapp.use(passport.session()) //unkownapp.use(users.routes()).use(users.allowedMethods()) //将我们写好的路由引入 接口设计(需求分析)/geo/getPosition/geo/province/geo/province/:id/geo/city/geo/hotCity /geo/menu 查询接口/search/top/search/resultsByKeywords/search/hotPlace/search/products/search/product/:id mongoimport -d dbs -c test pois.datdbs对应databasetest对应Collectionspois.dat 对应数据源 签名：没有签名获取不到数据http://cp-tools.cn/signc6a3d36c8d43371e21550e1420f0d19ehttps://www.imooc.com/u/3164558/bbs从这个人获取到了UID。。 怎么说呢，还行吧，不过是用wsl(windows的子系统ubuntu)提交会出问题，有些东西提交了两遍 123456789101112131415161718192021222324import Vue from 'vue'import Vuex from 'vuex'import geo from './modules/geo'import home from './modules/home'Vue.use(Vuex)const store = () =&gt; new Vuex.Store(&#123; modules: &#123; geo, home &#125;, actions: &#123; async nuxtServerInit(&#123;commit&#125;, &#123;req, app&#125;) &#123; //nuxtServerInit这个是nuxtjs提供的生命周期钩子 const &#123;status, data: &#123;province, city&#125;&#125; = await app.$axios.get('/geo/getPosition') commit('geo/setPosition', status ===200 ? &#123;city, province&#125;: &#123;city: '', province: ''&#125;) const &#123;status: status2, data: &#123;menu&#125;&#125; = await app.$axios.get('/geo/menu') commit('home/setMenu', status2 === 200 ? menu : []) &#125; &#125;&#125;)export default store 放弃，只是带我抄了一遍代码，基本没什么学的，垃圾]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
        <tag>SSR</tag>
        <tag>Koa2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6学习记录]]></title>
    <url>%2Fblog%2F2018%2F11%2F30%2FES6%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 入门ECMAScript 6 入门ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 let和const命令 ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 const声明一个只读的常量。一旦声明，常量的值就不能改变。 ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 “暂时性死区” 这个就是说不能在let之前写变量，必须声明不然报错 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 let不允许在相同作用域内，重复声明同一个变量。 if (父作用域) {子作用域} 不过现在代码无法实现罢了， for (let i = 0; i &lt; 3; i++) { let i = ‘abc’; console.log(i); } 这串代码输出正确就是3个abc，然后现在的转换工具都是输出一个abc,唯有chrome控制台输出3个abc 不存在变量提升，也就是上面说的会出现暂时性死区 块级作用域let实际上为 JavaScript 新增了块级作用域。立即执行函数表达式（IIFE）不再必要了1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明 ES5规定函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明，ES6明确表示可以在块级作用域中声明，函数声明语句的行为类似于let，在块级作用域之外不可引用 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数，如果确实需要，也应该写成函数表达式，而不是函数声明语句 123456789101112131415// 函数声明语句&#123; let a = &apos;secret&apos;; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = &apos;secret&apos;; let f = function () &#123; return a; &#125;;&#125; const 一旦声明必须赋值，不然就会报错本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 对象冻结const foo = Object.freeze({}); 不知道什么意思 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。 为什么一段代码要同时运行在浏览器端和node端，为什么同时要区顶层对象，不懂了变量的解构赋值 ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 npm cache clean –force 搭建环境的时候npm报错，这个命令解决了问题 对象赋值，正真赋值的是后者而不是前者123let &#123; foo &#125; = &#123; foo: &apos;aaa&apos; &#125;换一种写法let &#123; foo: baz &#125; = &#123; foo: &apos;aaaa&apos; &#125; 上面的代码中，foo是匹配模式，baz才是变量，正真被赋值的是变量baz,而不是模式foo如果foo也想取到值则要这样写1let &#123; foo, foo: baz &#125; = &#123; foo: &apos;aaaa&apos; &#125; 默认值生效的规则是必须严格等于undefined12345var [x = 3] = [];var &#123;x = 3&#125; = &#123;x: undefined&#125;var &#123;x: y = 3&#125; = &#123;&#125; 以上是数组和对象的默认值写法 1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 不能这样写{x}javascript引擎会将它理解为一个代码块，从而发生语法错误 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 可以这样用，好方便啊1let &#123; log, sin, cos &#125; = Math; 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 [arr.length - 1]属于“属性名表达式”（参见《对象的扩展》一章） 字符串的解构赋值我奇怪的是对象可以用一个方法去解构赋值12let &#123;length: len&#125; = &apos;hello&apos;;len //5 那就是说我可以用对象里面的属性喽？ 解构赋值时，如果等号右边是数组和布尔值，则会先转为对象。12345let &#123;toString: a&#125; = 123;a === Number.prototype.toString //truelet &#123;toString: b&#125; = true;b === Number.prototype.toString //true 如果是布尔值或者数字 主要用途也是很广泛的，列举一下 交换变量的值 从函数返回多个值 函数参数的定义 提取 JSON 数据 函数参数的默认值 遍历 Map 结构 输入模块的指定方法 字符串扩展 ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化 传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 repeat方法返回一个新字符串，表示将原字符串重复n次。 ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 堆栈溢出解决方法： 尾调用优化 只有严格模式才开启。ES6模块默认开启严格模式 尾递归 蹦床函数 数组的扩展扩展运算符spread是三个点，和rest参数的逆运算一样没有理解的想法123456789let 让arrayLike = &#123; &apos;0&apos;: ：&apos;a&apos;,， &apos;1&apos;: ：&apos;b&apos;,， &apos;2&apos;: ：&apos;c&apos;,， length: 3长度：3&#125;; // ES5的写法var arr1 = [] .slice.call(（arrayLike); 暂时先到这里吧，先去学vue开发美团了，用es6的时候继续看，或者两个一起学 全栈记录纯前端已经过时，全栈才是目标 let constlet 声明变量 不能重复声明 支持块级作用域const 声明产量 控制修改 支持块级作用域 作用域1. 传统ES5仅支持一种方式，函数作用域 2. ES6块级作用域123456789&#123;&#125;if () &#123;&#125;for () &#123;&#125; 这种{}写法，都是块级作用域 解构赋值{a:12, b: 5, c: 33}[12, 5, 8]12let &#123;a, b, c&#125; = &#123;a:12, b: 5, c: 33&#125;let [c, a, d] = [12, 5, 8] 左边的类型和右边必须一致右边必须得是个东西？ 函数1. 箭头函数() =&gt; {}有且只有一个参数，可以item =&gt; {}有且只有一个语句，可以item =&gt; item + 1修复了this的问题，其他语音不存在此问题 2. 参数展开…参数展开必须是最后一个数1234let name = (a, ...arr) =&gt; &#123; console.log(a, ...arr)&#125;name(1, 2, 4, 6, 7, 8); 展开数组，就是把值全部拿出来一样12let arr = [1, 2, 4, 6 ,9]console.log(...arr) ES6 新增系统对象1.Arraymap 映射123let arr = [5, 6, 7, 8, 9];let item = arr.map(item =&gt; item &lt;= 7);console.log(item); forEach 就是把for封装起来了。filter 过滤，很简单就是把返回false的值剔除123let arr = [5, 6, 7, 8, 9];let item = arr.filter(item =&gt; item &lt;= 7);console.log(item); reduce 返回一个值，减少？123let arr = [5, 6, 7, 8, 9];let item = arr.reduce((tem,item) =&gt; tem + item);console.log(item); 2.String字符串模板12let name = '模板';console.log(`字符串$&#123;name&#125;`); startsWith获取字符串开头值12345let http = 'http://';let https = 'https://';console.log(http.startsWith('http://'));console.log(https.startsWith('http://'));console.log(https.startsWith('https://')); endsWith和上面类似，不过是从结尾开始获取 JSON ES5.5新增对象stringify() 将对象转换为标准JSON123456var obj = &#123; a: 1, b: 2, c: 3&#125;console.log(JSON.stringify(obj)) parse() 将JSON格式的字符串转换为对象12var obj = '&#123;"a": "1", "b": "2", "c": "3"&#125;';console.log(JSON.parse(obj)); 异步处理回调地狱12345678910111213141516171819$.ajax(&#123; url: 'data/1.json', dataType: 'json', success(data1)&#123; $.ajax(&#123; url: 'data/2.json', dataType: 'json', success(data2)&#123; $.ajax(&#123; url: 'data/3.json', dataType: 'json', success(data3)&#123; console.log(data1, data2, data3); &#125; &#125;); &#125; &#125;); &#125;&#125;) Promise 创建一个promise12345678910111213let a = truelet prm = new Promise((resolve, reject) =&gt; &#123; if (a) &#123; resolve('success') &#125; else &#123; reject('err') &#125;&#125;)prm.then(data =&gt; &#123; console.log(data);&#125;, err =&gt; &#123; console.log(data);&#125;) 就是一个解决回调问题的处理方法，异步当然也可以，不过是一个统一的解决方案Promise.all([])12345678910111213141516let p1 = new Promise((resolve, reject) =&gt; &#123; resolve('success')&#125;),p2 = new Promise((resolve, reject) =&gt; &#123; resolve('success1')&#125;),p3 = new Promise((resolve, reject) =&gt; &#123; resolve('success2')&#125;);Promise.all([ p1, p2, p3]).then(([a, b, c]) =&gt; &#123; console.log(a, b, c);&#125;) 有一个promise抛出reject就会报错如果里面是异步的，则会同时请求，请求完成取决于最慢的哪一个，这样的话我们就没办法第二个异步调用第一个返回的结果，这种问题我们可以用then解决呀。。。好像可以 async/await这个语法糖处理异步用的，ES8推出的12345let as = async () =&gt; &#123; let s = 1; let s2 = 2; let data = await Promise;&#125; await 后面必须是一个promise，不知道会不会自己转换。 语法糖就是，写是这么写，到计算机真正执行的时候，会把函数编译回以前的写法，就比如我们的async我们其实这么写，代码执行的时候还是一层套一层的回调，其实就是避免写起来很麻烦的尴尬局面 面向对象面向对象机器语言 -&gt; 汇编 -&gt; 低级语言(面向过程) -&gt; 高级语言(面向对象) -&gt; 模块 -&gt; 框架 -&gt; API 面向对象：1.封装性2.继承性3.多态性 主要讲面向对象的封装和继承 class封装123456789101112class Box &#123; constructor (...arr) &#123; this.arr = arr &#125; show() &#123; console.log(this.arr); &#125;&#125;let box = new Box(1, 2, 3, 4)box.show() 继承12345678910111213141516171819202122class Box &#123; constructor (...arr) &#123; this.arr = arr &#125; show() &#123; console.log(this.arr); &#125;&#125;class Whx extends Box &#123; constructor (name, ...arr) &#123; super(...arr); this.name = name &#125; showWhx() &#123; console.log(this.name); &#125;&#125;var whx = new Whx('myname', 1, 2, 3 , 4, 6)whx.show()whx.showWhx() ES5写法封装123456function Box(name) &#123; this.name = name&#125;Box.prototype.show = function () &#123; console.log(this.name);&#125; 继承12345678910111213141516171819function Box(name) &#123; this.name = name&#125;Box.prototype.show = function () &#123; console.log(this.name);&#125;function Wxn(name, j) &#123; Box.call(this, j) //call是继承他里面的属性 this.wxn = name&#125;Wxn.prototype = new Box(); //继续方法Wxn.prototype.constructor = Wxn;Wxn.prototype.showWxn = function () &#123; console.log(this.wxn);&#125;var wxn = new Wxn('youse', 'jic')wxn.show()wxn.showWxn() ES6 梳理看慕课网的实战课程es6，记录一些不了解的知识点 编程练习里面遇到个问题，当用事件委托的时候如何确认当前index，jquery很好实现，但是js我们就要自己写了123456789let li = document.querySelectorAll('li');document.addEvnetListener('click', function(e) &#123; for (let i in li) &#123; if (li === e.target) &#123; console.log('当前下标', i); break &#125; &#125; &#125;, false) 差不多就是以上代码实现，很简单，但是以前没遇到过还查了一会。。 const常量必须被赋值常量为引用类型，可以被修改12345678const name = &#123; age: 10, name: '小明'&#125;console.log(name.age, name.name);name.age = 20;console.log(name.age); //可以修改 常量只能保证地址不变，不能做到内容不变 但是Object.freeze可以防止引用类型的值被修改12345678const name = &#123; age: 10, name: '小明'&#125;Object.freeze(name);console.log(name.age, name.name);name.age = 20;console.log(name.age); //不可以被修改 ES6之前声明常量12345678910111213//----第一种--------var BASE_NAME = '小名'; //这种就是一个约定，假装我们是常量//----第二种--------var CST = &#123;&#125;Object.defineProperty(CST, 'BASE_NAME', &#123; value: '小明', writable: false&#125;)CST.BASE_NAME = 'xiaoming'console.log(CST.BASE_NAME); //小明 不可以被修改Object.seal(CST); //防止扩展CST.a = 'a';console.log(CST) //不会添加a 对象解构赋值1.123456let arr = &#123; list: [&#123; skname: '龙吟' &#125;]&#125;;const &#123; list &#125; = arr;console.log(list) //[] 212345let arr = &#123; list: [&#123; skname: '龙吟' &#125;]&#125;;const &#123; list : [&#123;skname&#125;] &#125; = arr;console.log(skname) //龙吟 3123456let arr = &#123; list: [&#123; skname: '龙吟' &#125;, &#123; skname: '龙腾'&#125;]&#125;;const &#123; list : [&#123;skname&#125;, &#123;skname : sk&#125;] &#125; = arr;console.log(skname, sk) //龙吟//因为一个变量或常量不能重复声明，所以要重命名为sk … 扩展运算符123456789let arr = &#123; list: [&#123; skname: '龙吟', hn: &#123;names: 's'&#125;, nams: 'hs' &#125;]&#125;;const &#123; list : [&#123;skname, ...a,&#125;]&#125; = arr;console.log(skname, a) 扩展对象12345678const obj1 = &#123; archer: '卫宫', lancer: '瑟坦达'&#125;const obj = &#123; seber: '阿尔托利亚', ...obj1&#125; 如何对已经声明的变量解构赋值1234567let age;const obj = &#123; name: '小明', age: 22&#125;; //这里必须有;号(&#123; age &#125; = obj);console.log(age); 不建议这样使用 使用对象传入乱序的函数参数1234567891011121314function AJAX(&#123; url, data, type = 'get'&#125;) &#123; console.log(type)&#125;AJAX(&#123; url: '/getinfo', data: &#123; a: 1 &#125;&#125;) 封装了一个简单的模态框源码地址 ES6扩展字符串扩展模板字符串 部分新方法padStart 补全字符串1234let str = 'i';let str1 = str.padStart(5, 'mooc');console.log(str1) // mooci padEnd 从字符串的后面开始补充 123let str = 'i';let str1 = str.padEnd(5, 'mooc');console.log(str1) // imooc repeat 重绘字符串1234567console.log('i'.repeat(10)) // iiiiiiiiii//自己写一个重绘方法function repeat(str, num) &#123; return new Array(num + 1).join(str); //数组的长度是4但是内容为空，用str来分割数组&#125;console.log(new Array(4).join('i'))console.log('i', 3); // iii startWith 以什么字符串开头 endsWith 以什么字符串结尾12345let str = 'A promise is a promise';console.log(str.startWith('A pr')) //trueconsole.log(str.startWith('b pr')) //falseconsole.log(str.endsWith('ise')) //true includes 替代indexOf12345678let str = 'A promise is a promise';if (~str.indexOf('proms')) &#123; //按位取反&#125;if (str.includes('A prom')) &#123;&#125; for of可以用来便利字符串，以前可以用for,或者转换成数组遍历123let str = 'NAMES';str = Array.prototype.slice.call(str);console.log(str) 或者123let str = 'NAMES';str = str.split('');console.log(str) ES612345678910111213let str = 'NAMES';str = [...str];//或let [...oStr] = str;//或for (let oStr of str) &#123; console.log(oStr)&#125;//或let oStr = str.split('')oStr.forEach(function(item) &#123; console.log(item)&#125;) 对英文字符串加密123456789101112let str = 'NAMES';const map = &#123;N:100,A:80,M:50,E:30,S:20&#125;;let [...oStr] = stroStr.forEach(function(item, index) &#123; if (str.includes(item)) &#123; oStr[index] = map[item] &#125;&#125;)console.log(oStr.join('')) //10080503020 for of1234567let str = 'NAMES';const map = &#123;N:100,A:80,M:50,E:30,S:20&#125;;let newStr = '';for (let word of str) &#123; if (str.includes(word)) newStr += map[word];&#125;console.log(newStr) //和上面结果一样 unicode码(点)这个\u1f436来自emoji 有很多unicode表情js中仅识别 0000 - ffff一个码点 \u1f436 这个码点是超出了的，\u自动被识别为unicode码点ES6提供了一种方式\u{1f436} Unicode是一项标准 包括字符集、编码方案等他是为了解决传统的字符编码方案的局限而产生的，为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求codePointAt 获取字符串中对应字符的一个码点1'🐕'.codePointAt(0).toString(16) at 根据小标取字符 , 低版本浏览器支持，chrome不支持1'🐕'.at(0); 正则扩展u 修饰符，识别unicodey 修饰符,粘连修饰符 数值扩展新的进制表示法8进制 规定以0o或0O打头 octonary2进制 规定以0b或0B打头 binary以前的二进制写法016,现在的写法0o16; 新的方法与安全数？Number.parseInfNumber.parseFloat以前是挂载在window上，现在挂载到Number上了isNaN 判断一个值是否为NaN；console.log(Number.isNaN(NaN)) //true1234//自己实现一个NaNfunction isNa(value) &#123; return value !== value; //NaN === NaN 返回false&#125; isFinite 判断一个值是否有限123console.log(Number.isFinite(Infinity))console.log(Number.isFinite(2 / 0))console.log(Number.isFinite(1234)) Number.MAX_SAFE_INTEGER 最大值常量, Math.pow(2, 53) - 1 2**53 -1Number.MIN_SAFE_INTEGER 最小值常量Num.isSafeInteger() 安全数 ，是否在最大最小值之间 函数扩展函数传参和解构赋值结合1234function People(&#123; name, age = 18 &#125; = &#123;&#125;) &#123; console.log(name, age)&#125;People() 箭头函数1const pop = arr =&gt; void arr.pop(); void 可以让这句话不返回或undefined 对象扩展属性名表达式12345let key = 'is'let obj = &#123; [`$&#123;key&#125;obj`]: false&#125;//中括号代表表达式 Object.is() 相应的严格===12345//不一样的地方console.log(Object(-0, +0)); //falseconsole.log(-0 === +0); //trueconsole.log(Object(NaN, NaN)); //trueconsole.log(NaN === NaN); //false Object.assign() 和扩展运算符合并的是一样的，浅拷贝1Object.assign(&#123;a: 1&#125;, &#123;b: 2&#125;); Object.keys() 拿到对象的keyObject.values() 拿到对象的值Object.entries() 拿到对象的组，以上及当前都返回的数组结合以上的方法可以便利对象12345678obj = &#123; a: 1, b: 2, c: 3&#125;for (let [key, value] of Object.entries(obj)) &#123; console.log(key, value)&#125; __proto__ 调试的时候可以用，编码的时候不要用Object.setPrototypeOf(obj, obj2) 运行的过程中修改原型，性能低下，建议不要使用Object.create() 创建的时候指定原型Object.getPrototypeOf() 获取原型123456//推荐使用Object.setPrototypeOf 和 Object.getPrototypeOf 操作原型let obj1 = &#123; a: 1&#125;let obj = Object.create(obj1);console.log(Object.getPrototypeOf(obj) === obj.__proto__) super 关键字，可以访问对象的原型 数组的扩展Set() 新的数据类型，可以去重12var set = new Set([1, 2, 2, 3])console.log([...set]) find 如果查到就返回便利到的值findIndex 同理，不过返回的是下标，和indexOf区别就是indexOf不能识别NaN 取余%125 % 2 // =&gt; 1 具体逻辑是这样的，5 / 2 = 2 余 1 4 % 2 // =&gt; 0 逻辑, 4 / 2 = 0 幂运算1let a = 2 ** 10; //1024 按位取反12345~x = -(x + 1);if (~x.indexOf('proms')) &#123;&#125; 替代123if (x.indexOf('proms') !== -1) &#123;&#125; PromisePromise对象用于表示一个异步操作的最终状态(完成或失败)以及其返回值。 —MDN then() 接收两个匿名函数，一个代表成功，一个代表失败catch() 失败的处理。但是没有全局捕获错误的办法，只可以捕获上一次错误finally 不论成功失败，finally中的内容一定会执行 class测试不会的问题记录7测试图，正则 新增修饰符y的用法及 exec()方法使用16测试图，大意了，可以用function foo({x, y=0} = {}) {}; foo(); 这样调用就可以不出错了22测试图25测试图28测试图 VueVue的 按需加载1() =&gt; import(/* webpackChunkName: "about" */ './views/About.vue') 路由的按需加载，只有用到的时候才会加载，我的天 页面的跳转，比原生的浏览器跳转好12345678scrollBehavior (to, from, savedPosition) &#123; console.log('savedPosition', savedPosition) if (savedPosition) &#123; return savedPosition &#125; else &#123; return &#123; x: 0, y: 0 &#125; &#125;&#125; HTML5 History 模式]]></content>
      <categories>
        <category>笔记MAX</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2Fshell%2F</url>
    <content type="text"><![CDATA[linux命令linux命令 所学命令的一些大致顺序 以及简介 命令 常用参数 命令英文原意 简介 2016-9-22 pwd no print working directory 查询所在目录位置 ls -aldhi 查询目录内容 -rw-r–r– no r读w写x执行 mkdir -p make directories 建立目录 cd ~ - .. . change directory 切换所在目录 tab no 目录补全,命令补全,按两下就会显示当前目录的东西 rmdir no remove empty directories 删除，但是不常用，有文件内容就无法删除 rm -rf remove 删除文件或目录 cp -rpd -a copy 复制命令-a相当于-rpd mv move 剪切或改名命令 2016-9-23 ln -s link 链接命令 最好使用-s(软链接)方式创建 locate 文件搜索命令，搜索速度快,在/var/lib/mlocate 下搜索后台数据库 updatedb 每天更新一次，所以可以手动更新 whereis -bm 搜索命令的命令,ls.1.gz 1 命令 man -f ls ，man 1 ls 一致 which 搜索命令的命令。搜索命令所在路径及别名 find -iname -user -nouser find / -name install.log * ? [] 通配符*任意内容?一个内容[]任意一个中括号中的内容 -exec {} \ 可以在其他命令之后再继续执行命令 grep -iv 搜索字符串命令 grep [选项] 字符串 文件名 man -f 帮助命令 man ls man 需要下载包 编辑模式-d 然后按n就可以向下跳 shift上 passwd 找到所有关于 ls –help 在xShell中显示中文 help 获取内部命令 介绍 info 帮助查询，回车进入(带有*号) u 进入上层页面 n进入下一节 p进入上一节 q退出 zip -r zip 压缩文件名 源文件 zip -r 压缩文件名 源目录 unzip 解压缩 touch -acfm 用来更新文件的或目录的时间，文件不存在则创建文件 gzip .gz 格式压缩 gzip 源文件 #这样源文件会消失，gzip -c 源文件 &gt; 压缩文件源文件保留,gzip -r 目录 压缩目录下的所有子文件，不能压缩目录 ls &gt; abc 将ls 当前数据写到 abc文件下 cat 输出文件 gunzip gzip -d 两种都可以解压缩 bzip2 bzip2 -k 源文件 这样可以保留源文件，bzip2 源文件 不能压缩目录 bzip2 -d bunzip2 解压缩 tar -cvf 打包命令，例如 tar -cvf longzls.tar longzls 打包后压缩 tar -xvf 解打包命令 -x解打包 tar -zcvf 直接将其打包解压gzip tar -jcvf 直接将其打包为bzip2 tar -ztvf t代表测试的意思，只查看里面内容但是不解压 shutdown -chr shutdown [选项] 时间 date 时间 &amp; shutdown -r 05:30 &amp; 代表后台执行 ，吧这条命令了放到后台组不占用当前操作字段 runlevel 查看运行级别 logout 退出登录命令 mount -a 挂载命令 mount -to mount [-t文件系统] [-o特殊选项] 设备文件名 挂载点 umount 卸载命令 fdisk -l 查看已经读取的设备 w 查看登录用户信息 who 查看登录用户信息 last 查询当前登录和过去登录的用户信息，/var/log/wtmp/这个文件是被编译的，一旦修改直接崩溃 lastlog 查看所有用户的最后一次登录时间，/var/log/lastlog/ echo $SHELL 打印当前环境的shell用的是什么sh、ksh、Bash、psh、zsh echo -e 输出命令,echo [选项] [输出内容] vim 貌似是创建一个文本 chmod 755 hello.sh 赋予执行权限 bash hello.sh 通过Bash调用执行脚本 alias 显示已有的别名,alias ls=”ls –color=never” 定义别名 history -cw 历史命令 history [选项] [历史命令保存文件] wc -cwl 输入重定向，wc [选项][文件名] more 分屏显示 netstat -an df -lahHTtx 磁盘管理 du -bkmhHs 统计磁盘文件大小 fdisk 分区 passwd 修改密码 source 配置文件 或 . 配置文件 locate 遵循/etc/updatedb.conf 配置文件 常见压缩格式 ： .zip .gz .bz2 .tar.gz .tar.bz2 tar -jxvf jp.tar.bz2 -C /tmp/ 指定目录解压缩 tar -jxvf /tmp/jp.tar.bz2 jp anaconda 压缩多个文件，并且指定目录 shutdown -r now 立即重启 -h关机 -c取消前一个关机命令 cat /etc/inittab 决定你启动是在字符界面还是图像界面 默认运行级别 linux 中大写X代表图形界面 mount -t vfat /dev/sdb1 /mnt/usb/ 挂载U盘 vfat = fat32 光盘设备文件名 /dev/sr0 mount -t iso9660 /dev/sr0 /mnt/cdrom/ 挂载光盘 按i, I, o, O, a, A, r, R任一字符进入输入模式 ##环境变量12345678910111213141516171819202122用户自定义变量(本地变量)环境变量 环境变量作用:定义每个用户的操作环境。已学的环境变量：path预定义变量位置参数变量source 配置文件或. 配置文件修改配置文件后，必须注销重新登录才能生效使用source命令可以不用重新登录/etc/profile/etc/profile.d/*.sh~/.bash_profile~/.bashrc/etc/bashrc本地终端欢迎信息：/etc/issue\l 显示登陆终端号，共6个远程登陆欢迎信息：/etc/issue.net显示欢迎信息，由ssh的配置文件/etc/ssh/sshd_config决定，加入&quot;Banner /etc/issue.net&quot; 行才能显示(重启ssh服务) ##用户和用户组123456789101112131415161718192021222324252627282930313233343536373839404142434445464748sudo adduser username 创建用户/etc/group 存储当前系统中所有用户组信息组名称:组密码占位符:组编号:组中用户名列表/etc/gshadow 存储当前系统中用户组的密码信息组名称：组密码：租管理者：组中用户列表 * ！可以认为密码为空/etc/passwd 存储当前系统中所有用户的信息用户名:密码占位符:用户编号：用户编号组：用户注释信息：用户主目录：shell类型/etc/shadow 存储当前系统中所有用户的密码信息groupadd sexygroupmod -n market sexy 修改组名groupmod -g 668 market 修改组编号groupadd -g 888 boss 创建box 直接改变组编号groupadel market 删除 用户组 必须先删除用户用户groupadd sexyuseradd -g sexy sdf -g指定用户组useradd -g sexy jzmbuseradd -d /home/xxx imooc -d指定用户文件夹 没有写就会直接创建同名文件夹usermod -c dgdzmx sdf 修改sdf用户备注usermod -l cls sdf 新用户写到前面，旧用户写到后面 修改usermod -d /home/cls cls 修改cls用户文件夹usermod -g sexy imooc 将用户imooc切换到 sexyuserdel jzmb 删除用户jzmb 不会删除文件userdel -r jzmb 删除他的个人文件touch /etc/nologin 出了root 用户 其他人都无法登陆 在~目录创建就好passwd -l cls 锁定账户pwsswd -u cls 解锁passwd -d cls 清除密码gpasswd -a cls boss 附属组gpasswd -a cls boss,sexy 多个附属组newgrp boss 切换附属组 要输入组密码gpasswd =d cls boss 清除附属组useradd -g group1 -G group2,group3,········ 及指定主要组和附属组gpasswrd imooc 设置组密码su username 切换用户Whoami 我谁谁？显示当前登录用户名id cls 显示指定用户信息，包括用户编号，用户名groups cls 显示cls用户所在组chfn cls 设置用户资料，一次输入用户资料finger imooc 显示用户详细资料 ##swap12345678910fdisk /dev/sdbpt磁盘1-nL 编号mkswap /dev/sdb5 格式化swapon /dev/sbb5 启用free 加载状况swapoff /dev/sdb5 停止 ##自动挂载12vim + /etc/fstab/dev/sdb1 /mnt/imooc ext4 defaults 0 0 ##格式化 12mkfs.ext4 /dev/sdb1mkfs -t ext4 /dev/sdb2 ##分区1234567891011121314151617181920fdisk 查看帮助fdisk -l 最后一块就是我们新添加的盘fdisk /dev/sdbm 查看帮助信息n 添加分区 p表示主分区 e表示扩展分区p 查看当前分区表d 删除分区w 写入方案 保存parted 分区 MBR GPT 两个都可以使用此工具help 帮助信息select /dev/sdcmklabel gptprint 查看当前分区详情print all 查看所有mkpart 添加分区 提问模式 交互模式mkpart test 2000 3000 命令模式rm 3 删除第三块分区unit GB 位单位 VIM123456789101112131415161718192021222324252627vim + abc 直接进入最后一行vim +2 abc 进入第二行vim +/a abc 查看所有带A的高亮 命令模式按n切换vim aa bb cc 打开多个文件，n下一页 N 上一页底行模式常用指令:w 保存修改:q 退出:! 强制执行:ls 列出当前打开的所有文件:n N:15 快速定位/xxx 从光标位置向后搜索?xxx 从光标位置向前搜索命令模式h 光标左移j 光标下移k 光标上移l 光标右移ctrl+f 向下翻页ctrl+b 向上翻页ctrl+d 向下翻半页ctrl+u 向上翻半页dd 删除光标所在行o 在光标所在行的下方插入一行并切换到输入模式yy 复制光标所在的行p 在光标所在行的下方粘贴P 在光标的所在行的上放粘贴 通配符123456789101112？ 一个字符* 所有[] [abc][-] [0-9][0-9][^] [^0-9]逻辑非----------`` 是用来包含系统命令的 $(ls) 替代方案&apos;&apos; 变量 \ $ 不会被执行&quot;&quot; 和单元号相反# 代表注释$ 用于调用变量，调用name的时候，需要$name方式\ 转以符合 ##管道符1234567891 多命令顺序执行; 命令1;命令2&amp;&amp; 命令1&amp;&amp;命令2|| 命令1||命令22.管道符这个才是管道符命令1 | 命令2 用命令2去操作命令1打印出来的东西netstat -an | grep ESTABLISHED | wc -l 通过他我们可以知道服务器连接多少人 重定向123456789ls &gt; test.log 文件不存在创建并修改ls &gt;&gt; test.log 追加detecang 2&gt;&gt;test.log 错误信息追加，没有空格ls &gt;&gt; test.log 2&gt;&amp;1ls &amp;&gt;&gt; test.log 不管错误还是标准 都追加ls $&gt; /dev/null 丢进黑洞ls&gt;&gt;文件1 2&gt;&gt;文件2 正确的保存到文件1 错误的保存到文件2 ##历史命令的调用123!n 重复执行第N条历史命令!! 重复执行上一条命令!字符 重复执行最后一条以该字符开头的命令 快捷键1234567ctrl+c 强制终止当前命令ctrl+l 清屏 clearctrl+a 光标移动到命令行首ctrl+e 光标移动到命令行尾ctrl+u 从光标所在位置删除到行首ctrl+z 把命令放入后台 &amp;ctrl+r 在历史命令中搜索 环境变量1234vi ~/.bashrc#写入环境变量的配置文件source .bashrc 直接生效，或者重新登录unalias cp 临时删除 第一个脚本12345vi hello.sh#!/bin/bash 必须有#The first program 注释echo -e &quot;\e[1;34m 天上掉下个林妹妹 \e[0m&quot; shell1234vi /etc/shells 可以查看当前Bash与sh兼容sh 进入 sh shellexit 退出csh 进入 csh shell ##mount -o指定一些操作1234567891011atime/noatime 更新访问时间/不更新访问时间。访问分区文件时,是否更新文件的访问时间,默认更新async/sync 异步/同步，默认为异步auto/noauto 自动/手动,mount -a 命令执行时,是否会自动安装/etc/fstab文件内容挂载，默认为自动defaults 自动默认值,相当于re,suid,dev,exec,auto,nouser,async这七个选项exec/noexec 执行/不执行,设定是否允许在文件系统中执行科执行文件,默认是exec允许remount 重新挂载已经挂载的文件系统,一般用于指定修改特殊权限rw/ro 读写/只读,文件系统挂载时,是否具有读写权限,默认是rwsuid/nosuid 具有/不具有SUID权限,设定文件系统是否具有SUID和SGID的权限，默认是具有user/nouser 允许/不允许普通用户挂载,设定文件系统是否允许普通用户挂载,默认是不允许,只有root可以挂载分区usrquota 写入代表文件系统支持用户磁盘配额,默认不支持grpquota 写入代表文件系统支持组磁盘配额,默认不支持 find ，-exec1234567891011121314151617181920212223242526&gt; find /var/log/ -mtime +10 查找10天前修改的文件&gt; -10 10天内修改的文件&gt; 10 10天当天修改的文件&gt; +10 10天前修改的文件&gt;&gt; atime 文件访问时间&gt; ctime 改变文件属性&gt; mtime 修改文件内容&gt; &gt; find . -size 25k 查找文件大小是25K的文件&gt; **25M M要大写**&gt; -25k 小于25KB的文件&gt; 25K 等于25KB的文件&gt; + 大于 25KB的文件&gt;&gt; find . -inum 262422&gt; 查找I节点是262422的文件&gt;&gt; find /etc -size +20k -a -size -50k&gt; #查找/etc目录下，大于20KB并且小于50KB的文件&gt; -a and 逻辑于&gt; -o or 逻辑或&gt;&gt; find /etc -size +20k -a -size -50k -exec ls -lh &#123;&#125; \; 常用目录的作用12345678910111213141516/根目录/bin命令保存目录 (普通用户就可使用) /sbin (root才可修改) /usr还有bin目录意思同前面/boot 启动目录 保存的是启动数据/dev 特殊文件目录/etc 保存的是默认配置文件/home 是普通用户目录/root 超级管理员目录/lib 函数库/mis /media /mnt 挂载U盘 空目录，所有存储设备都要挂着后使用，挂载就是分配盘符，用着作为外接存储的盘符 /mnt挂U盘 移动硬盘，老师在/mnt目录下创建CDrm 挂载光盘，同时创建mst挂载U盘*** 为什么呢 因为老式的linux 没有其他两个目录 /mis挂载磁带机 /media 挂载光盘 ***/proc /sys 不能直接操作，保存的是内存的挂载点，直接写在内存当中，无法写入数据/tmp 临时目录/usr 系统资源保存目录/var 系统相关文档*** 练习的话就在tmp和root，home下 *** ps aux 查看运行程序 scp 的使用-v 和大多数 linux命令中的-v意思一样，用来显示进度。可以用来查看连接、认证、或是配置错误 -C 使能压缩选项 -P 选择端口 -r 复制目录 1、从本地将文件传输到服务器scp【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】 scp /Users/mac_pc/Desktop/test.png root@192.168.1.1:/root 2、从本地将文件夹传输到服务器scp -r【本地文件的路径】【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】 sup -r /Users/mac_pc/Desktop/test root@192.168.1.1:/root 3、将服务器上的文件传输到本地scp 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】 scp root@192.168.1.1:/data/wwwroot/default/111.png /Users/mac_pc/Desktop 4、将服务器上的文件夹传输到本地scp -r 【服务器用户名】@【服务器地址】：【服务器上存放文件的路径】【本地文件的路径】 sup -r root@192.168.1.1:/data/wwwroot/default/test /Users/mac_pc/Desktop 作者：小猪熊121来源：CSDN原文：https://blog.csdn.net/aa294194253/article/details/50054723版权声明：本文为博主原创文章，转载请附上博文链接！ 查看进程，杀死进程12ps -aux // 查看进程kill -s 9 PID // 上面的命令可以查出PID sudo npm sudo node 报错找不到命令123456//原因很简单，没有放到/usr/local/bin目录下，所以我们创建软链接即可while node //查看命令所在路径while npmsudo ln -s /home/demoorbug/.nvm/versions/node/v14.5.0/bin/node /usr/local/bin/sudo ln -s /home/demoorbug/.nvm/versions/node/v14.5.0/bin/npm /usr/local/bin///done brew 安装12345curl -L https://github.com/Homebrew/brew/tarball/master | tar xz --strip 1 -C ~/homebrew# 环境变量配置export PATH="$HOME/.linuxbrew/bin:$PATH"export LD_LIBRARY_PATH="$HOME/.linuxbrew/lib:$LD_LIBRARY_PATH"source ~/.bashrc z 配置12345brew install zbrew list zvim ~/.bashrc. /home/demoorbug/homebrew/Cellar/z/1.9/etc/profile.d/z.sh #这条命令粘贴到.bashrcsource ~/.bashrc 12 技巧https://www.youtube.com/watch?v=gxBis8EgoAg&amp;t=1010s12find packages -type f | grep vue //查找packages下所有带vue带文件find packages -type f | grep vue | xargs rm //删除所有筛选到到文件]]></content>
      <categories>
        <category>github项目笔记</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>bash</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[angular]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2Fangular%2F</url>
    <content type="text"><![CDATA[MVC 只是手段，终极目标是模块化和复用项目地址：angular|时间|简介|内容||–|–|–||9-13|开始|| 核心特效1234MVC模块化和依赖注入双向数据绑定指令 Controller 使用过程中的注意点12345不要试图去复用Controller,一个控制器一般只负责一小块试图不要在Controller中操作DOM,这不是控制器的职责 指令不要在Controller里面做数据格式化,ng有很好用的表单控件不要在COntroller里面做数据过滤操作,ng有$filter服务一般来说,Controller是不会互相调用的,控制器之间的交互会通过事件进行 数据模式(Model) 视图(View) 控制器(Controller) AngularJS的MVC是借助$scope实现的，就是说全部借助于作用域实现的神器的$scope12345678910111213141516171819$scope 是一个POJO(Plain Old javascript) 普通的js对象pojo$scope 提供了一些工具方法$watch()实时监测属性变化/$apply() 一般来说不会手动调用，它会帮我们在内部监控这些属性的实时变化$scope 是表达式的执行环境(或者叫作用域)$scope 是一个树形结构,与DOM标签平行，子层标签继承父标签上面的一些属性，方法每一个Angular应用只有一个根$scope对象(一般位于ng-app上)$scope 可以传播事件，类似DOM事件，可以向上也可以向下$scope 不仅是MVC的基础，也是后面实现双向数据绑定的基础可以用angular.element($0).scope()进行调试angular启动的时候一定首先创建$rootScope,子层的$scope都是不断的往$rootScope上面添加的当然子层标签也是可以创建一些独立的$scope$scope的生命周期 Creation 创建 Watcher registration 监控 Model mutation 检测模型的变化 Mutation observation 观察模型到底有没有(脏啊) Scope destruction 不用了可以销毁 用到的指令记录12345678ng-repeat 迭代数组$emit() 向上去传播 向根 树型结构$broadcast() 向下去传播 向叶子 树型结构ng-band 避免出现&#123;&#123;&#125;&#125; 首页用ng-band 子页面因为已经被angular管理了，所以可以用&#123;&#123;&#125;&#125;ng-model 没有具体讲解，不过看起来和上面挺像 &lt;input&gt;, &lt;select&gt;, &lt;textarea&gt;, 元素支持该指令。ng-class 接受表达式 ng-class='&#123;moss:Nime,asd:Asd&#125;' 如果Nime为true,则赋值mossng-show 显示ng-hide 路由、模块、依赖注入1234使用 ngRoute 进行视图直接的路由$routeProvider 有两个方法 when /demo otherwise 默认跳转 github 搜索 Angular-ui项目指令1234567891011121314151617181920212223242526272829303132myModule.directive("hello",function()&#123; return &#123; restrict: 'AEMC', E 元素 C class A 自定义属性 M 注释&lt;!-- directive:hello --&gt; 注意两边有空格 E A 常用 template: '&lt;div&gt;Hi everyone!&lt;/div&gt;', replace: true templateUrl: 'hello.html' transclude: true 可以嵌套 template: "&lt;div&gt;Hi everyone!&lt;div ng-transclude&gt;&lt;/div&gt; &lt;/div&gt; " compile: function()&#123; 自定义compile &#125; link: function(scope,element,attr)&#123; 操作DOM 绑定事件，作用域 &#125; controller: function($scope) &#123; 应该是暴露一组函数，别人可以调用。给外部调用 $scope.abilities = []; this.addStrength= function() &#123; $scope.abilities.push('strength') &#125; &#125; require: '^superman', 依赖于superman指令 这样就可以调用到里面的controller link: function(scope,element,attrs,supermanCtrl) &#123; supermanCtrl 就可以调用到依赖superman指令暴露出的controller函数 &#125; &#125; &#125;)]]></content>
      <categories>
        <category>github项目笔记</category>
      </categories>
      <tags>
        <tag>angular</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Newproject]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2FNewproject%2F</url>
    <content type="text"><![CDATA[穆克网七夕 html5 一些记录吧项目地址：穆克网七夕 HTML5+CSS3+jquer.html 第一天:nth-child1234案例p:nth-child(2) &#123;background:#ff0000;&#125; 选中P的第二个标签 规定属于其父元素的第二个子元素的每个 p 的背景色： .find(“:first”)12这个很神奇 获取父级的html，但是不获取父级，很奇怪获取第一个子节点 transform: translate3d(-740px, 0px, 0px);transition-timing-function: linear;transition-duration: 5000ms;1234567891011121314151617181920212223242526272829303132translate3d(x,y,z) 定义 3D 转换。transition-timing-function 规定速度效果的速度曲线。transition-duration 规定完成过渡效果需要多少秒或毫秒。_transition 的全名写法：_transition-property 规定设置过渡效果的 CSS 属性的名称。transition-duration 规定完成过渡效果需要多少秒或毫秒。transition-timing-function 规定速度效果的速度曲线。transition-delay 定义过渡效果何时开始。_transform 的各种用法：_none 定义不进行转换。 matrix(n,n,n,n,n,n) 定义 2D 转换，使用六个值的矩阵。 matrix3d(n,n,n,n,n,n,n,n,n,n,n,n,n,n,n,n) 定义 3D 转换，使用 16 个值的 4x4 矩阵。 translate(x,y) 定义 2D 转换。 translate3d(x,y,z) 定义 3D 转换。 translateX(x) 定义转换，只是用 X 轴的值。 translateY(y) 定义转换，只是用 Y 轴的值。 translateZ(z) 定义 3D 转换，只是用 Z 轴的值。 scale(x,y) 定义 2D 缩放转换。 scale3d(x,y,z) 定义 3D 缩放转换。 scaleX(x) 通过设置 X 轴的值来定义缩放转换。 scaleY(y) 通过设置 Y 轴的值来定义缩放转换。 scaleZ(z) 通过设置 Z 轴的值来定义 3D 缩放转换。 rotate(angle) 定义 2D 旋转，在参数中规定角度。 rotate3d(x,y,z,angle) 定义 3D 旋转。 rotateX(angle) 定义沿着 X 轴的 3D 旋转。 rotateY(angle) 定义沿着 Y 轴的 3D 旋转。 rotateZ(angle) 定义沿着 Z 轴的 3D 旋转。 skew(x-angle,y-angle) 定义沿着 X 和 Y 轴的 2D 倾斜转换。 skewX(angle) 定义沿着 X 轴的 2D 倾斜转换。 skewY(angle) 定义沿着 Y 轴的 2D 倾斜转换。 perspective(n) 为 3D 转换元素定义透视视图。 封装1234封装，即隐藏对象的属性和实现细节，仅对外公开接口。封装的目的是增强安全性和简化编程，使用者不必了解具体的实现细节，而只是要通过外部接口，以特定的访问权限来使用类的成员这个主题案例，我采用的是面向接口编程的写法，简单的说就是将行为封装分布在各个对象中，并让这些对象自己各自负责自己的行为，这也是面向对象设计的一个优点就拿页面切换的效果来说，在某一时刻，元素A需要让页面进行切换，那么元素A不需要关心页面是怎么切换的，它只能要调用到一个接口方法能让页面切换就行了 @keyframesanimation12345678/*规定 @keyframes 动画的名称。*/animation-name: person-slow; /*规定动画完成一个周期所花费的秒或毫秒。默认是 0*/animation-duration: 950ms;/*规定动画被播放的次数。默认是 1。 infinite(循环播放)*/animation-iteration-count: infinite;/*动画切换的方式是一帧一帧的改变*/animation-timing-function: steps(1, start); animation-play-state: paused;1暂停动画 js的一些技巧我发现这些人喜欢这样编码1234567891011121314151617var getValue = function(className) &#123; var $elem = $('' + className + ''); // 走路的路线坐标 return &#123; height: $elem.height(), top: $elem.position().top &#125;;&#125;;// 路的Y轴var pathY = function() &#123; var data = getValue('.a_background_middle'); return data.top + data.height / 2;&#125;();_定义函数的时候 用var getVlaue = function()&#123;&#125; 这样的方式，而且就算是求值也要写到函数里面，get_&lt;i&gt;哇塞，这好像封装了两个方法，好厉害啊 点赞 这样好像有些不清晰，为了以后方便查找源，这里附上链接&lt;/i&gt;&lt;a&gt;http://www.imooc.com/code/8897&lt;/a&gt; 判断对象12obj instanceof Object _上面的基于原型链判断的_ jquery.transit1234过度动画 和 animation很像 $boy.transition(&#123; 'left': $("#content").width() + 'px', &#125;, 10000, 'linear', function() &#123;&#125;); Promises123456789101112131415161718192021222324dtd.then(function() &#123; //操作1&#125;).then(function() &#123; //操作2&#125;).then(function() &#123; //操作3&#125;)_上面是一个案例模型，下面的才是一个例子_function animate2() &#123; var dtd = $.Deferred(); // 生成Deferred对象 $("#block4").animate(&#123; width: "50%" &#125;, 2000, function() &#123; dtd.resolve(); // 改变Deferred对象的执行状态 &#125;); return dtd;&#125;_var anim = animate1(); 为了让代码清晰_ anim.then(function() &#123; $("#block3").text('block3动画动画直接结束'); return animate2();&#125;).then(function() &#123; $("#block4").text('block4动画动画直接结束');&#125;);]]></content>
      <categories>
        <category>github项目笔记</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>css3</tag>
        <tag>jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[comprehensive]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2Fcomprehensive%2F</url>
    <content type="text"><![CDATA[以前做过的东西，总结一下几乎涵盖了16年学的所有东西 CSS3+JS 实现超炫的散列画廊特效项目地址：CSS3+JS 实现超炫的散列画廊特效12345678910111213141516**3D效果编写**2016.4.25transition：property duration timing-function delayproperty 规定设置过渡效果的css属性的名称duration 规定完成过渡效果多少秒或毫秒timing-function 规定速度效果的速度曲线，默认easedalay 定义过渡效果延迟多久开始，默认0**知识**-webkit-font-smoothing:antialiased;用于字体平滑&lt; body onselectstart="return false"&gt;# onselectstart="return false" 防止文字被选中 -webkit-perspective:800px; # 支持3Dbox-sizing: border-box; # 内容和padd都会在border边框之内去呈现-webkit-transform-style:preserve-3d; #支持子元素的3D效果-webkit-transform:translate(0px,0px) rotateY(0deg); #定义位移以及沿着Y轴旋转-webkit-backface-visibility:hidden; 当元素不面向屏幕时隐藏 WEB APP项目地址: WEB APP Touch基础事件5.30touchstart:手指触摸屏幕触发(已经有手指放屏幕上不会触发)touchmove:手指在屏幕滑动,连续触发touchend:手指离开屏幕时触发touchcancel:系统取消touch时候触发(不常用 )android的4.4,4.0的bug：支触发touchstart，和一次的touchmove不触发加入event.preventDefault除常见的事件属性外，触摸事件包含专有的触摸属性touches:跟踪触摸操作的touch对象数组targetTouches:特定事件目标的touch对象数组changaoTouches:上次触摸改变的touch对象数组每个touch对象包含属性:clientX:触摸目标在视口中的x坐标clientY:触摸目标在视口的y坐标identifier:标识触摸的唯一ID。pageX:触摸目标在页面中的x坐标(包含滚动)pageY:触摸目标在页面中的y坐标(包含滚动)screenX:触摸目标在屏幕中的x坐标screenY:触摸目标在屏幕中的y坐标target:触摸的DOM节点目标。移动框架库5.25Tab自定义事件Fastclick库zepto.jstab点透bugviewport 视图5.20980px(ios)&lt; meta name=”viewport” content=”name=value,name=value&gt;width: 设置布局viewport的特定值(‘device-width’)initial-scale: 设置页面的初始缩放 1minimum-sacle: 最小缩放maximum-scale: 最大缩放user-scalable: 用户能否缩放垂直居中 CSS3.myoff-wrapper { position:absolute; top:50%; left:50%; z-index:3; -webkit-transform:translate(-50%,-50%); border-radius:6px; background:#FFF}基本知识-像素5.19移动开发像素知识px: css pixels 逻辑像素，浏览器使用的抽象单位 1px == 1像素dp,pt: device independent pixels 设备无关像素 1dp == 4/1像素 一个像素就会有4个物理像素(dp)渲染dpr: devicePixelRatio 设备像素缩放比_计算公式：1px = (dpr)_2_ dp_ iphone5是320px568px? -&gt; 因为 dpr = 2平面上：1px = (2)_2_ dp纬度上：1px = 2 dp因此换算公式640dp1136dp == 320px568pxDPI:打印机每英寸可以喷的墨汁点(印刷行业)PPI:屏幕每英寸的像素数量，既单位英寸内的像素密度目前。在计算机显示设备参数描述上，二者意思表达的是一样的。 计算公式： 以iPhone5为例子ppi= √ (1136_2_ 640_2_) /4 = 326ppi (视网膜Retina屏) PPI越高，像素数越高，图像越清晰当可视度越低(小)，系统默认设置缩放越大 ldpi mdpi hdpi xhdpippi 120 160 240 320默认缩放比 0.75 1.0 1.5 2.0_1px = dpr_2_ dp_ canvas项目链接：canvas 这几天看css3去了4.27 第一天4.19canvas 指定大小最好在 width=”” height=”” 最好在标签能直接加上css指定的实际是canvas显示的大小1234567891011121314151617181920_var canvas = document.getElementById('canvas');var context = canvas.getContext('2d'); #使用context进行绘制_可以判断 canvas.getContext('2d'); #是否为空 * context.moveTo(100,100); 画一条直线开始 context.lineTo(700,700); 结束 context.lineWidth = 5; 线条宽 context.strokeStyle = "#005588" context.stroke();*_ 绘制一个三角并填充 context.moveTo(100,100); context.lineTo(700,700); context.lineTo(100,700); context.lineTo(100,100); // context.strokeStyle = "#005588"; context.fillStyle = "rgb(2,100,3)" context.fill();_ css3 重要的项目地址：css3 置顶 19.48 感冒头疼 特此请假 2016-5-18 —— 2016-5-19tap事件基础5.24自定义事件自定义Tap事件原理：在touchstart、touchend时记录时间、手指位置，在touchend时进行比较，如果手指位置为同一位置(或允许移动一个非常小的位移值)且时间间隔较短(一般认为200ms)，且过程中未曾触发过touchmove，即可认为触发了手持设备上的“click”，一般称他为“tap”样式处理5.24在移动web页面上渲染图片，为了避免图片产生模糊，图片的宽度用物理像素单位渲染，即100100的图片，应该使用100dp100dpwidth: (w_value/dpr)px;height: (h_value/dpr)px;边框1px使用2dp渲染.sidebar .folder li { padding:8px 0 8px 15px; color:#7c7c7c; cursor:pointer; position:relative;}.folder li + li:before { position:absolute; top: -1px; left: 0 ; content: ‘’; width:100%; height:1px; border-top:1px solid #DDD; -webkit-transform: scaleY(0.5)}上面这个方案比较成熟的相对单位em : 是根据父节点font-size为相对单位rem : 是根据html的font-size为相对单位 em在多层嵌套下，变得非常难以维护rem更加能成为全局统一设置的度量实例remrem基值设置多少好？回归我们的目的：为了适应手机的屏幕rem = screen.width / 20;——————————————默认html {font-size:32px}iphone 6设备的宽度最少为375的时候@media (min-device-width: 375px) { html { font-size:37.5px}}iphone 6 plus@media (min-device-width: 414px) { html { font-size:41.4px;}}换算公式如iphone5上的rem基值为32px，渲染一张6464px的div，则用2rem2rem去渲染。换算公式非常简单：width：px/rem基值height：px/rem基值多行文本溢出//单行文本溢出….inaline { overflow: hidden; white-space: nowrap; text-overflow: ellipsis;}//多行文本溢出….intwoline { display: -webkit-box ! important; overflow: hidden; text-overflow: ellipsis; word-break: break-all; -webkit-box-orient: vertical; -webkit-line-clamp: 2; }媒体查询5.23@media screen and (max-width:1024px)常用媒体查询参数：width —— 视口宽高height ——device-width 设备的宽度device-height 设备的高度orientation： 检测设备处于横向(landscape)还是竖屏 (portrait)媒体类型screen(屏幕)print(打印机)handheld(手持设备)all(通用)flex 属性 代替 弹性盒模型章节5.20justify-content: center; /子元素水平居中/align-items: center; /子元素垂直居中/display: -webkit-flex;flex-direction:row; /default/ 方向 默认:row-reverse; /default/ 反方向:column; 纵向:column-reverse;flex-wrap:nowrap; 默认flex-wrap:nowrap; }display:-webkit-flex; &lt; 这个例子父容器虽然是400 里面内容撑出也不换行width:400px; } :wrap 正常:wrap-reverse 反方向flex-flow:flex-direction flex-wrap; z自己体会 上面的结合justify-content:flex-start; 效果通 float：left:flex-end 效果同 float: right:center 水平居中:space-between 两边对其:space-around 按间距去划分align-self 父元素用:flex-start; 头部:flex-end; 底部:center; 居中:auto; 默认:baseline 字体什么位置:stretch; 填充满？align-items: 子元素用:flex-start 全部上:flex-end 下:center 居中:baseline:stretchalign-content:flex-start 不会像 align-items 切分高度:flex-end:center:space-between 上下两边:space-around 等比划分:stretch 默认 填充好整个容器addEventListener 事件5.19function addEnd (obj,fn) { obj.addEventListener(‘webkitAnimationEnd’,fn,false);}document.getElementById(‘box’).onclick = function(){ this.className = ‘box move’; addEnd(this,fn)}function fn () { alert( ‘e’ )}@-webkit-keyframes move 动画5.18_animation:move 5s 1s ease-in 5 _animation:2s move必要属性 -animation-name 动画名称(关键帧名称) -animation-duration 动画持续时间例子 animation-play-state 播放状态 (running 播放 和 paused 暂停)可选属性animation-timing-function -linear 均速 -ease 缓冲 -ease-in 由慢到快 -ease-out 由快到慢 -ease-in-out 由慢到快再到慢 -cubic-bezier (1,1,1,1) [0-1]可选属性2animation-delay 动画延迟 -只是第一次animation-iteration-count 重复次数 -infinite 为无限次animation-direction 播放前重置 -动画是否重置后再开始播放 -alternate 动画直接从上一次停止的位置开始执行 -normal 动画第二次直接跳到0%的状态开始执行css3.0-3d变换-15.17transform-style(preserve-3d)建立3D空间perspective:100px景深perspective-origin景深基点backface-visibility隐藏背面Transform 新增函数 ·rotateX() ·rotateY() ·rotateZ() ·translateZ() ·scaleZ()matrix(a,b,c,d,e,f)矩阵5.17filter:progid:DXImageTransform.Microsoft.Matrix(M11=1,M12=0,M21=0,M22=1,SizingMethod=’auto expand’);m11 == a , m12 == c, m21 == b , m22 == dtransform5.17后写的先执行transform:rotate(20deg) skewX(20deg) scaleX(20px); ·rotate() 旋转函数 取值度数 -deg 度数 -Transform-origin 旋转的基点 放到未变化元素上 最多估计是两个参数 rotateX rotateY rotateZ 还有z轴 ·skew()倾斜度数 取值度数 -skewX() -skewY() transform:skewX(deg) transform:skew(deg,deg) ·scale()缩放函数 取值 正数、小数 -scaleX() -scaleY() ·translate()位移函数 -translateX() -translateY() transform:translateX(px) transform:translate(px,px)这里有个钟表 以后可以复习下 妙味云课堂-钟表效果-4扇形导航 妙味云课堂-扇形导航 赶紧学点不知道的 这些案例可以闲下来弄transitionend事件5.16_function addEnd(obj,fn) { obj.addEventListener(‘WebkitTransitionEnd’,fn,false); obj.addEventListener(‘transitionend’,fn,false);}function removeEnd(obj,fn) { obj.removeEventListener(‘WebkitTransitionEnd’,fn,false); obj.removeEventListener(‘transitionend’,fn,false);}addEnd(oBox,function(){ 美执行完一个transition就会触发 这个函数 oBox代表当前有tran元素 this.style.width = this.offsetWidth+100+”px” removeEnd(this,addEnd)})oBox.onclick = function (){ }_transition过渡5.16属性ease： (逐渐变慢)默认值linear： 匀速ease-in：加速ease-out：减速ease-in-out：先加速后减速cubic-bezier 贝塞尔曲线(x1,y1,x2,y2)新增ui样式35.15径向渐变radial-gradient:[起点|| left(数值) || 大小 || 形状]&lt;点&gt;,&lt;点&gt;background:-webkit-radial-gradient(farthest-corner,red,blue)形状：ellipse椭圆、circle圆大小：具体数值或百分比，也可以是关键字(最近端closest-side，最近角closest-corner，最远端farthest-side，最远角farthest-corner，包含contain或覆盖cover)(closest-side,closest-corner,farthest-side,farthest-corner,contain or cover); -注意firefox目前只支持关键字背景尺寸_background-size:x y _ -background-size:100% 100%; -Cover 放大 -Contain 缩小background-origin: border|padding|content ·border-box: 从border区域开始显示背景。 ·padding-box: 从padding区域开始显示背景。 ·content-box: 从content区域开始显示背景background-clip 背景裁切 这里用到一个ip开机解锁哪里的一个动画，很简单不会的话可以到本节28分钟 ·border: 从border区域向外裁剪背景 ·padding: 从padding区域向外裁剪背景 ·content: 从content(内容)区域向外裁剪背景 ·no-clip: 从border区域向外裁剪背景 ·text : 从text区域向外裁剪背景_遮罩_ 就是添加一个png图片作为遮罩Mask-imageMask-positionMask-repeat 新增ui样式25.15边框颜色border-colors:red bule syellow 多种边框颜色 兼容不是很好线性渐变属于background-image:的linear-gradient([&lt;起点&gt;||&lt;角度&gt;,]?&lt;点&gt;,&lt;点&gt;…);linear-gradient(30deg,blue 20px,red 50%);只能用在背景上 -IE filer:progid:DXImageTransform.Microsoft.gradient(startColorstr=’#FFFFFF’,endColorstr=’#ff0000’,GradientType=’1’);参数 -起点：从什么方向开始渐变 默认top top right bottom left -角度：从什么角度开始渐变 xxx deg的形式 -点：渐变点的颜色和位置 black 50%，位置可选 50%代表范围吧repeating-linear-gradient(60deg,red 0,blue 30px) 平铺新增ui样式1 box-radius 还不是很熟悉 今天就到这里5.13 box-radius100px/200px 前边x轴半径 后边y轴半径响应式布局&lt; link rel=”stylesheet” type=”text/css” href=”css.css” media=”srceen and (min-width:800px)”&gt;&lt; link rel=”stylesheet” type=”text/css” href=”css.css” media=”all and (orientation:portrait)”&gt; 竖屏&lt; link rel=”stylesheet” type=”text/css” href=”css.css” media=”all and (orientation:landscape)”&gt; 横屏 border-img:url 0 10 0代表上下 10代表左右 ·border-image-sourceg 引用图片 ·border-image-slice 切割图片 单位没有px ·border-image-width 边框宽度 ·border-image-repeat 图片的排序方式 - round平铺，repeat重复，stretch 拉伸 border-left-width:10px; _style 里面写 _@media screen and (min-width:400px) and (max-width:500px) {} @import url(‘indexc.css’) srceen and (min-width:400px) and (max-width:800px);分栏布局column-width 栏目宽度column-count 栏目列数column-gap 栏目距离column-rule 栏目间隔线盒阴影box-shadow: [inset] x y blur [spread] colorinset 内阴影blue 模糊半径spread 扩展阴影半径 先扩展原有形状，再开始画阴影box-reflect:方向 距离 渐变(可选)倒影direction 方向 above|below|left|right距离渐变(可选) -linear-gradient(left,red 0,blue 100%) 线性渐变resize 自由缩放 添加后盒子就可以自由伸缩 ·Both 水平垂直都可以缩放 ·Horizontal 只有水平方向可以缩放 ·Vertical 只有垂直方向可以缩放 注意：一定要配合overflow：auto一块使用 只有水平方向可以伸缩box-sizing:[box]content-box 标准盒模型width/height = border+padding+contentborder-box 怪异width/height = content弹性盒模型 放到父级使用display:box || inline-box; display:-webkit-box 老的写法，而且兼容性不够好，需要用前缀。 慕课网看到的：-webkit-flex 父级设置 子元素fiex：1Box-orient定义盒模型的布局方向 ·Horizontal 水平显示 ·vertical 垂直显示Box-direction 元素排列顺序 ·Normal 正序 ·Reverse 反序Box-ordinal-group 设置元素的位置box-flex 定义弹性空间 公式 子元素尺寸=盒尺寸子元素的box-flex属性值/所有子元素的box-flex属性值的和box-pack 对盒子富裕的空间进行管理 ·Star 所有子元素在盒子左侧显示，富裕空间在右侧 ·End 所有子元素在盒子右侧显示，富裕空间在左侧 ·Center 所有子元素居中 ·Justify 富裕空间在子元素之间平均分布box-align 在垂直方向上对元素的位置进行管理 ·Star 所有元素在顶 ·End 所有子元素在底 ·Center 所有子元素居中文本属性text-shadow x y mohu color 文字阴影text-stroke x color 描边Direction 定义文字排序方式(全兼容) 兼容IE6Rtl 从右向左排序Ltr 从左向右排序注意要配合unicode-bidi 一起使用Text-overflow 两个值 clip 无省略号 Ellipsis 省略号white-space:nowrap; 不要超出换行overflow:hidden;Text-overflow:Ellipsis 自定义字体转换文字格式生成兼容代码 http://www.fontsquirrel.com/fontface/generator@font-face { font-family: ‘FontName’; src: url(‘FileName.eot’); src: url(‘FileName.eot?#iefix’) format(‘embedded-opentype’), url(‘FileName.woff’) format(‘woff’), url(‘FileName.ttf’) format(‘truetype’), url(‘FileName.svg#FontName’) format(‘svg’); font-style: normal; font-weight: normal;}b伪类选择div:target {display: block;background: red;}target 控制哈希值 锚机那个东西 控制表单很有用enabled 可以点击状态表单控件disabled 不可编辑状态checked 控制 type=checkbox || radio 的选中样式给radio用相同name 就可以成为单选框 文本新增伪类E:first-line 文本第一行E:first-letter 第一个文字 伪元素E::selection 表示E元素在用户选中文字时 选中文字的时候样式 这个牛E::before 生成元素之前E::after 生成元素之后::after {content:”苗圩”; display:block;border:1px solid red;}E:not(.h2) 排除某一项选择器 属性选择器p[属性名=’属性值’]p[miaov~=’ds’]{background: red;}p[attr~=’value’] 词组中有valuep[attr^=’value’] value开头p[attr$=’value’] value结尾p[attr=’value’] 只要包含了valuep[attr|=’value’] 横岗开始 或者单纯value b-leo结构选择器p:nth-child(1){bakcground: red;} 表示P父元素中的第几个节点p:nth-child(odd) {} 奇数行p:nth-child(even) {} 偶数行p:nth-child(n) {} n代表从1到正无穷大一个整数 2n 20开始到2正无穷大 nth-last-child()从后往前数p:nth-of-type(1){background: red;} 这个的话 值查找P父级元素下的 P 也就是整合到一个集合 其他东西不管p:first-child 也就是直接第一个p:last-child 最后一个p:first-of-type 第一个 元素的第一个节点必须是Pp:last-of-type 最后一个 *p:empty{background:red;} 是否为空标签p:only-of-type 表示p元素中只有一个子节点，且这个唯一的子节点类型必须是p。注意：子节点不包含文本节点_这样听就很难理解 我的理解就是 一个父元素下不能有一样的节点 p :only-of-type_p:only-child 表示p元素只有一个子节点。注意子节点不包含文本节点 html5 重要的html5 clearInterval() setInterval()canvas25.03canvas25.03绘制圆arc(x,y,半径,起始弧度,结束弧度,旋转弧度) -x,y:起始位置 -弧度与角度的关系：弧度=角度Math.PI/180 -旋转方向：顺时针(false) 逆时针(true) -例子：canvas时钟.html 绘制其他曲线*arcTo(x1,y1,x2,y2) -第一组坐标、第二组坐标、半径_例context.beginPath();context.moveTo(100,200);context.arcTo(100,50,200,150,50);context.stroke();_quadraticCurveTo(dx,dy,x1,y1) -贝塞尔曲线：第一组控制点、第二组结束点_例 虽然例子要不了这么多 但是自己玩玩context.beginPath();context.moveTo(100,200);context.quadraticCurveTo(100,100,200,100);context.stroke(); context.beginPath();context.moveTo(100,200);context.quadraticCurveTo(200,200,200,100);context.stroke(); context.beginPath();context.moveTo(100,200);context.lineTo(200,100);context.stroke();_bezierCurveTo(dx1,dy1,dx2,dy2,x1,y1) -贝塞尔曲线：第一控制点、第二控制点、第三组结束坐标_例context.beginPath();context.moveTo(100,200);context.bezierCurveTo(100,100,200,200,200,100);context.stroke();_canvas 分开写 不然看着木乱5.03边界绘制lineJoin:边界点连接点样式 -miter(默认)、round(圆角)、bevel(斜角)_例：context.lineJoin = ‘round’;_lineCap :端点样式 一条直线的两个端点 -butt(默认)、round(圆角)、square(高度多出为宽一半的值)_例：绘制直线后才可context.lineCap = ‘round’context.lineCap = ‘square’ 当前宽度一半_绘制路径 类似ps钢笔beginPath：开始绘制路径_例：context.beginPath()_closePath：结束绘制路径 这个是闭合啊_例：context.closePath(); 这个是闭合啊_moveTo:移动到绘制的新目标点_例：context.moveTo(100,100);_lineTo：新的目标点_例：context.lineTo(100,100);_绘制路径—2stroke()：画线，默认黑色fill()：填充，默认黑色rect():矩形区域clearRect()：删除一个画布的矩形区域_例context.clearRect(0,0,oc.width,oc.height);_save()：保存路径restore()：恢复路径_例context.save(); context.fillStyle = &apos;red&apos;; context.beginPath();/*开始*/ context.rect(20.5,20.5,100,100); context.lineWidth = 1; context.fill() context.restore() context.beginPath();/不会受到影响/ context.rect(20.5,140.5,100,100);context.lineWidth = 1; context.fill()_ 直接可以用鼠标进行绘画案例 挺简单var oc = document.getElementById(‘cOne’); context = oc.getContext(‘2d’); /目前支持2d 还有个webgl：制作３ｄ绘图 兼容很大问题/ oc.onmousedown = function(ev){var ev = ev || window.event context.beginPath(); context.moveTo(ev.clientX-oc.offsetLeft,ev.clientY-oc.offsetTop); document.onmousemove = function(ev){ console.log(ev.clientX-oc.offsetLeft,ev.clientY-oc.offsetTop) var ev = ev || window.event; context.lineTo(ev.clientX-oc.offsetLeft,ev.clientY-oc.offsetTop); context.stroke(); } }document.onmouseup = function(){ document.onmousemove = null; document.onmouseUp = null; } _方块运动var oc = document.getElementById(‘cOne’);context = oc.getContext(‘2d’); /目前支持2d 还有个webgl：制作３ｄ绘图 兼容很大问题/var num = 0;context.fillRect(0,0,100,100);setInterval(function(){ num++; context.clearRect(0,0,oc.width,oc.height); context.fillRect(num,num,100,100);},30)_canvas5.03默认大小 300150px 创建好getContext(‘2d’)对象后就可以来绘图了绘制方块 分为了两个方法 和边框 写的先后顺序不同 则先覆盖后fillRect(L,T,W,H) 默认的颜色是黑色_例：context.fillRect(50,50,100,100)_strokeRect(L,T,W,H) 带边框的方块-默认一像素黑色边框，显示出来的不一样原因 _例：context.strokeRect(50,50,100,100) 这样的话实际为2像素context.strokeRect(50.5,50.5,100,100) 这样的话实际为2像素_设置绘图fillStyle： 填充颜色(绘制canvas是有顺序的)_例：可以影响两个 要是只想用到一个什么必须用到save 保存路径 restrore 恢复路径context.fillStyle = ‘red’;_lineWidth： 线绘制，是一个数值_例：context.lineWidth = 10;_strokeStyle： 边线绘制 颜色_例：context.strokeStyle = ‘blue’;_ 火狐下无法拖拽 必须设置dataTransfer对象的setData方法才可以拖拽除图片外的其他标签 dataTranSfer出现在event对象下的 setData();设置数据key和value(必须是字符串) getData();获取数据，根据key值，获取对应的value ev.dataTransfer.setData(‘name’,’hello’)设置键值对 ev.dataTransfer.getData(‘name’)获取设置好的name值 配合拖拽可以完成一个删除功能 dataTransfer对象属性 effectAllowed -effectAllowed：设置光标样式(none,copy,copyLink,copyMove,link,linkMove,move,all和uninitialized) 光标样式属性 里面值 各代表不同样式 setDragImage() - 三个参数：指定元素，X ，Y *改变当前拖拽元素* files - 获取外部拖拽的文件，返回一个filesList列表 - filesList下有个type属性，返回文件的类型 讲到了拖拽事件 很实用啊 用到了可以复习5.02拖放操作1历史管理4.22onhashchange : 改变hash值来管理history ： -服务器下运行 -pushState ：三个参数：数据 标题(都没实现) 地址(可选) -popstate事件 ： 读取数据 event.state -注意： 网址是虚假的，需要服务器指定对应页面，不然刷新找不到页面延迟加载JS4.22JS的加载会影响后面的内容加载 –defer 延迟到onload前执行 内联无意义 –async 异步加载 加载完就触发 有顺序问题Labjs 异步加载js库data 自定义数据4.22dataset - data-name: dataset.name - data-name-first: dataset.nameFirst data数据在jquery mobile 在有重要作用 如果以前想获取一组自定义属性 小心的使用getAttribute JSON的新方法4.22parse() : 吧字符串串成json 只能解释json形式的字符串变为js - 字符串中的属性要严格的加上引号 _var str = ‘{ “name” : “hello” }’var json = JSON.parse(str);alert( json.name )_ 有兼容问题 要去 json官网 下载 json2.js stringify() : 吧json转化成字符串 - 会自动的把双引号加上 var str = ‘{ name : “hello” }’var json = JSON.stringify(str);alert( json ) 新方法与eval的区别妙味搜索 对象引用eval原来是将字符串转换为 js语句的html5新的选择器4.22新的选择器querySelector //类似于jq的 $querySelectorAllgetElementsByClassName获取class列表属性classList 获得class 集合 - length : class的长度 *这都是上面的方法* - add() : 添加class方法 - remove() : 删除class方法 - toggle() : 切换class方法 html5表单验证反馈4.21validity 对象 ，通过下面的valid可以查看验证是否通过，如果八种验证都通过返回true，一种验证失败返回false oText.addEventListener(“invalid”,fn1,false); ev.preventDefault() 阻止默认事件 valueMissing : 输入值为空时 输入值为空返回true typeMismatch: 控件值与预期类型不匹配 输入类型和要求类型不一致返回true patternMismatch : 输入值不满pattern正则 输入值是否满足正则要求不一致 返回true tooLong : 超过maxLnegth最大限制 rangeUnderflow : 验证的range最小值 stepMismatch: 验证range的当前值是否符合min、max及step的规则 customError 不符合自定义验证》setCustomValidity() ; 自定义验证 formnovalidate 直接取消表单验证_ var oText = document.getElementById(‘name’); Otext.addEventListener(‘invalid’,fn1,false); function fn1(){alert(this.validity.valid) 当前事件是否通过 ev.preventDefault() 阻止默认事件 }_* var oText = document.getElementById(‘name’); Otext.addEventListener(‘invalid’,fn1,false); oText.oninput = function (){if(this.value == &apos;1&apos;) { this.setCustomValidity(&apos;请不要输入敏感词&apos;) } } function fn1(){alert(this.validity.valid) 当前事件是否通过 ev.preventDefault() 阻止默认事件 }html5语义化兼容4.21document.createElement(‘leo’); input 新增表单控件和属性type :email : 邮箱tel : 移动端会变为一个数字输入键盘url : 网址 search : 搜索 后面有个×range : 数值选择器 ：_属性 step=”2” 一次跳两步 min=”0” max=”10” value当前值_ 新的输入形控件_2*number : 只能包含数字的输入框color : 颜色选择器datetime : 显示完整日期datetime-local : 显示完整日期，不含时区time : 显示时间，不含时区date : 显示日期week : 显示周month : 显示月新的表单特性和函数placeholder : 输入框提示信息autocomplete : 是否保存用户输入值默认为no,关闭提示选择off autofocus : 指定表单获取输入焦点 自动聚焦list 和 datalist : 为输入框造一个选择列表 list值为datalist 标签的idrequired : 此项必填 ， 不能为空pattern : 正则验证 pattern = “\d{1,5}”Formaction 在submit 里定义提交地址 又增加一个提交地址 可以的。。maxlength 限制表单输入最大值 imooc-why 重要的项目地址：响应式布局,慕课网教程 这个估计是我所有东西的启蒙网站了，很值得留念 为方便后续使用网址，在这里收集下123456789.ico 在线转换 网址 http://www.bitbug.nethumans官方网址 http://www.humanstxt.org.cn.editorconfig http://editorconfig.orgmarkdown http://dillinger.io 很好的一个参考网站 http://www.jianshu.com/p/375bd2057d18最新浏览器升级 http://browsehappy.comHTML5 大纲生成页面 https://gsnedders.html5.org/outliner/Normalize (NO 么赖似) https://necolas.github.io/normalize.csscss3自动增加前缀 http://autoprefixer.github.ioOwlCarousel2 轮播插件（O 凯弱塞奥2）官方http://owlcarousel2.github.io/OwlCarousel2/ 开始robots.txt 机器人 搜索引擎查看网站,第一个访问的文件。告诉我们的爬虫服务器上什么文件，被查看，什么文件不能被查看*12Disallow: /admin/此例子告诉搜索引擎都可以去访问,除了admin文件下的内容，每种不同的 搜索引擎都会有自己不一样的设置 一些流氓的搜索引擎会无视次文件，毕竟这只是相关行业的约定，你不遵守，也没办法favicon.ico 可以通过一些在线的网站进行转换，比如http://www.bitbug.nethumans.txt 人类 就是一个单纯的文本文件，用来保存网站的建设者，和一些其他有用的信息，可以快速的了解网站背后的团队信息，开发人员信息，和他们的一些故事等等，也就是“机器人”是给搜索引擎、机器看的，humans是给我们人看的 官方网站http://www.humanstxt.org.cn 可以了解到，写法，想怎么写就怎么写，官网有参考范例.editorconfig 是用于统一代码解决方案的文件。很多项目都有用到 官网http://editorconfig.org 官网有相关规则，还有支持的IDEeditorconfig.org123456789101112131415161718# ; 注释 单独占用一行 一般使用## root = true 表示这是最顶层的配置文件，发现root=true的话 就不会再继续查找editorconfig文件了root = true# 一般看到*都知道是通配符 *代表所有文件，*.js 代表js文件[*]charset = utf-8indent_size = 4# indent_size = 4 4代表空格数 每次缩进的数 当然也可以设置为tab# indent_size = tab 那么我们接下来会设置一个 tab的宽 tab-width = 多少 一般来说呢，我们都通过空格来进行缩进indent_style = space# indent_style = space 空格缩进 tab在各种编辑器宽度解释各有不同，为了保证代码排版看起来一致。建议都使用空格insert_final_newline = true# insert_final_newline = true 每一个文件 用空格行结尾trim_trailing_whitespace = true# trim_trailing_whitespace = true 去除换行行首的任意字符[*.md]trim_trailing_whitespace = false .gitignore安装呢 使用什么编辑器就在哪里安装，我安装到NPM里面了。。1234567.DS_Store.ideanode_modulesdist这个是github 管理忽略的上传文件 LICENSE.txt 如果项目基于一些许可协议 可以建立这样一个文件，注意这个文件名全部使用了大写README.md 顾名思义呢，就是项目的简介、使用方式、相关链接CHANGELOG.md 看名字也都知道、项目每个版本的更新、说明的版本号、更新内容、修复了哪些问题等以上两个文件都是使用 .md作为后缀， md == markdown 是一种普通的文本编辑器，来编写的一个标记语言，通过一些简单的标记语法呢，就可以让普通的一些文本具有一定的格式，编辑markdown 在线 编辑网站 http://dillinger.io 很好的一个参考网站http://www.jianshu.com/p/375bd2057d18编写代码lang=”zh-CN” 中文简体lang=”zh” 支持更广泛的中文字符，简体，繁体，方言啊等等的(方言是什么鬼)lang=”en” 这样的话 问题也不是很大，但是你安装了google翻译啊什么的 他会自动翻译 还有些针对盲人的朗读软件 如果设置为en 可能就不会正常的工作 可能出现中文字符就跳过了，不读&lt; meta http-equiv=”x-ua-compatible” content=”ie=edge”&gt; x-ua-compatible == IE的兼容性 通过此代码表示在IE下的呈现方式 IE8开始多了个兼容模式 为了在IE8显示不正常，但在老的浏览器下显示正常的一些模式 IE9再往后也会支持这样一个模式 比如我们把 content=”ie=EmulateIE7” 设置成这样代表模仿IE7。x-ua-compatible如果此标签设置不正确的话。就会有几率出现用IE5.5 来渲染， ie=edge 表示强制以最新的IE模式渲染页面注意 : IE11这个文档模式已经弃用了&lt; meta name=”viewport” content=”width=device-width,initial-scale=1”&gt; 设备宽度统一，初始缩放比1 _ &lt; !–[if gt/lt/gte/lte IE 8]&gt;&lt; ![endif]– &gt; _ IE的条件注释1234567891011121314151617lt == 比当前版本低gte == 可以理解为&gt;=lte == 可以理解为&lt;=*IE 8 这里要加空格 老师说后面有讲到*```http://browsehappy.com_IE8不兼容HTML5 媒体查询 如何兼容呢 后面会有提到_*编写基本内容，及HTML5标签语义化详解*```bashnav 导航article (啊提Q) 代表文档啊 页面或者应用程序中独立的完整的一些可以被外部引用的一些内容，怎样理解呢，一般可以是博客里面的一篇文章，一个帖子section (塞克什) 实际使用中呢其实经常会和 article 这样一个元素搞混，区别：section使用范围更广泛，每一个区块都可以去使用，比如页面里面的广告，联系方式，文章里面的章节，只要觉得是个区块就可以使用，一般来说呢元素内容明确出现在文档大纲里section就比较适用，比如说装饰就不用了，但是你是需要出现在文档大纲中，需要让用户看到的，有意义的内容。article 可以看做一个特殊的section，它是section的一个子集对section一个特殊的描述，他比section具有明确的语义，如果你是一个独立的完整的有内容的一个相关的区块，比如说包含一个图文内容的文章，这块确实是言之有物，就可以使用article*怎么理解呢article相比section 他的语义更加的强烈它可以脱离整体，作为一个完整部分的存在，举个例子来说一个广告，你嵌在首页里面有意义，你把它拿出来放到别处没有什么太大的意义，但是一篇文章呢，独立出来和嵌到页面都可以，都有单独的意义，甚至于这篇文章呢你把它放在rss里面去订阅 也可以独立的存在 当然广告不会放在rss里面去作为一个订阅存在*nav 元素呢也是一种特殊的 section 应用在导航里面呢你就一般不会吧导航写成section 而是把导航写成nav 其实article也是一样的 具有更强的语义*如果不太确定就用div (D物)*其他标签的一些语义规定b 吸引人注意，不传达任何比如重要啊，强调啊em 重点强调i 和其他文字 文法和其他文法不同可以使用 编写代码注意： 一般都使用class定义样式，id一般用于js快速的区别和获取元素class，一般都用中横线分割，id一般使用驼峰名称法 class=’main-top’ id=’mainTop’必不可少的图片使用&lt; img&gt; 引入，可有可无的装饰性图片可以使用标签的style引入这是一个 HTML5 大纲生成页面 https://gsnedders.html5.org/outliner/WebStorm 自带了一个生成大纲插件 HTML5 Outlinesection 最高有标题 生成大纲后 吧没有标题的 section 换成 divcss resets VS Normalize.cssresets (锐塞似)Normalize (NO 么赖似) https://necolas.github.io/normalize.csspx,em,rem_px_ 1个px相当于1个像素 _em_ 相对的长度对象，参考物 父元素的font-size 父元素没有的话就找到最接近的font-size为主，页面没有设置font-size的话 1em == 16px rem rem相对参照物为根元素html，相对参照固定不变所以好计算 IE9 里面只要不在font里面简写就没有问题，但是IE8不兼容清除浮动flex 是一种可以替代float布局的方式 IE支持差CSS中有个概念 BFC 块级格式化上下文，简单理解就是 触发了BFC就会闭合浮动 预防高度塌陷 能触发BFC的属性：解决inline-block 间距问题12345678910111213141516171819202122232425262728293031&lt; ul&gt; &lt; li&gt;&lt; a href="#"&gt;登录&lt; /a&gt; &lt; li&gt;&lt; a href="#"&gt;快速注册&lt; /a&gt; &lt; li&gt;&lt; a href="#"&gt;关于&lt; /a&gt; &lt; li&gt;&lt; a href="#"&gt;帮助&lt; /a&gt; &lt; li&gt;&lt; a href="#"&gt;App下载&lt; /a&gt;&lt; /ul&gt; _不加结尾 浏览器会自己加 亲测IE5.5 以上_&lt; ul&gt; &lt; li&gt;&lt; a href="#"&gt;登录&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;快速注册&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;关于&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;帮助&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;App下载&lt; /a&gt;&lt; /li&gt;&lt; /ul&gt; _这种是将 闭合标签添加到下一行 也可以解决_&lt; ul&gt; &lt; li&gt;&lt; a href="#"&gt;登录&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;快速注册&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;关于&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;帮助&lt; /a&gt;&lt; /li&gt;&lt; li&gt;&lt; a href="#"&gt;App下载&lt; /a&gt;&lt; /li&gt;&lt; /ul&gt; _写在一行，有些丑之外，都还不错_父元素设置 font-size:0 ; 子元素设置font-size: * ; 某些情况下也有很多问题，例如老师这个例子就出现了下边距header .top ul li + li &#123; border-left: 1px solid #999; margin-left: -3px;&#125;_通过-3px设置的，也有问题，每个浏览器间距不一样 导致出现差异_*CSS4草案中有这样一个属性：*white-space-collapsing 这个属性可以解决这个设置，但是CSS4啊，。。只能展望未来了 CSS3 calc()calc是CSS3的一个计算方法。动态计算 \00a0\00a0 代表不换行的空格字符a:first-child:before &#123;123 content: &apos;最新公告: \00a0\00a0&apos;; color: #aaa;&#125; 文字不换行- 显示省略号a:first-child &#123;1234 text-overflow: ellipsis; overflow: hidden; white-space: nowrap;&#125; http://autoprefixer.github.io 自动增加前缀用户代理字符串navigator.userAgent 可以通过此代码 显示当前用户代理字符串，当然安全性不好，用处：判断用户当前是安卓，还是IOS 从而给出相应的下载链接媒体查询常用节点800px或者以下 包含800 */12345678910111213141516171819@media only screen and (max-width: 800px) &#123; header .top &#123; background-color: green; &#125;&#125;/* 481和800之间 */@media only screen and (min-width: 481px) and (max-width: 800px) &#123; header .top ul li a &#123; color: red; &#125;&#125;/* 小于等于480像素 */@media only screen and (max-width: 480px) &#123; header .top ul li a &#123; color: blue; &#125;&#125; 媒体查询的单位选择媒体查询 不会根据html font-size大小改变rem大小，也就是说他会按照浏览器的默认1rem == 16pxrem 兼容性不好，而且是根据浏览器大小限制，这里没有优势_em_ 兼容好，根据浏览器字体大小改变，完美_px_ 这种用户改变浏览器默认字体大小，就会出现bugCSS3选择器CSS选择器介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384①：_基本选择器_* 通配符 选择所有元素 或者某个元素下的所有元素E 元素选择器.class 类选择器#id ID选择器E F 后代选择器 也被称作包含选择器E &gt; F 子元素选择器 只能选择某个元素的子元素 不包含孙子元素 或再往后的元素E + F 相邻兄弟选择器 可以选择紧接在另一个元素后的元素 而且他们具有一个相同的父元素 也就是说呢E和F具有一个相同的父元素 而且呢 F在E的后面而且相邻E ~ F 通用元素选择器，也是选择某个元素后的元素，和相邻兄弟选择器非常的像，举个例子&lt; ul&gt; &lt; li&gt;&lt; /li&gt; &lt; li&gt;&lt; /li&gt; &lt; a&gt;&lt; /a&gt; &lt; li&gt;&lt; /li&gt;&lt; /ul&gt;ul li + li 选中了 后面的一个liul li ~ li 选中了 后面所以的li②：_属性选择器_E[attr] a[href] 只要 a 有 href 就都被选择E[attr=&quot;value&quot;] 指定属性名 和属性值 可以不加引号 那就得按规范来 不能以数字啊，两个短横线开头等等E[attr^=&quot;value&quot;] 以value 开头的 a[href ^= &quot;http://&quot;] 都被选中E[attr$=&quot;value&quot;] value 结尾的 img[src$=&apos;.png&apos;]E[attr*=&quot;value&quot;] 只要包含就OK img[src*=&apos;.png&apos;] a[href *= &quot;http://&quot;] 不管在什么位置出现都行E[attr~=&quot;value&quot;] title= &quot;hello world&quot; a[title ~= &quot;world&quot;] 以空格隔开的都可以模糊查询到E[attr|=&quot;value&quot;] 和 ^差不多 但是| 还包含以-开头的 lang=&quot;zh-cn&quot; a[lang|=&quot;zh&quot;]*其中 *= = 最为常用*③：_伪类和伪元素的选择器_:link 链接 :visited 被访问的链接 :hover 鼠标悬浮 :active 被集活 :focus 表单元素变为焦点:enabled 启用禁用被选中的文本框 :disabled checked 被选中的:first-child 某个元素的第一个子元素:last-child 某些元素的最后一个子元素:nth-child() 选中一个或多个特定的子元素 ()内呢 可以写整数值，也可以写表达式：2n n是从0开始 2,4,6 简写的方式even 偶数单词 奇数单词odd 2n+1 或 2n-1:nth-last-child():nth-of-type()*和 :nth-child() 区别对比 ：* &lt; div class=&quot;nth&quot;&gt; &lt; div&gt;1&lt; /div&gt; &lt; p&gt;2&lt; /p&gt; &lt; p&gt;3&lt; /p&gt; &lt; p&gt;4&lt; /p&gt; &lt; p&gt;5&lt; /p&gt; &lt; p&gt;6&lt; /p&gt; &lt; /div&gt;.nth p:nth-child(2) &#123; color: red; 2内容变红 从nth向下找到第二个元素 并且是P&#125;.nth p:nth-of-child(2) &#123; color: blue; 3变蓝 从nth下的子元素 P开始 计算，第二个P&#125;:nth-last-of-type():first-of-type:last-of-type:only-child.nth p:only-child &#123; 当只有一个P的时候 变红 color: red;&#125;:only-of-type 也是一样 不过是找类型:empty 空元素 什么也没有 哪怕一个空格:not().nth :not(p) &#123; 所有不是P的元素 color: red;&#125;_伪元素选择器：比较老的伪元素选择器，css2的时候就已经有了_:first-line 第一行:first-letter 第一个文字:before 前 :after 后_第三个隐藏_ul li:nth-child(3) &#123; display:none&#125; 小屏样式及技巧手机屏幕再小也不会小于 320 PX 轮播图，我们不需要重复的造轮子所以呢 选择一款适合的插件这里用到的：OwlCarousel2 （O 凯弱塞奥2） 升级版本官方网址 http://owlcarousel2.github.io/OwlCarousel2/GitHub https://github.com/OwlCarousel2/OwlCarousel2响应式图片&lt; picture&gt; &lt; source srcset=”images/ad002-l.png” media=”(min-width:50em)”&gt; &lt; source srcset=”images/ad002-m.png” media=”(min-width:30em)”&gt; &lt; source srcset=”images/ad002-m.png” media=”(orientation: landscape)” &gt; 这个表示横屏 &lt; img src=”images/ad002.png”&gt; &lt; /picture&gt; 在线编辑SVG文件 http://editor.method.ac https://icomoon.io polyfill (泡里废奥) 可以吧裂缝填平，兼容性坑填 picturefill (陪个扯儿废由) 这就是picturefill库 http://scottjehl.github.io//picturefill SVG图片压缩 http://iconizr.com PNG JPG..压缩 https://tinypng.com NPM 技巧Node.js使用了一个事件驱动、非阻塞式I/O的模型(非阻塞的读取文件 I/O 读写)Node.js 中文网 http://Nodejs.cnNode.js 官网 http://Nodejs.orgNPM 命令 NPM 网站 https://npmjs.cominstall jquery12345678910111213141516171819202122232425262728293031323334package.json (配K只)_建立 package.json_npm initname: (src) 不能大写 包名version: (1.0.0) 主版本号 副版本号 补丁版本号description: 描述entry point: () 入口文件test command: 测试命令git repository: git上的路径keywords: 关键字author: 作者license: (ISC) 这个包基于什么样的一个协议_packages.json 文件解读_dependencies 这里面所写是 生产环境下的包devDependencies 开发过程所依赖的包_使用packages.json_npm i 简写 npm i --production 下载产品方面依赖的包 npm i --dev 下载开发过程所依赖的包npm install_查看版本_* -v* --version_管理员权限运行_windows 直接右击 管理员权限就行mac os 中sudo npm install gulp_如何更新到packages.json_npm install jquery --save-dev --save 前者是写到devDependencies 后者dependenciesnpm uninstall jquery --save --save-dev 一个道理npm update jquery 更新npm update 更新所有 http-servergithub https://github.com/indexzero/http-server 启动 http-server 根目录 参数 虚拟机 选择github https://github.com/xdissent/ievms 或者微软官方 https://developer.microsoft.com/en-us/microsoft-edge/tools/vms/ 移动端测试手机使用趋势 http://www.umindex.com/安卓设备虚拟机 http://genymotion.net 兼容调试 hack 可以查看到各种浏览器之间的 hack写法 http://browserhacks.com html5Shiv https://github.com/aFarkas/html5Shiv Respond IE6到8不支持CSS3查询 https://github.com/scottjehl/Respond modernizr.js https://modernizr.com 主动性检测兼容问题 防御性编程 兼容问题千千万 使用任何特性之前 到 http://caniuse.com网站查询兼容性 提高效率 当有多个设备时 ， 改完一个样式每个页面都要刷新， 效率低，刚好有这么一个 ，省时的浏览器同步测试工具http://www.browsersync.cnNPM 安装到 全局就可以了sudo npm install -g browser-sync_命令_start 启动服务 后面可以跟两个参数， --server "src" 服务器根目录设置到什么下 --files "src" 监听这个文件夹的所有改动 可以写一些通配符 "**/*.css"1browser-sync start --server &quot;src&quot; --files &quot;src&quot; 打包发布在线网站 https://javascript-minifier.com 在线压缩代码 主流的3个工具 1.Grunt 自动化构建工具2.Gulp 3.Webpack 静态资源打包工具 gulp (告 铺)官网 http://gulpjs.com 中文网 http://gulpjs.com.cn 用到的插件1234567891011121314151617181920212223242526272829303132333435363738gulp-rev 给每个文件计算 哈希码 然后把文件更改掉gulp-rev-replace 文件名改变 index引用则改变gulp-useref 注释 怎样的合并方式gulp-filter 可以把JS文件筛选出来做一些压缩，然后再放回去gulp-uglify 比较出名的 压缩 js代码插件gulp-csso 就是压缩CSS的一个插件--save-dev 肯定是开发过程中使用的_var jsFilter = filter('**/*.js', &#123;restore: true&#125;);__var cssFilter = filter('**/*.css', &#123;restore: true&#125;);__var indexHtmlFilter = filter(['**/*','!**/index.html'], &#123;restore: true&#125;);_这个任务里面声明三个 filter (非由特)然后 return 一个这样的东西 return gulp.src('src/index.html') .pipe(useref()) _分析带有标注的地方 例如 &lt; !-- build:js scripts/combined.js --&gt;_ 这样他就把 这些文件扔到流里面了，这样我们的流就包含这些文件了 .pipe(jsFilter) _接下来该做我们的 filter 处理了，第一个filter就是把我们的JS文件筛选出来_ .pipe(uglify()) _做一个 uglify的操作，也就是做一个压缩的操作_ .pipe(jsFilter.restore) _通过这样在扔回到流里面 jsFilter.restore。接着源代码的流接着往下流_ .pipe(cssFilter) .pipe(csso()) .pipe(cssFilter.restore) .pipe(indexHtmlFilter) _这里['**/*','!**/index.html']可以是一个数组，第一个意思是所有文件，第二个！是排除的意思，为什么排除我们的index呢，因为处理之后首页最好还是叫index。不然你加个版本号，主页就没了。。_ .pipe(rev()) _生成哈希版本号文件名_ .pipe(indexHtmlFilter.restore) _之后呢再恢复_ .pipe(revReplace()) _恢复后呢。我们对index中的引用进行更新_ .pipe(gulp.dest('dist')); _最后呢可以看到这样一个方法dest()这里呢就是结束了，把我们管道里的水(也就是文件流)给扔到这个目录下_*这就是一个典型的gulp任务*可以看到是一系列的 pipe (牌普) 处理 gulp default 这个是默认任务执行 ，当然默认也可以不写 *! 这样的注释在 gulp压缩中 不会被压缩掉 gulp 实现眼花缭乱的功能gulp-watch 监听文件的改版，自动改变，_gulp-postcss _ 可以把 (奥吐普锐菲克斯) 结合，自动给浏览器属性添加一些前缀，也可以对我们的CSS文件进行一些处理gulp-concat 可以把我们的多个文件合并成一个文件gulp-responsibe 这是一个可以实现响应式图片的文件 可以把我们的一个大图片，按照我们的规则 生成一系列的响应式图片，这些过程都是自动化的 这些插件还有很多，我们可以在NPM里面输入gulp- 。 一般来说在一个项目的生命周期中，很少回去改变，属于一个一劳永逸的事情，所以很有必要花些时间写一个完美的gulpfile文件趁手的IDE IDE 简单的来说就是集成开发环境 响应式框架Bootstrap http://getbootstrap.com http://v3.bootcss.comFoundation http://foundation.zurb.com http://www.foundcss.com结构语义化，移动设备优先，完全可以定制Semantic UI http://semantic-ui.com http://semantic-ui-cn.com命名非常的语义化，PureCss http://Purecss.io http://purecss.org非常轻量级 WebStorm svg 没有内容，忘记干什么的了svg CSS 既 html 标签收集CSS 既 html 标签收集 W3C标准(1.1) http://www.w3.org/TR/SVG11浏览器支持情况 http://caniuse.com/#cats=svgie margin-right 有双margin bug display: inline;解决 Node.js收集http://www.nodebeginner.org/index-zh-cn.html#javascript-and-nodejs事件驱动的回调 电商网站收集_ font:italic small-caps bold 12px/1.5em arial,verdana; 等效于：font-style:italic;font-variant:small-caps;font-weight:bold;font-size:12px;line-height:1.5em;font-family:arial,verdana;顺序：font-style | font-variant | font-weight | font-size | line-height | font-family（注：简写时，font-size和line-height只能通过斜杠/组成一个值，不能分开写。）不过使用这种简写需要注意几点：要使简写定义有效必须至少提供 font-size 和 font-family 这两个属性 ；同时font-weight, font-style 以及 font-varient 这几个属性如果不做设定的话将默认为normal。__ &amp; copy; == © gt; == &gt; lt; == &lt;__input的背景需要清楚none _line-height: 35px\9; 所有IE浏览器css hack 好多地方都有提到IE 最小高度20 overflow: hidden解决IE 百分比宽度不精确 可以用 *width:49.9% 类似方案解决都给border-bottom 的话 IE会撑出 margin-bottom : -1px; position:relative;提升层级元素撑到下一个位置的时候 可以考虑设置高度来解决走进svg基本API创建图像documen.createElementNS(ns,tagName);添加图像element.appendChild(childElement)设置/获取属性element.setAttribute(name,value)element.getAttribute(name)rx圆角半径 cx横坐标 &lt; rect &gt;、 x y width height rx ry 这个属性画矩形&lt; circle &gt;、 cx cy r r&lt; ellipse &gt;、 cx cy rx ry 椭圆&lt; line &gt;、 x1 y1 x2 y2 直线&lt; polyline &gt;、 x1,y1 x2,y2 … 折现 points=”x1 y1 x2 y2 x3 y3”&lt; polygon &gt; 多边形 就是讲最后第一个点和 起始点连接基本属性fill、stroke、stroke-width、transform2016.4.19transform: scale(0.3); 这个是放大效果transform-origin: center;transition-delay: 0; 延迟 很有用2016.4.18autoprefixer 一个库lessc –source-map .less .css 绑定文件 更好找到less编译后的csswr –exec “lessc –cource-map .less .css” *.less 当less 更改后执行该命令 –exec有待研究https://www.npmjs.com/package/wr 参考网站 svg 气泡学习*2016.4.15outline css样式（轮廓）是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。article html5标签 &lt; article&gt; 标签规定独立的自包含内容。一篇文章应有其自身的意义，应该有可能独立于站点的其余部分对其进行分发。&lt; article&gt; 元素的潜在来源：论坛帖子报纸文章博客条目用户评论*section &lt; section &gt; 标签定义文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 CSScss置顶不知道的属性letter-spacingword-spacingvertical-alignvertical-align家族基本认识5.31inherit 继承1。线类 baseline,top,middle,bottom2.文本类 text-top,text-bottom3。上标下标类 sub,super4.数值百分比类 //IE6/7 不支持小数行高 20px,2em,20% Mysql笔记mysql笔记 ob_clean 清除输出图片前的空格[client] [mysqld]下添加default-character-set=utf851.// print_r(mysql_fetch_row($result)); //速度最快// print_r(mysql_fetch_assoc($result));// echo mysql_field_name($result, 3);// mysql_field_name — 取得结果中指定字段的字段名// echo mysql_num_fields($result);// mysql_num_fields — 取得结果集中字段的数目/* * mysql_get_client_info — 取得 MySQL 客户端信息 * mysql_get_host_info — 取得 MySQL 主机信息 * mysql_get_proto_info — 取得 MySQL 协议信息 * mysql_get_server_info — 取得 MySQL 服务器信息 */ mysql_num_fields($result);//字段数目 mysql_num_rows($result);//行数目 *很多优化语句* 50.require ‘50Demo.php’; //大概就是将其他PHP建立连接吧(可以调用函数之类的)/ //新增数据 $query = ‘INSERT INTO user(name,email,point,regdate) VALUE (“王大大”,”2358@163.com“,”150”,NOW())’; mysql_query($query); / / //删除修改 $query = ‘UPDATE user SET name=”王” WHERE id=”4” ‘; mysql_query($query); / / //显示数据 $query = ‘SELECT id,name,email,point,regdate FROM user’; $result = mysql_query($query); while ($row = mysql_fetch_array($result)) { echo $row[0],$row[1],$row[2],$row[3].’‘; } / 47，48，49. 这章包含了很多知识点mysql_connect — 打开一个到 MySQL 服务器的连接mysql_query(‘SET NAMES UTF8’); //设置字符集mysql_select_db — 选择 MySQL 数据库mysql_query — 发送一条 MySQL 查询 //就是执行mysql语句mysql_fetch_array — 从结果集中取得一行作为关联数组，或数字数组，或二者兼有mysql_free_result — 释放结果内存mysql_close — 关闭 MySQL 连接46. / WHERE 表达式的常用运算符 MYSQL运算符 含义 = 等于 &lt; 小于 大于 &lt;= 小于或等于 = 大于或等于 != 不等于 IS NOT NULL 具有一个值 IS NULL 没有值 BETWEEN 在范围内 NOT BETWEEN 不再范围内 IN() 指定的范围 OR 两个条件语句之一为真 AND 两个条件语句都为真 NOT 条件语句不为真 LIKE 筛选*/ /* SELECT FROM user WHERE email LIKE ‘%163.COM’; %代表任意 筛选出163.com结尾的 SELECT * FROM user WHERE email LIKE 3; //一个参数代表显示前3条 SELECT FROM user WHERE email LIKE 2,3;* //代表从3开始显示3个 SELECT * FROM user OREDR BY regdte DESC; regdte按照这个进行倒叙 SELECT AVG(point) AS ‘平均值’ FROM user; 算出平均值 // SELECT AVG(point) AS ‘平均值’ FROM user; 算出平均值 MYSQL分组函数 函数 用法 描述 AVG() AVG(column) 返回列的平均值 COUNT() COUNT(column) 统计行数 (NULL统计不到) MAX() 求列的最大值 MIN() 求列的最小值 SUM() 求列中的和//**检查这个表的信息 SHOW TABLE STATUS\G 优化一张表 OPTIMIZE TABLE grade;/ 为什么表格式为iatin1_swedish_ci45./ 创建一个数据库，表grade内容ID,姓名NAME,邮件email,评分 point,注册日期regdate *UNSIGNED 表示无符号，TINYINT(2) 无符号整数0-99,NOT NULL 表示不能为空,AUTO_INCREMENT表示从1开始每增加一个字段，累加一位* // CREATE TABLE USER( 设置主键 自动递增 ID TINYINT(2) UNSIGNED NOT NULL AUTO_INCREMENT, NAME VARCHAR(3) NOT NULL, EMAIL VARCHAR(40), POINT TINYINT(3) UNSIGNED NOT NULL PRIMARY KEY(ID) 设置主键 让ID唯一不得重复/ 遗留问题 如何删除字段 添加指定字段44./ Mysql 常用函数 文本函数 函数 用法 描述 大致写法 CONCAT() CONCAT(X,Y,…) 创建形如xy的新字符串 CONCAT(‘lee’,’ee’) leeee LENGTH() LENGTH(column) 返回列中储存的值长度 LEFT() LEFT(column,x) 从列的值中返回最左边的X个字符 RIGHT() RIGHT(column,x) 从列的值中返回最右边的X个字符 TRIM() TRIM(column) 从存储的值删除开头和结尾的空格 UPPER() UPPER(column) 吧存储的字符串全部大写 LOWER() LOWER(column) 吧存储的字符串全部小写 SUBSTRING() SUBSTRING(column,start,length) 从column中返回开始start的length个字符(索引从0开始) MD5() MD5(column) 吧存储的字符串用MD5加密 SHA() SHA(column) 吧存储的字符串用SHA加密 数字函数 有很多数字函数 这里只列举几个 可以到这章看 四舍五入 最大整数 最小整数 绝对值 日期和时间函数 HOUR() 返回存储日期的小时值 SELECT HOUR(NOW()); 格式化日期和时间DATE_FORMAT() 和 TIME_FORMT() 名词 用法 示例 %e 一月中某一天 1~31 %d 一月中的某天，两位 01~31 %D 带后缀的天 1st~31st %W 周日名称 Sunday~Saturday 还有很多 就不一一列举了 格式化的比上面更细腻 SELECT DATE_FORMAT(NOW(),’%e’)/43.对应章节43Demo2.PHP// Mysql 数据库操作/ 显示当前存在的数据库 SHOW DATABASES; 2选择你所需要的数据库 USE guet; 3查看当前所选择的数据库 SELECT DATABASE(); 4查看一张表的所有内容 SELECT FROM guest //可以先通过SHOW TABLES*来查看有多少张表 SHOW TABLES; 5根据数据库设置中文编码 SET NAMES gbk //set names utf8 6创建一个数据库 首先打开 SHOW DATABASES打开所有数据库看 CREATE DATABASE book; 7在数据库里创建一张表 *CREATE TABLE uses( username VARCHAR(20) ,//NOT NULL,这样的话 就不能为空 没有数据就出错 sex CHAR(1) , //性别 birth DATETIME);* //注册日期 8 显示数据表结构**DESCRIBE uses; 简写形式 DESC USES; 那不早说 Field Type NULL KEY Default Extra user varchar(20) YES NULL 字段名 类型 可以为空 主键未设置 默认值没有 额外的没有 no-replat9 显示表的结构 &gt; INSERT INTO uses (username,sex,birth) VALUES (‘Lee’,’x’,’NOW()’);NOW() 是Mysql 自带的时间 仅显示 字段名呢 没看懂 SELECT username FROM uses; 10 筛选指定的数据*SELECT FROM uses WHERE sex=’0’; 11 删除数据 DELETE FROM user WHERE sex=’0’; 12修改指定数据 UPDATE uses SET sex=’男’ WHERE USERNAME=’LEE’; 13按指定的数据库排序 SELECT FROM uses ORDER BY birth DESC;* //正序 ASC// 正序 14删除指定的表 DROP TABLE uses; 15删除指定的数据库 DROP DATABASE book;// SELECT 应该是查看 挑选 SHOW 叫显示 显示 USE 选择你想要的数据库 使用 DATABASE()函数 DATABASES命令 数据库 代表所有字段 SELECT FROM guest Empty set (0.00sec) 这是一张空表 /43./ 日期型 列类型 ‘零’值 DATETIME ‘0000-00-00 00:00:00’ DATE ‘0000-00-00’ TIMESTAMP 000000000000000 TIME ‘00:00:00’ YEAR 0000 字符串型 值 CHAR(4) 存储需求 VARCHAR(4) 存储要求 ‘’ ‘ ‘ 4个字节 ‘’ 1个字节 ‘ab’ ‘ab ‘ 4个字节 ‘ab’ 3个字节 ‘abcd’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 ‘abcdefgh’ ‘abcd’ 4个字节 ‘abcd’ 5个字节 如果采用CHAR类型： 那么就存放4个字节 空格也算字符 CHAR 定长类型 VARCHAR 类型 会将后面的空格删掉； VARCHAR 可变长度类型 自己本身长度+1 备注型：自己本身+1 类型 描述 TINYTEXT 字符串，最大长度255个字符 TEXT 字符串，最大长度65535个字符 MEDIUMTEXT 字符串，最大长度16777215个字符 LONGTEXT 字符串，最大长度4294967295个字符 text 比较常用 用于备注，大文章，帖子，新闻 CHAR 一般用于密码 性别 加密之后永远是32 || 40 VARCHAR 用于标题 整数型 类型 字节 最小值 最大值 (带符号的/无符号的) (带符号的/无符号的) TINYINT 1 -128 127 0 255 SMALLINT 2 -32768 32767 0 65535 MEDIUMINT 3 -8388608 8388607 0 16777215 INI 4 -2147483648 2147483647 0 4294967295 BIGINT 8 -9223372036854775808 9223372036854775807 0 18446744073709551615 整数型 类型 字节 最小值 最大值 FLOAT 4 +-1.175494351E-38 +-3.402823466E+38 DOUBLE 8 +-2.2250738585072014E-308 +-1.7976931348623157E+308 DECIMAL 可变 它的取值范围可变/42./ Mysql 常用命令 1显示当前数据库的版本号和日期 SELECT VERSION(); CURRENT_DATE(); 2通过AS关键字设置字段名 SELECT VERSION() AS version; // 可设置中文，通过单引号 3通过SELECT执行返回计算结果 SELECT (20+5)*4 AS ‘结果’; 4 通过多行实现数据库的使用者和日期 SELECT USER(),NOW(); //一行显示 SELECT USER(); 使用者 SELECT NOW(); 5 通过一行显示数据库使用者和日期 SELECT USER() , SELECT NOW(); 6 命令取消 \c 7 MySql 窗口退出 exit; ctrl+C quit MySql 常用数据类型 整数型：TINYINT, SMALLINT , INT, BIGINT 浮点型：FLOAT , DOUBLE, DECIMAL(M,D) 日期型：CHAR, VARCHAR 备注型：TINYTEXT, TEXT , LONGTEXT */原文：http://www.2cto.com/database/201108/101151.html MySQL会出现中文乱码的原因不外乎下列几点：1.server本身设定问题，例如还停留在latin12.table的语系设定问题(包含character与collation)3.客户端程式(例如php)的连线语系设定问题强烈建议使用utf8!!!!utf8可以兼容世界上所有字符!!!!一、避免创建数据库及表出现中文乱码和查看编码方法1、创建数据库的时候： [sql] view plain copyCREATE DATABASE testDEFAULT CHARACTER SET ‘utf8’COLLATE ‘utf8_general_ci’;2、建表的时候[sql] view plain copyCREATE TABLE database_user (ID varchar(40) NOT NULL default ‘’,UserID varchar(40) NOT NULL default ‘’,) ENGINE=InnoDB DEFAULT CHARSET=utf8; 这3个设置好了，基本就不会出问题了,即建库和建表时都使用相同的编码格式。但是如果你已经建了库和表可以通过以下方式进行查询。1.查看默认的编码格式: [sql] view plain copymysql&gt; show variables like “%char%”;+————————–+—————+| Variable_name | Value |+————————–+—————+| character_set_client | gbk || character_set_connection | gbk || character_set_database | utf8 || character_set_filesystem | binary || character_set_results | gbk || character_set_server | utf8 || character_set_system | utf8 |+————————–+————-+ 注：以前2个来确定,可以使用set names utf8,set names gbk设置默认的编码格式;执行SET NAMES utf8的效果等同于同时设定如下： [sql] view plain copySET character_set_client=’utf8’;SET character_set_connection=’utf8’;SET character_set_results=’utf8’; 2.查看test数据库的编码格式: [sql] view plain copymysql&gt; show create database test;+————+————————————————————————————————+| Database | Create Database |+————+————————————————————————————————+| test | CREATE DATABASE test /!40100 DEFAULT CHARACTER SET gbk / |+————+————————————————————————————————+ 3.查看yjdb数据表的编码格式:[sql] view plain copymysql&gt; show create table yjdb;| yjdb | CREATE TABLE yjdb (sn int(5) NOT NULL AUTO_INCREMENT,type varchar(10) NOT NULL,brc varchar(6) NOT NULL,teller int(6) NOT NULL,telname varchar(10) NOT NULL,date int(10) NOT NULL,count int(6) NOT NULL,back int(10) NOT NULL,PRIMARY KEY (sn),UNIQUE KEY sn (sn),UNIQUE KEY sn_2 (sn)) ENGINE=MyISAM AUTO_INCREMENT=1826 DEFAULT CHARSET=gbk ROW_FORMAT=DYNAMIC | 二、避免导入数据有中文乱码的问题1:将数据编码格式保存为utf-8设置默认编码为utf8：set names utf8;设置数据库db_name默认为utf8: [sql] view plain copyALTER DATABASE db_name DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;设置表tb_name默认编码为utf8:[sql] view plain copyALTER TABLE tb_name DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;导入：[sql] view plain copyLOAD DATA LOCAL INFILE ‘C:\utf8.txt’ INTO TABLE yjdb;2:将数据编码格式保存为ansi(即GBK或GB2312)设置默认编码为gbk：set names gbk;设置数据库db_name默认编码为gbk:[sql] view plain copyALTER DATABASE db_name DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;设置表tb_name默认编码为gbk:[sql] view plain copyALTER TABLE tb_name DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci;导入：[sql] view plain copyLOAD DATA LOCAL INFILE ‘C:\gbk.txt’ INTO TABLE yjdb;注：1.UTF8不要导入gbk，gbk不要导入UTF8;2.dos下不支持UTF8的显示;三、解决网页中乱码的问题 将网站编码设为 utf-8,这样可以兼容世界上所有字符。 如果网站已经运作了好久,已有很多旧数据,不能再更改简体中文的设定,那么建议将页面的编码设为 GBK, GBK与GB2312的区别就在于:GBK能比GB2312显示更多的字符,要显示简体码的繁体字,就只能用GBK。1.编辑/etc/my.cnf ,在[mysql]段加入default_character_set=utf8;2.在编写Connection URL时，加上?useUnicode=true&amp;characterEncoding=utf-8参;3.在网页代码中加上一个”set names utf8”或者”set names gbk”的指令，告诉MySQL连线内容都要使用utf8或者gbk; NodejsNodejs call 作用域指向 两个参数apply根_本_听不懂,_从_基础来_吧_ 加油重写爬虫，更优雅的异步编程https http https tcp ssl/tls ip tcp iphttpsnode中专门处理加密传输 Promise学习使用对象有3种状态未完成(pending)已完成(fulfilled)失败(rejected)A与A+不同点A+规范通过术语thenable来区别promise对象A+定义onFulfilled/onRejected必须是作为函数来调用，而且调用过程必须是异步的A+严格定义了then方法链式调用时onFulfilled/onRejected的调用顺序promise then方法promiseObj.then(onFulfilled,onRejected) 第一个是操作时调用的回调函数，第二个是失败时调用回调函数onFulfilled = function(value){ return promiseObj2}onRejected = function (err){ }Promisepromise/promise.html安装npm install bluebird库_&lt; script scr=”../node_modules/bluebird/js/browser/bluebird.js”&gt;&lt;/ script &gt;_request方法get就是对request的一个封装 也就是说get能干的事 request都能做http.request(options[,callback])第一个参数是对象的话就可以配置 来定制我们发出的请求的格式host 将要请求的服务器域名，或是ip地址hostname 就是host的别名port 远端服务器端口 末日80localAddress 绑定local链接的本地接口socketPathmethod 指定http请求方法的字符串 默认getpath 请求的路径 默认就是根路径 如果是有查询的字符串就要在后面追究一些参数headers 包含请求头的一个对象auth 用于计算头的基本认证 u’ze pa si wo deagent 控制agent行为也就是一个代理keepAlive 保持资源池周围的套接字在未来能被用于其他请求 末日的值是falsekeepAliveMsecs小爬虫 /school/comment.js爬虫var http = require(‘http’)var url = ‘http://www.imooc.com/learn/348&#39;http.get(url,function(res){ var html = ‘’ res.on(‘data’,function(data){ html += data }) res.on(‘end’,function(){ console.log(html) })}).on(‘error’,function(){ console.log(‘获取失败’)})HTTP源码解读nodejs 高并发iojs 密集操作作用域 局部作用域 全局作用域上下文 this 一个函数被作用于对象调用时 this 指向调用这个方法的对象var pet = { words: ‘…’, speck : function (){ console.log(this.words) }}pet.speck()this通常指向当前函数拥有者 拥有者叫做执行上下文pet.call(this,words);pet.apply(this,arguments);this 代表js一个关键字 函数运行时自动生成的一个内部对象1nodejs 顶层的global"阁楼薄"对象 == window HTTP概念进阶什么是回调 什么是同步/异步var c=0;function printIt() { console.log(c)}function plus(callback) { setTimeout(function(){ c+=1; callback(); },1000) }plus(printIt)什么是I/O 磁盘 数据的进和出什么是单线程/多线程什么是阻塞/非阻塞什么是事件什么是事件驱动什么是基于事件驱动的回调什么是事件循环可以通过回调的方式来达到异步编程，非堵塞的效果nodejs 非堵塞 单线程 和事件驱动 更好的理解下一节内容状态码 200 OK成功1xx 请求接受，继续处理 400 语法错误 服务器无法理解2xx 成功 401 没有授权3xx 重定向，要想完成就要更进一步操作(跳转或..) 403 拒绝提供服务 可能还是没有权限4xx 客户端错误，语法错误 ，无法实现 404 没找到5xx 服务器端错误 500 服务器端发生了不可预期错误 503 服务器端当前还不能处理这个请求http知识填坑-分解 http知识填坑http头和正文信息 123http头发送的是一些附加信息：内容类型服务器发送响应的日期，HTTP状态码正文就是用户提交的表单数据。 chrome//net-internals/#dns首先域名解析 1 chrome 先搜索自身的DNS缓存2 搜索操作系统自身的DNS缓存(浏览器没有找到缓存或缓存已经失效) chrome//net-internals/#dns 查看缓存是否过期3 读取本地host文件4 浏览器发起一个DNS的一个系统调用5 浏览器获得域名对应的IP地址后，发起HTTP”三次握手”6 TCP/IP 连接起来后，浏览器就可以向服务器发送http请求了使用了比如说，用HTTP的GET方法请求一个根域里的一个域名，协议可以采HTTP1.0的一个协议7 服务器端接受到了这个请求，根据路径参数，经过后端的一些处理之后，把处理后的一个结果数据返回给浏览器，如果是慕课网的页面就会把完整的HTML页面代码返回给浏览器8 浏览器拿到了慕课网的HTML页面代码，在解析和渲染这个页面的时候，里面的js、css、图片静态资源，他们同样也是一个HTTP请求需要经过上面的主要的七个步骤9 浏览器根据拿到的资源对页面进行渲染，最终把一个完整的页面呈现给用户运营商的DNS服务器呢首先1.查找自身的缓存找到对应的条目2.没有找到会代替我们的服务器发起一个迭代DNS解析请求 运营商服务器吧结果返回操作系统内核 同时缓存起来 操作系统内核把结果返回浏览器 最终浏览器拿到www.imooc.com对应的IP地址Query String参数处理小利器querystring.stringify 序列化querystring.stringify({name:’scott’,course:[‘1’,’2’]},’,’,’:’) 第四个参数 默认限制1000 设置为0 就不限制querystring.parse 反序列化 querystring.escape(‘&lt;哈哈&gt;’) 转译querystring.unescape(‘%3C%E5%93%88%E5%93%88%3E’)URL解析好帮手nodeurl.parseurl.parse(‘http://www.imooc.com/video/6710&#39;) 如果第二个参数设置true 则 query将变为一个对象 第三个参数设置为true{protocol: ‘http’, 什么协议 http ftpslashes:true, 是否//auth:null,host:’www.imooc.com&#39;, ip地址或者域名port:null, 端口 默认80hostname:’www.imooc.com&#39;, 主机名hash:null, 锚点search:null, 查询字符串参数query:null, 发送数据=号间隔开的 键值称之为参数传pathname:’/video/6710’, 资源路径名path:’/video/6710’, 路径href:’http://www.imooc.com/video/6710&#39; 没被解析的超链接}url.formaturl.format({protocol:slashes:auth:host:port:hostname:hash:search:query:pathname:path:href:})会将这些解析为 合法的 url地址url.resolve(‘http://imooc.com/&#39;,&#39;/course/list&#39;)http://imooc.com/course/list命令行体验 目前版本 0.10.34 飙升 0.10.35 io.js也同时发布了1.0.1的版本 标志nodejs分化为两个阵营起一个web服务器const http = require(‘http’); const hostname = ‘127.0.0.1’;const port = 3000; const server = http.createServer((req, res) =&gt; { 请求体和响应体 req：那个url地址过来的，请求类型 res:告诉服务器给这个请求响应一些内容 要不然一直就是挂起的状态 res.statusCode = 200; //返回的状态码 代表成功 res.setHeader(‘Content-Type’, ‘text/plain’); //返回的文本内容类型是 纯文本 res.end(‘Hello Nodejs\n’); 这里是匿名的回调函数}); server.listen(port, hostname, () =&gt; { console.log(Server running at http://${hostname}:${port}/);});修改内容没变化 因为没有重启服务器有请求有返回 五脏俱全啊 Nodejs入门[] 1这个链接呢 是node学习的根基 没有它 就没有我 哈哈 http://www.nodebeginner.org/index-zh-cn.html处理POST请求这里的特定的事件有data事件（表示新的小数据块到达了）以及end事件（表示所有的数据都已经接收完毕）。12345678我们需要告诉Node.js当这些事件触发的时候，回调哪些函数。怎么告诉呢？ 我们通过在request对象上注册监听器（listener） 来实现。这里的request对象是每次接收到HTTP请求时候，都会把该对象传递给onRequest回调函数。request.addListener("data", function(chunk) &#123; // called when a new chunk of data was received&#125;);request.addListener("end", function() &#123; // called when all chunks of data have been received&#125;); 以非阻塞操作进行请求响应 堵塞与非堵塞上述代码中，我们引入了一个新的Node.js模块，child_process。之所以用它，是为了实现一个既简单又实用的非阻塞操作：exec()。123exec()做了什么呢？它从Node.js来执行一个shell命令。在上述例子中，我们用它来获取当前目录下所有的文件（“ls -lah”）,然后，当/startURL请求的时候将文件信息输出到浏览器中。上述代码是非常直观的： 创建了一个新的变量content（初始值为“empty”），执行“ls -lah”命令，将结果赋值给content，最后将content返回。 路由给真正的请求处理程序1路由，顾名思义，是指我们要针对不同的URL有不同的处理方式。例如处理/start的“业务逻辑”就应该和处理/upload的不同。 我们暂时把作为路由目标的函数称为请求处理程序。123456789101112应用程序需要新的部件，因此加入新的模块 -- 已经无需为此感到新奇了。我们来创建一个叫做requestHandlers的模块，并对于每一个请求处理程序，添加一个占位用函数，随后将这些函数作为模块的方法导出：function start() &#123; console.log("Request handler 'start' was called.");&#125;function upload() &#123; console.log("Request handler 'upload' was called.");&#125;exports.start = start;exports.upload = upload;这样我们就可以把请求处理程序和路由模块连接起来，让路由“有路可寻”。 不过结果有点令人失望，JavaScript没提供关联数组 – 也可以说它提供了？事实上，在JavaScript中，真正能提供此类功能的是它的对象。12在C++或C#中，当我们谈到对象，指的是类或者结构体的实例。对象根据他们实例化的模板（就是所谓的类），会拥有不同的属性和方法。但在JavaScript里对象不是这个概念。在JavaScript中，对象就是一个键/值对的集合 -- 你可以把JavaScript的对象想象成一个键为字符串类型的字典。但如果JavaScript的对象仅仅是键/值对的集合，它又怎么会拥有方法呢？好吧，这里的值可以是字符串、数字或者……函数！ 行为驱动执行函数式编程路由模块 我们需要的所有数据都会包含在request对象中，该对象作为onRequest()回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的Node.JS模块，它们分别是url和querystring模块。123456789101112131415 url.parse(string).query | url.parse(string).pathname | | | | | ------ -------------------http://localhost:8888/start?foo=bar&amp;hello=world --- ----- | | | | querystring(string)["foo"] | | querystring(string)["hello"]当然我们也可以用querystring模块来解析POST请求体中的参数，稍后会有演示。 服务端的模块放在哪里exports可以导出函数 服务器是如何请求的1当我们的回调启动，我们的onRequest()函数被触发的时候，有两个参数被传入：request和response，他们都是对象，你可以使用他们的方法来处理http请求的细节(比如向发出请求的浏览器发回一些东西) 1_今天先到这里。。明天贼尴尬。。居然没去成。。平常上班你怎么那么准时，到了这种时候却起不来，啊啊啊。。我都不信啊，我也是有毒。。居然没定闹钟。。额 。老天爷。你为什么要这样。。好吧 。。今天还看了看东西。给自己点赞+1_ 2016/7/4 _开始_1所以我们的代码就是：收到请求，使用response.writeHead()函数发送一个状态200和HTTP头的内容类型(content-type),使用response.write()函数在HTTP相应主体中发送文本"hello World",最后我们调用response.end()完成响应 目前来说，我们对请求的细节并不在意，所以我们没有使用request对象 基于事件驱动的回调为什么我们要用这种方式呢(上一章节)这个问题不好回答，不过这是nodejs原生的工作方式。他是事件驱动的，这也是他为什么这么快的原因作者的理解，我自己也理解写下1当我们使用http.createServer方法的同时，我们当然不只是想要一个侦听某个端口的服务器，我们还要它在服务器收到一个http请求的时候做点什么。 问题来了，这是异步的：请求任何时候都可能到达，但是我们服务器却跑在一个单进程中。1php的时候可以一点都不用担心，任何时候当有请求进入的时候，网页服务器(通过apache)就为这一请求新建一个进程，并且开始从头到尾执行相应的PHP脚步 那么在nodejs程序中，当一个新的请求到达8888端口的时候，我们怎么控制流程呢1我们不知道这件事情什么时候发生，但是我们现在有一个处理请求的地方：他就是我们传递过去的那个函数。至于他是被预先定义的函数还是匿名函数，就无关紧要了。这个就是传说中的*回调*。我们给某个方法传递一个函数，这个方法在有相应事件发生时调用这个函数来进行回调 让我们再来琢磨琢磨这个新概念。我们怎么证明，在创建完服务器之后，即使没有HTTP请求进来、我们的回调函数也没有被调用的情况下，我们的代码还继续有效呢？我们试试这个：123456789101112var http = require("http");function onRequest(request, response) &#123; console.log("Request received."); response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;http.createServer(onRequest).listen(8888);console.log("Server has started."); 执行这串代码后 第一次回出现 Server has started.当访问这个页面时 就会在命令行输出 Request received. 这就是事件回调这就是事件驱动的异步服务器端JavaScript和它的回调啦！1*（请注意，当我们在服务器访问网页时，我们的服务器可能会输出两次“Request received.”。那是因为大部分服务器都会在你访问 http://localhost:8888 /时尝试读取 http://localhost:8888/favicon.ico ) * 创建server.js文件1234567var http = require("http");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;"Content-Type": "text/plain"&#125;); response.write("Hello World"); response.end();&#125;).listen(8888); http://localhost:8888/，分析HTTP服务器第一行是nodejs 自带的一个http模块 将其赋值给 http变量接下来调用http模块提供的函数: createServer 。这个函数返回一个对象，这个对象有一个叫做listen的方法，这个方法有一个数值参数，指定http服务器监听的端口号我们本来可以用1234var http = require("http");var server = http.createServer();server.listen(8888); 这样的代码启动服务器他的第一个参数是传递一个函数啊 怪不得12345678910function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, "Hello");来个例子吧 挺叼的哈 我们不一定要绕这个先定义，在传递的圈子。123456function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word)&#123; console.log(word) &#125;, "Hello");作者意思是我们还是得遵循渐进么，先接受一点，在js中，一个函数可以作为另一个函数接收一个参数，我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。 PHPPHP ctrl+shift+j 注释函数查看快捷键 ctrl+shift+l41.对应文件41Demo2.php这章主要讲解了些 图片进行微缩getimagesize — 取得图像大小创建一个新图 $im = imagecreatetruecolor($_width,$_height);下面的工作是载入原图 $_im = imagecreatefromjpeg(RIL.’12.jpe’); imagecopyresampled — 重采样拷贝部分图像并调整大小 //将新图输出 imagejpeg($im,null,10); imagedestroy($im); //关闭第一个句柄 imagedestroy($_im); //关闭第二个句柄41.加载系统已有字体define(‘URL’, dirname(FILE).’\‘);header(‘Content-Type:image/png’); - 设置开头imagecreatefrompng — 由文件或 URL 创建一个新图象。采用系统提供的字体iconv — 字符串按要求的字符编码来转换imagecolorallocate — 为一幅图像分配颜色imagettftext — 用 TrueType 字体向图像写入文本这个是自己写的随机验证码 感觉不错imagepng - 输出imagedestroy - 清除40.对应章节40Demo2.php这章导入一个已有的图片 添加水印define(‘URL’, dirname(FILE).’\‘);imagecreatefrompng — 由文件或 URL 创建一个新图象。40.简单的一个验证码// mt_rand — 生成更好的随机数// echo mt_rand(0,15);// 为什么要循环0-15之间的数呢？// 因为要实现最简单的字母和数字搭配// 十六进制 0-9 a-f;// dechex — 十进制转换为十六进制// 十六进制 0-9都一样的 但是10-15的时候会转换为A-F// echo dechex(mt_rand(0,15)); for ($i=0;$i&lt;4;$i++) { @$nmsg .= dechex(mt_rand(0,15)); //会报错 也解决不了 头疼 } 39./* * 创建图像的一般流程 * 1.设定标头，告诉浏览器你要生成的MIME类型 * 2.创建一个图像区域，以后的操作都将基于此图像区域 * 3.在空白图像区域绘制填充背景 * 4.在背景上绘制图像轮廓输入文本 * 5.输出最终图像。 * 6.清除所有资源 * 7.其他页面调用图像 /// 1设置标头指定MIME输出类型： header(‘Content-Type: image/png’);// 2新建一个基于调色板的图像 $im = imagecreatetruecolor(200, 200);// 为一幅图像分配颜色 $color = imagecolorallocate($im, 153,204 ,255 );// 3区域填充 imagefill($im, 0, 0, $color);// 4绘制线条 $white = imagecolorallocate($im, 0,0,0 ); imageline — 画一条线段 imageline($im, 0, 0, 200, 200, $white); imagestring — 水平地画一行字符串 imagestring($im,5,80,80,’Mr.jj’,$white);// 5以 PNG 格式将图像输出到浏览器或文件 imagepng($im); //要放一个句柄// 第六步 清除所有资源* imagedestroy($im); 38.创建一个常量dirname — 返回路径中的目录部分is_dir — 判断给定文件名是否是一个目录 mkdir — 新建目录define(‘URL’, dirname(FILE).’\images’);$UR = str_replace( ‘\‘, ‘/‘,URL);in_array — 检查数组中是否存在某个值is_array — 检测变量是否是数组这个章节进行了很多优化和改进if (!is_dir(URL)) { 这个创建一个常量后，进行各种取值取得目录，如果没有该目录 则自己创建 mkdir(URL,0777);}37.这两章都写到一起了，36主要讲了一些根目录PHP.ini的设置36.这一章用处很多is_uploaded_file() 判断文件是否通过HTTP POST上传的move_uploaded_file — 将上传的文件移动到新位置location.href=’xianshi.php?url=”.’images/‘.$_FILES[‘username’][‘name’].”‘&lt;/ script&gt;”大概就是可以将一个图片用户去上传到本网站，成为自己网站的一部分，差不多就是可以达成我们说的 B 2 B 用户对用户35.做一个简单的登陆cookieSession会话34.time — 返回当前的 Unix 时间戳setcookie(‘name’,’wq’);/ cookie限制* 1、必须在HTML文件的内容输出之前设置 2、不同的浏览器对cookie的处理不一致，且有时会出现错误的结果 3、限制是在客户端的。一个浏览器能创建的cookie数量最多为30 个，并且每个不能超过4KB，每个WEB站点能设置的cookie总量 不超过20个/ $_COOKIE33.接收所有数据正则判断邮箱PHP可以输出JS代码 $_GET 可以接收超链接？后的变量值32.header(‘Content-Type:text/html;charset=gbk’);//设置页面编码 header(‘Location:Demo2.php’); //绝对相对链接都可以/ 表单元素 描述 text input 文本框 passoword input 密码框 hidden 隐藏框 select 下拉列表框 checkbox 复选框 radio 单选按钮 textarea 区域框 file 上传 submit 提交按钮 reset 重置按钮 email 邮箱/ $_POST $_GETisset — 检测变量是否设置31.explode — 使用一个字符串分割另一个字符串microtime — 返回当前 Unix 时间戳和微秒数 返回两个值localtime — 取得本地时间date_default_timezone_set(‘Asia/Shanghai’); //有效 //字符串意思 ： 亚洲/上海putenv — 设置环境变量的值 putenv(‘TZ=Asia/Shanghai’) 这种设置已经无效了 不知道为什么 反正用上面那个就行了getlastmod — 获取页面最后修改的时间 :date(‘Y-m-d H:i:s’,getlastmod()+(60608)) 这种写法后面60608 == 已秒数增加8小时strtotime(‘2015-12-05 18:13:06’); //人性化获取时间戳mktime(12,18,2,1,7,2016); //这种就很反人类吧 //时-分-秒-月-日-年date(‘Y-m-d H:i:s’,mktime(12,18,2,1,7,2016))time()+(6060*8); //时间差写法round — 对浮点数进行四舍五入30.checkdate — 验证一个格里高里日期 //没有详细的用法gettimeofday — 取得当前时间 //返回数组getdate — 取得日期／时间信息time — 返回当前的 Unix 时间戳 //直接获取时间戳29.preg_grep — 返回匹配模式的数组条目 //函数搜索数组中的元素。preg_match — 执行一个正则表达式匹配 //第一个当然是正则表达式 第二个要进行匹配的字符串preg_match_all — 执行一个全局正则表达式匹配 //要传3个参数 第三个参数利用二维数组储存//定界正则preg_quote — 转义正则表达式字符preg_replace — 执行一个正则表达式的搜索和替换//取消贪婪1.第一种是利用JS中的?方式2.第二种呢PHP中自己有 用 “U” 直接去除贪婪 preg_split — 通过一个正则表达式分隔字符串print_r(preg_split(‘/[.w]/‘,&#39;qweq.qwe@qwe.q@we@qw.qwe‘));28.preg_match — 执行一个正则表达式匹配x表示忽略空白 /php/x;27. 同28章26.所有处理中文字符串的都是已mb开头的重点讲5个，其他可以硬套 /* * mb_strlen(); mb_strlen — 获取字符串的长度 * mb_strstr(); mb_strstr — 查找字符串在另一个字符串里的首次出现 * mb_strpos(); mb_strpos — 查找字符串在另一个字符串中首次出现的位置 * mb_substr(); mb_substr — 获取字符串的部分 * mb_substr_count(); mb_substr_count — 统计字符串出现的次数 * //对应函数 substr_count(); 手册中没有 * substr_count — 计算字串出现的次数 */ $inname = &apos;名字&apos;; mb_strpos($inname,&apos;字&apos;,0,&apos;gbk&apos;); 可以用这个格式硬套其他的 手册看了就会了 25. /* * strcmp(); strcmp — 二进制安全字符串比较 * strcasecmp(); strcasecmp — 二进制安全比较字符串（不区分大小写） * strnatcmp(); strnatcmp — 使用自然排序算法比较字符串 */ strcmp(‘吧’, ‘啊’); // $st1 &gt; str2 返回大于0 $st1 &lt; $st2 返回小于0strcasecmp(‘a’, ‘A’); //不区分大小写strcmp(‘2’, ‘10’); //这种是字符比较 所以比较的是第一个值strnatcasecmp(‘2’, ‘10’); //这个是自然排序法strspn — 计算字符串中全部字符都存在于指定字符集合中的第一段子串的长度。echo strspn(‘sin’, ‘suin po’,0,3);strlen($string); //字符串长度substr_count — 计算字串出现的次数strchr() 是 strstr的别名;strstr(‘qweqdd’, ‘d’,true); //打印出该字符首次出现位置strpos — 查找字符串首次出现的位置 //最先出现的位置strrpos — 计算指定字符串在目标字符串中最后一次出现的位置 //最后出现的位置// str_replace — 子字符串替换// str_ireplace — str_replace() 的忽略大小写版本// substr_replace — 替换字符串的子串// echo str_replace(‘.’,’伍德’,’this is .’);// echo substr_replace(‘this is .’,’$#’,0,5); // 第0个开始取5个 替换为$#24./*explode() explode — 使用一个字符串分割另一个字符串 * implode() implode — 将一个一维数组的值转化为字符串 * join() join — 别名 implode() */ strtok — 标记分割字符串substr — 返回字符串的子串str_split — 将字符串转换为数组strrev — 反转字符串 中文不行23.trim — 去除字符串首尾处的空白字符（或者其他字符）ltrim — 删除字符串开头的空白字符（或其他字符）rtrim — 删除字符串末端的空白字符（或者其他字符） /* * chop() chop — rtrim() 的别名 * ltrim() ltrim — 删除字符串开头的空白字符（或其他字符） * rtrim() rtrim — 删除字符串末端的空白字符（或者其他字符） * trim() trim — 去除字符串首尾处的空白字符（或者其他字符） */ nl2br — 在字符串所有新行之前插入 HTML 换行标记 //通常在回帖的时候使用htmlentities 转换所有字符htmlspecialchars($ea); //转换html代码strip_tags($ea); //此方法直接将 &lt; strong&gt;删除addslashes($ea); // 给特殊符号加上转义符stripcslashes($ea); //将反斜杠去掉// 格式化字符串大小写 /* * strtoupper() 函数将字符串转换为大写 * strtolower() 函数将字符串转换为小写 * ucfirst() 函数将第一个字母转换为大写 * ucwords() 函数将每个单词第一个字母转换为大写; * * str_pad — 使用另一个字符串填充字符串为指定长度 */ str_pad — 使用另一个字符串填充字符串为指定长度 应该不错22.require ‘p.php’; //如果不存在就停止执行并报错include ‘p.php’; //如果不存在就报错require_once ‘p’; //如果调用一次 则不会继续调用//推荐使用require;魔法常量 … require(dirname(FILE).’\21Demo.php’); //此写法可以读取读取大目录21.按引用传递加上&amp;即可global 定义全局变量$GLOBALS[‘a’] = 50; //超级全局变量，就是一个数组啊include ‘’; //==链接了一个Php文件吧print_r($_POST); 不知道为什么用到这个20. 这一章貌似没什么重点 所以当时是跳过了19.file_exists — 检查文件或目录是否存在filesize — 取得文件大小unlink — 删除文件rewind — 倒回文件指针的位置fseek — 在文件指针中定位ftell — 返回文件指针读/写的位置 //查看当前指针位置fopen — 打开文件或者 URLfgetc — 从文件指针中读取字符fclose — 关闭一个已打开的文件指针文件锁定 –解决问题:假如同时两个客户购买，只能获得一条数据flock — 轻便的咨询文件锁定opendir — 打开目录句柄readdir — 从目录句柄中读取条目closedir($dir); //关闭scandir — 列出指定路径中的文件和目录rmdir — 删除目录rename — 重命名一个文件或目录md5 — 计算字符串的 MD5 散列值 //加密md5_file — 计算指定文件的 MD5 散列值函数传入值的话 直接覆盖 没传值用赋值的18.fwrite — 写入文件（可安全用于二进制文件）fgetc — 从文件指针中读取字符fgets — 从文件指针中读取一行fpassthru — 输出文件指针处的所有剩余数据//读出文件/* fgetc($handle); — 从文件指针中读取字符 fgets($handle); — 从文件指针中读取一行 fgetss($handle); — 从文件指针中读取一行并过滤掉 HTML 标记 fread($handle, $length); — 读取文件（可安全用于二进制文件） fpassthru($handle); — 输出文件指针处的所有剩余数据 file($filename); — 把整个文件读入一个数组中 readfile($filename); — 输出一个文件 file_get_contents($filename); — 将整个文件读入一个字符串 //函数源码自带fclose 关闭 */ //利用while循环完成 feof 测试文件指针是否到了文件结束的位置17.fopen — 打开文件或者 URLfopen 返回的是资源类型(resource),我们一般称它为句柄，或者叫资源句柄fwrite — 写入文件（可安全用于二进制文件）file_put_contents — 将一个字符串写入文件 //不需要任何其他灵活的事情的时候使用16.basename — 返回路径中的文件名部分dirname — 返回路径中的目录部分pathinfo — 返回文件路径的信息realpath — 返回规范化的绝对路径名相绝路径filesize — 取得文件大小round — 对浮点数进行四舍五入round(filesize($name)/1024,2); //这样却得是字节，字节/1024得KBdisk_free_space — 返回目录中的可用空间echo round(disk_free_space(‘D:’)/1024,2)/1024/1024;disk_total_space — 返回一个目录的磁盘总大小echo round(disk_total_space(‘G:’)/1024/1024/1024,2);fileatime — 取得文件的上次访问时间date_default_timezone_set — 设定用于一个脚本中所有日期时间函数的默认时区fileatime — 取得文件的上次访问时间filectime — 取得文件的 inode 修改时间filemtime — 取得文件修改时间date(‘Y:m:d ‘.’H:i:s’,fileatime($Basic5)); //应该是可以直接打印出访问时间15.array_unshift — 在数组开头插入一个或多个单元array_push — 将一个或多个单元压入数组的末尾（入栈）array_shift($userNames); //删除开头array_pop($userNames); //删除末尾array_rand — 从数组中随机取出一个或多个单元array_rand($userNames,2); //返回数组中随机或多个键(key) gettype — 获取变量的类型 current($array); //获取指针当前的元素next — 将数组中的内部指针向前移动一位reset — 将数组的内部指针指向第一个单元prev — 将数组的内部指针倒回一位pos — current() 的别名end — 将数组的内部指针指向最后一个单元array_count_values($array) 统计数组中所有值出现的次数extract — 从数组中将变量导入到当前的符号表 //将数组中字符串键(key)设置为变量初始化 $z=$ci=’’;14.sort — 对数组排序asort — 对数组进行排序并保持索引关系foreach 语法结构提供了遍历数组的简单方式。foreach 仅能够应用于数组和对象，如果尝试应用于其他数据类型的变量，或者未初始化的变量将发出错误信息。有两种语法：each — 返回数组中当前的键／值对并将数组指针向前移动一步while ($a = each ($fn)) { //按顺序打印 echo ‘&lt; br /&gt;’.$a[‘key’].’=&gt;’.$a[‘value’];}count — 计算数组中的单元数目或对象中的属性个数krsort — 对数组按照键名逆向排序sort(); asort(); ksort(); a的是排序后不改变key关系k是按key排序rsort(); arsort(); krsort(); 全部+上r 代表降序shuffle — 将数组打乱array_reverse — 返回一个单元顺序相反的数组rsort — 对数组逆向排序 //array打头的一般创建一个新数组进行返回 当然是一般喽13.list — 把数组中的值赋给一些变量each — 返回数组中当前的键／值对并将数组指针向前移动一步13章还有个小练习，虽然很简单，但是也是一番努力得来的12.reset — 将数组的内部指针指向第一个单元array_unique — 移除数组中重复的值array_unique($userNames); //只能临时删除不能改变原数组array_flip — 交换数组中的键和值11.each — 返回数组中当前的键／值对并将数组指针向前移动一步10.range — 建立一个包含指定范围单元的数组 /* * count()和sizeof()统计数组下标的个数 * array_count_values($array);统计数组内下标的个数 */ is_array — 检测变量是否是数组9.可以在变量或值前面增加(int)、(integer)、(float)、(double)或(real)实现intval — 获取变量的整数值floatval — 获取变量的浮点值is_numeric — 检测变量是否为数字或数字字符串is_int($var); is_float($var); 用于检测具体数值类型/ $a = ‘10.5’;// echo intval($a); echo floatval($a); //临时转换 settype($a, “float”); //转换 echo gettype($a); //查看类型 /rand(); //这个是老的函数生成 随机数;mt_rand(0,10); //比rand快4倍 牛B啊getrandmax(); //最大随机数mt_getrandmax(); //最大随机数 //格式化数据number_format — 以千位分隔符方式格式化一个数字number_format($a,2,’#’,’c’); //这里后面必须传两个参数才可全部更改/* 数学函数 abs(); 绝对值 floor(); 舍去法取整 ceil(); 进一法取整 round(); 四舍五入 min(); 求最小值或数组中最小值 max(); 求最大值数组中最大值*/echo pow(2,4); //2的4次方8.switch ($w) { case 1:echo &apos;1&apos;; break; default :echo &apos;没有&apos;; break; }//第一种：break 退出循环；第二种 exit 退出程序 ；第三种 continue 退出当前循环break; //退出循环;exit; //直接后面的程序都不执行了continue; //退出此次循环，继续执行7./* 转义序列 描述 \n 换行符 \r 回车 \t 水平制表图 相当于tab \ 反斜杠 \$ 美元符 \” 双引号*/错误抑制符@Demo. 对应章节Baisa2/Demo2.phpgettype($var); 却得它的类型settype($var, $type); 设置它的类型isset(); 和 unset()用来判断一个变量是否存在empty(); 用来判断一个变量是否为空换句话说，””、0、”0”、NULL、FALSE、array()、var $var ;(这个是空的变量，只不过写成VAR而已)以及没有任何属性的对象都将被认为是空的unset — 释放给定的变量isset — 检测变量是否设置empty — 检查一个变量是否为空//类型判断函数is_integer — is_int() 的别名is_int — 检测变量是否是整数//可以通过调用一个函数来实现转换变量数据类型的目的 intval()、floatval()、strval();Demo. 对应章节Baisa2/demo.phpprint — 输出字符串printf — 输出格式化字符串sprintf — Return a formatted stringsprintf(“保留到内存中”); //返回字符串6.//超级全局变量/* $GLOBALS 所有全局变量数组 $_SERVER 服务器环境变量数组 $_GET 通过GET方法传递给该脚本的变量数组 $_POST 通过POST方法传递给该脚本的变量数组 $_COOKIE cookie数组变量 $_FLLES 与文件上载相关的变量数组 $_ENV 环境变量数组 $_REQUEST 所有用户输入的变量数组 $_SESSION 会话变量数组*/define — 定义一个常量除了自定义常量外，PHP还预定了许多常量。了解这些常量的简单方法就是运行phpinfo();命令 应用场景 快捷键 功能查看快捷键 ctrl+shift+l 显示所有快捷键列表查看和修改快捷键 打开Window-&gt;Preferences-&gt;General-&gt;keys修改字体字号 打开Window-&gt;Preferences-&gt;General-&gt;Appearance-&gt;Colors and Fonts，找到Basic-&gt;Text Font行操作 ctrl+alt+↓ 复制当前行到下一行ctrl+d 删除当前行ctrl+↓ 当前行下移一行ctrl+↑ 当前行上移一行end 跳转到当前行末尾ctrl+Backspace 删除光标前一个单词，如前面是符号，就删除一个符号,前面是一个单词就删除一个单词alter+→ 在编辑过的位置前进alter+← 在编辑过的位置后退ctrl+home 光标移到文件头ctrl+end 光标移到文件尾shift+home 选中从光标处到行首的文字shift+end 选中从光标处到行末的文字ctrl+/（数字键） 收起/展开代码段shift+enter 在当前行的下一行插入空行ctrl+shift+enter 在当前行的前一行插入空行ctrl+Q 定位到最后编辑的地方ctrl+shift+X 当前选中的文本全部变为大写ctrl+shift+Y 当前选中的文本全部变为小写注释操作 ctrl+/ 添加/取消行注释ctrl+shift+/ 块注释ctrl+shift+\ 取消块注释函数操作 Alt+/ 代码提示助手ctrl 函数跳转，按住ctrl键，鼠标点击函数名Ctrl+Shift+J 给自定义函数或者方法添加注释面向对象操作 ctrl+O 快速大纲, 列出当前文件中的所有变量、函数和方法，对阅读类文件时很有用ctrl+shift+M 搜索方法名ctrl+T 快速显示当前类的继承结构查找操作 ctrl+f 打开本文件的搜索/替换 ，只搜索当前文件ctrl+k 查找下一个ctrl+shift+k 查找上一个ctrl+h 全文检索，打开搜索替换窗口 ，可搜索整个工作空间ctrl+l 转到当前文件的某一行CTRL+E 搜索编辑器中已打开的文件名文件操作 ctrl+w 关闭当前文件ctrl+m 当前编辑窗口最大化/还原ctrl+N 新建文件ctrl+p 打印当前文件ALT+ENTER 查看当前文档的属性ctrl+F12 打开任务(任务：个人定义某一个特定的工作集,如你要完成一个注册模块，有三个文件config.phpregister.class.php register.php|你可以将这些文件保存成一个任务register ,只要打开register就能同时打开这三个文件| )ctrl+F9 激活任务ctrl+shift+F9 取消任务F11 调试当前文件ctrl+F11 运行当前文件alt+→ 下一个编辑的页面alt+← 前一个编辑的页面ctrl+shift+E 显示当前打开的所有的文件代码格式化 Tab 增加代码缩进Shift+Tab 减少代码缩进CTRL+SHIFT+F 当前文件代码格式化调试快捷键 F5 单步调试进入函数内部（单步进入）F6 单步调试不进入函数内部（跳过）F7 由函数内部返回到调用处（跳出）F8 一直执行到下一个断点F9 添加/删除断点 所有代码部分F10 逐过程。单步执行调试文件到下一行F11 逐语句。单步执行到下一被执行的行F12 概要文件URL。打开profile URL对话框Shift+F8 添加监视点。打开添加监视点对话框Shift+F11 跳出。单步执行到返回后执行的第一行Shift+F10 执行代码到光标所在行。Ctrl+F5 无中断的执行脚本Shift+F5 停止调试器Ctrl+Alt+B 在浏览器中显示 Jquery总结Jquery总结 toggleClass(“class1″) 如果原来没有class1就添加class1，如果原来有class1就移除class1attr(“className”,”class1″)addClass(“class1″) .removeClass(“class2″) addClass 添加class removeClass(“class2″) 移除_ 移除所有$(“div”).removeClass(function() { return $(this).attr(‘class’);});_ 添加递归元素 index可以获取递增数自 jQuery 1.4开始, .addClass() 方法允许我们通过传递一个用来设置样式类名的函数。$(“ul li:last”).addClass(function(index) {return “item-“ + index;});*_toggle 绑定两个或多个处理程序绑定到匹配的元素，用来执行在交替的点击。_前面所学 制作鼠标拖拽4.21 11：31_$.fn.extend({drag : function () {var aDiv = 0,cDIv = 0, This = this; this.mousedown(function(ev){aDiv = ev.pageX - $(this).offset().left; cDIv = ev.pageY - $(this).offset().top; $(document).mousemove(function(ev){ console.log(aDiv) This.css(&apos;left&apos;,ev.pageX - aDiv); This.css(&apos;top&apos;,ev.pageY - cDIv); console.log(&apos;s&apos;) }); $(document).mouseup(function(){ $(this).off() }) return false; //不知道有什么用 })}})$(‘#drag’).drag()_$ 插件4.21$-$.extend 扩展工具方法下的插件形式 $.xxx()$.extend({leftTime : function(ind){ return ind.replace(/^\s+/,&apos;&apos;); //leftTime为去掉左空格方法 } })$.fn -$.fn.extend 扩展到jQ对象下的插件形式 $().xxx()$下的方法4.21ajax() : json形式的配置参数-url success-error contentType-data type-dataType cache timeout抽象出来的方法 参数是一个json形式$.ajax({ url : ‘地址’， data : &apos;name=hell&amp;age=20&apos;, type : &apos;POST&apos;, success : function (data) { data 请求成功后返回的一个内容 成功后的回调函数 }, error : function () { 失败的回调 }, contentType : 请求头信息, dataType : 返回数据类型, cache : 是否缓存, timeout : 是否有延迟 })*-get()-post()-getJSON()$下的方法4.20$下的方法 不仅可以给jq对象用 还可以用于原生js 工具方法type() $.type(‘les’); 检测参数类型 更加强大 可以区分[] data 正则 nulltrim() $.trim(‘ | les |’); 去空格inArray() 和indexof 差不多 $.inArray(‘b’,arr) arr= [‘a’,’b’,’c’] 有的话返回相应位置 没有从头开始数proxy() 改变this指向 $.proxy(函数,指向) () 直接可以去执行 $.proxy(函数,指向,参数) (参数) 直接可以去执行noConflict() 避免冲突 jquery == $ 别人的库说不定也是使用的这个 为了避免冲突 var miaov = $.noConflict()parseJSON() 将字符串 解析为json类型 直接就可以解析ajax数据 $.parseJSON( “{‘name’:’names’}” ).namemakeArray() 把类数组转换为真正的数组 类数组就是 var aDiv = document.getElementsByTagName(‘div’);这就叫做类数组 $.makeArray(aDiv).push();这样就不会报错了 动画4.20animate() //第一个参数是个json {} 第二个参数时间 第三个参数 运动形式 默认：swing慢快慢 linear匀速 第四个参数回调 可以写链式调用 == 回调函数stop() 停止运动 默认只会知足当前运动 stop(true) 阻止后续运动 第二个参数 直接到达目标点finish() 立即停止到你所有你指定的目标点delay() 延迟 参数秒算起delegate() 事件委托_$(‘ul’).delegate(‘li’,’click’,function(){ $(this).css(‘background’,’red’);})_undelegate() $(‘ul’).undelegate() 阻止事件委托trigger() //主动触发 $(‘ul’).delegate(‘li’,’click’,function(){alert(‘w’)}) $(‘ul’).trigger(‘click’);ev.dataev.targetev.type_on(‘click’,{name:’hello’},function(ev){ ev.data 就是这个json {name:’hello’} 这个整体 ev.data.name == ‘hello’ ev.target 当前事件源 我操作的是谁 ev.type 当前操作的事件类型})_DOM操作4.20parents() //当前操作节点的所有祖先节点，参数筛选功能closest() //获取最近指定的祖先节点(包含当前元素自身)，必须要写筛选的参数siblings() //获得所有的兄弟节点 有参数，筛选功能nextAll() //下面所有的兄弟节点prevAll() //上面所有的兄弟节点parentsUntil() // Until 截止的意思 所有祖先节点 指定位置nextUntil() //截止到你指定的位置 就不会继续了 当然是填写参数prevUntil()clone() 可以接受一个参数，作用复制之前的操作行为 参数为布尔值 //$(div).clone().appendTo( $(‘span’) ); //这个属性用于复制节点wrap() 包装 $(‘span’).wrap(‘&lt; div &gt;’); 给span元素包装divwrapAll() 整体包装 将集合中的元素 外围整体嵌套一个div 元素不在一起 将元素剪贴过来 更改DOM节点wrapInner() 内部包装 div添加到了span 节点里unwrap() 删除包装 删除父级add() 将元素组合到一起 进行后续操作 $(div).add(‘span’).css(‘background’,’red’) 两个元素都更改slice() 选取的意思 有一组集合 $(div).slice(2,5) 第二个到第四个serialize() 可以将input Name Value 穿连到一起 有助于数据提交 get postserializeArray() 还可以直接转换为数组形式项目中应用siblings() 获得匹配元素集合中每个元素的兄弟元素,可以提供一个可选的选择器。。animate() 根据一组 CSS 属性，执行自定义动画。size() length == size().parent() 取得匹配元素集合中，每个元素的父元素，可以提供一个可选的选择器。toggleClass() 在匹配的元素集合中的每个元素上添加或删除一个或多个样式类,取决于这个样式类是否存在或值切换属性。即：如果存在（不存在）就删除（添加）一个类。.stop() 停止匹配元素当前正在运行的动画。.fadeIn() 通过淡入的方式显示匹配元素。.children() 获得匹配元素集合中每个元素的子元素，选择器选择性筛选。.contents() 获得匹配元素集合中每个元素的子元素，包括文字和注释节点。基础篇:get() : 下标和length属性 就是把jq转换为原生的js _$(‘div’).get(0).innerHTML _outerWidth() : 针对隐藏元素和参数true 可以获取隐藏元素的 width heighttext() : 合体的特例 和html()区别在于 只能获取文本 不能获取标签remove() : detach() var oDiv = remove() 删除所有操作 $(‘body’).append(oDiv)进行恢复 也是无法完成的 detach() 删除了 但是它保留了所有操作$() : $(document).ready() 17:$()方法hover() hover 移入的效果 模拟css中的hover 两个参数 移入移出show() 隐藏 传参 时间参数 改变高和displayhide() 显示fadeIn() 淡入 同意有时间 默认400fadeOut() 淡出 $(‘div’).fadeOut(500); 改变透明度fadeTo() 半透明 fadeTo(900,.5,function(){alert(‘d’) }slideDown() 向下展开slideUp() 向上卷曲13:_ jq 中的 禁止右击 $(document).ready(function(){ $(document).bind(“contextmenu”,function(e){ return false; //即阻止冒泡，又阻止默认事件 }); });_$()常用方法ev //鼠标事件 event对象pageX ev.pageX 获取当前鼠标位置which 键盘键值preventDefault 阻止默认事件stopPropagetion 阻止冒泡one() 事件执行一次offset() $(‘div’).offset().top; 获得元素距离屏幕的左距离 算marginposition() 从定位后算起 父元素设置定位 就从父元素算起offsetParent() 获取有定位的父级val() 获取val值 加参数后== 修改size() 类似于length 获取长度each() 就是jq中的循环 $(‘li’).each(function (i,value) { alert(i +’–’+ $(value).html()); }) _ 拖拽$(document).ready(function () { var disx = 0; var disy = 0; $(‘div’).mousedown(function (ev) { disx = ev.pageX - $(this).offset().left ; disy = ev.pageY - $(this).offset().top ; $(document).mousemove(function (ev) { $(&apos;div&apos;).css(&apos;left&apos;,ev.pageX - disx); $(&apos;div&apos;).css(&apos;top&apos;,ev.pageY - disy); }) $(document).mouseup(function (ev) { $(document).off(); }) return false; }) })_12:弹窗如何创建一个DIV $(‘‘) 这样就是创建滚动条事件和窗口调整事件 onresize onscroll9:$() 常用方法addClass() 添加样式removeClass() 删除样式width() 实际 width 没有单位 只能获得原始宽 windth innerWidth() 不能获得border 宽 _windth + padding _outerWidth() 可以获得所有属性 总和起来的宽 给个参数true 就能获得 windth + padding + border + margin_ /———————jq中的节点操作———————–/ _insertBefore() 节点操作 讲一个点 移动到一个节点前 $(‘span’).insertBefore( $(‘div’) ) ; 将 div 移动到 span前before() _ $(‘span’).before( $(‘div’) ) ; span前面必须是div 也是调换位置_inserAfter() $(‘span’).inserAfter( $(‘div’) ); 将div移动到 span 后after() 和 before() 类似appendTo() 添加到一个指定节点的最后 $(‘div’).appendTo( $(‘span’) ); 这样就将 div 放置在span里最后的位置append() 和 before() 类似prependTo() $(‘div’).prependTo( $(‘span’) ); div 放置在span里开始的位置prepend() 和 before() 类似 _ /——————————————–/ _remove() 删除节点on() 这个就是事件了 click() == on(‘click’,function(){}) 更加强大 可以自定义事件 还可以继续添加其他事件 空格隔开 简直6 G森形式 (不知道是什么东东)localstorage$(&apos;div&apos;).on( &apos;click&apos; : function () { alert(&apos;123&apos;); }, &apos;mouseover&apos; : function () { alert(&apos;456&apos;); } ) $(this).off() 这个就是 关闭点击事件 也是可以传参的 关闭指定事件scrollTop() 滚动距离5:$()下的常用方法has() 包含意思 $(‘div’).has(‘span’).css(‘bakcground’,’red’); //div中包含span 变红not() filter 反义词filter() 过滤next() 下一个兄弟节点prev() 上一个兄弟节点find() 查找的意思eq() eq二联 饿 其实 相当于 js中的下标index() 索引 当前元素在所有兄弟节点中的位置attr() 设置属性 后面会说和其他有什么不同proper deta2: API$(‘li:first’).css(‘background’,’red’); //第一个 first $(‘li:last’).css(‘background’,’red’); //最后一个 last$(‘li:eq(2)’).css(‘background’,’red’); //选择第二个 eq(2) $(‘li:even’).css(‘background’,’red’); //奇数行$(‘li:odd’).css(‘background’,’red’); //偶数行 $(‘li’).filter(‘.box’) //过滤 筛选元素集合中匹配表达式 或 通过传递函数测试的 那些元素集合。$(‘li’).filter(‘[title = href]’) //筛选出’[title = href]’’ title = href的 innerHTML == html()**onclick == click()* $(this) mongodbmongodb mongoDB基本使用123456789101112131415161718192021222324252627282930313233343536db.dropDatabase() 删除数据库show dbs 查看所有表use imooc 切换数据库 并且自己创建*在mongo中我们将一个表称作一个集合*db.imooc_collection.insert(&#123;x:1&#125;) 插入json格式show collections 查看表db.imooc_collection.find() 查询所有db.imooc_collection.find(&#123;x:1&#125;) 指定查询可以使用js语法for(i=3;i&lt;100;i++) db.imooc_collection.insert(&#123;x:i&#125;)db.imooc_collection.find().count() 进行计数db.imooc_collection.findOne() db.imooc_collection.find().skip(3)前三条.limit(2)限制返回2条.sort(&#123;x:1&#125;) 使用x排序 1正序 1-倒叙db.imooc_collection.updateAt(&#123;x:1&#125;,&#123;x:999&#125;) 更新数据db.imooc_collection.updateAt(&#123;x:1&#125;,&#123;x:999&#125;,true) 更改不存在的数据，自动创建db.imooc_collection.updateAt(&#123;x:1&#125;,&#123;$set:&#123;x:999&#125;&#125;) $set操作符为部分操作符db.imooc_collection.updateAt(&#123;x:1&#125;,&#123;$set:&#123;x:999&#125;&#125;，false,true) 更新多条数据 第四个参数db.imooc_collection.remove(&#123;c:2&#125;) remove 删除所有数据db.imooc_collection.drop() 删除表show tables*-------------* db.imooc_collection.getIndexes() 查看索引创建成千上万条数据，没有索引将不查找db.imooc_collection.ensureIndex(&#123;x:1&#125;) 正项排序 -1 逆向排序 建立索引 单建索引多建索引与单件索引创建形式相同，区别在于字段的值 单建索引：值为单一的值，例如字符串，数字或者日期 多建索引：值具有多个记录，例如数组*-------------*db.imooc.ensureIndex(&#123;time:1&#125;,&#123;expireAfterSeconds:30&#125;) 30秒后删除 db.imooc.insert(&#123;time:new Date()&#125;) 存储在过期索引字段的值必须是指定的时间类型。说明：必须是ISODate或者ISOData数组，不能使用时间戳，否则不能自动删除如果指定了ISODate数组，则按照最小的时间进行删除过期索引不能使复合索引删除时间不是精确删除过程是由后台每运60S跑一次，而且删除也需要一些时间，所以存在误差 Node+Express快速搭建电影网站Node+Express快速搭建电影网站 Node+Express快速搭建电影网站后端是用nodejs来驱动的所以需要：1234node.js 在这个基础之上的框架 express可以帮我快速的搭建web应用 jade数据库 mongoDb (芒古DB) 以及对 mongoDb快速建模的工具也就是 mongoose (芒古思) Moment.js后端的模板引擎 jade (zhei de)时间和日期的格式化 Moment.js 底下的四个模块都是利用npm安装的 底下的？ 不懂那些123前端jquery 类库 以及 bootstrap 样式框架 他们都是网站前端的静态资源网站前端的静态资源呢 都存在一个版本的依赖和版本的管理所以这里我需要通过 Bower(鲍尔) 来安装他们 bower 本身也是一个npm模块 需要npm安装 本地开发环境123后面会用到less编译 样式的合并 语法的检查 包括前后端单元测试的实现 以及服务的自动重启 这几个任务都是通过GRUNT集成 会放到下一期的课程讲 大概一些模块名字 ：less cssmin jsHint uglifyJS mocha 不认识 什么鬼 实战开始1.需求分析 1来看看总共有几个页面 页面都有什么内容 以什么样的交互 2.项目依赖初始化 1对项目所依赖的模块进行一个安装和初始目录的创建 3.入口文件编码 1在后端呢创建一个入口文件，来进行编码 4.创建视图 1创建几个主要页面视图 也就是模板 来跑通前后端的流程 也就是说从浏览器发起一个请求到后端，后端接收到之后呢，再返回一段数据，跑通这个前后端流程以后呢 就可以对页面进行样式的开发 和html Dom结构的填充 同时要为早一些模板的数据 这时候页面基本上都有了 我们现在就开始基于页面里面的内容进行提取抽象同时来设计数据库的模型，然后来开发后端逻辑，到这一步位置前后端的逻辑已经实现，还差一步，就是对前端静态资源版本和后端模块版本进行一个配置文件的生成，然后呢整个网站开发结束 步骤详情全部在4后5.测试前端流程6.样式开发，伪造模板数据7.设计数据库模型8.开发后端逻辑9.配置依赖文件，网站开发结束Node入口文件分析项目结构初始化 imooc / npm install expressnpm install jadenpm install mongodbnpm install bower -gbower install bootstrap入口文件编码 123456789var express = require(&apos;express&apos;);var app = express()app.set(&apos;view engine&apos;,&apos;jade&apos;);app.set(&apos;port&apos;,3000)app.get(&apos;/&apos;,function(req,res)&#123; res.render(&apos;index&apos;,&#123;title:&apos;imooc&apos;&#125;) &#125;) 这几行代码大概意思是 引入一个express 模块 生成一个web应用的实例 将这个实例的监听端口设置成3000 然后就可以监听来自这个端口过来的请求创建视图 imooc / node_modules/ 猫丢斯 安装一些模块的时候安装到此目录 bower_components/ 静态资源 安装到 (鲍尔 康门特) 下 views/ v又特 用来测试的主要视图文件 index.jade detail.jade admin.jade list.jade app.js 入口文件 测试前端流程 localhost:3000/ localhost:3000/movie/1 localhost:3000/admin/movie localhost:3000/admin/list实际编码想创建入口文件 app.jsnpm install express jade moment mongoose 数据库模型设计Schema 模式Model 模型 &gt; mongoose &gt;&gt; mongodbDocuments 文档 模式定义 模式里面呢 对数据字段进行定义12345678910var mongoose = require(&apos;mongoose&apos;)var MovieSchema = new mongoose.Schema(&#123; doctor: &apos;String&apos;, title: &apos;String&apos;, language: &apos;String&apos;, country: &apos;String&apos;, year: &apos;Number&apos;, summary: &apos;String&apos;,&#125;) 编译模型 调用mongoose 时对传入schemas 时进行编译然后会生成构造函数12345678var mongoose = require(&apos;mongoose&apos;);var MovieSchema = require(&apos;../schemas/movie&apos;)var Movie = mongoose.model( &apos;movie&apos;, movieSchema)module.exports = Movie 文档实例化 只需要调用这个构造函数 传入一条数据 1234567891011var Movie = require(&apos;./models/movie&apos;)var movie = new Movie(&#123; title : &apos;机械战警&apos;, doctor : &apos;何塞·帕迪利亚&apos;, year: 2018&#125;)movie.save(function(err) &#123; if (err) return handleError(err)&#125;) _–_123456789101112131415161718192021数据库批量查询var Movie = require(&apos;./models/movie&apos;)app.get(&apos;/&apos;,function(req,res)&#123; Movie .find(&#123;&#125;) * 查询全部 * .findOne(&#123;_id:id&#125;) *单条* .exec(function(err,movies)&#123; res render(&apos;index&apos;,&#123; title:&apos;imooc 首页&apos;, movies:movies &#125;) &#125;)&#125;*单条数据删除*Movie .remove(&#123;_id:id&#125;),function(err,movie) &#123; if(err) &#123; console.log(err) &#125; &#125; 开发后端逻辑 目录层次调整 imooc/- node_modules/ - bower_components/ - views/ - \*.jade - models/ - movie.js - schemas/ - movie.js app.js 定位导航定位导航 js编写兼容调试解决IE6不支持问题IE6不支持 fixed 要用到 hack解决IE6下跳变的bug html, * html body {background-image: url(about:blank); background-attachment: fixed; } *html #menu { position: absolute; top: expression(((e=document.documentElement.scrollTop)?e:document.body.scrollTop)+100+’px’);} scrollscroll:([data],fn):当用户滚动到指定元素时，会发生scroll事件scroll事件适用于所有可滚动的元素和window对象(浏览器窗口)$(window).scroll(function(){/…/});scrollTop([val]) 获取/设置匹配元素相应滚动条顶部的偏移offset(); 获取匹配元素的相应偏移。返回的对象包含两个整形属性：top和left，以像素计 搜索框搜索框 Ajax$.get(url,callback,’json’);使用json最大的好处就是不用额外的进行一些编码操作同源策略Ajax发生请求的url地址与服务器地址必须是同一域名下搭建一个api.bing.com使用nginx和fiddler工具设置IE兼容&lt; meta http-equiv=”X-UA-Compatible” content=”IE=edge”&gt; 防止IE浏览器进入怪异模式 标签讲解&lt; form action=”” target=”_blank” method=”get”&gt;&lt; /form&gt;outline:none 默认点击后 text 高亮取消 画廊笔记画廊笔记3D效果编写2016.4.25transition：property duration timing-function delayproperty 规定设置过渡效果的css属性的名称duration 规定完成过渡效果多少秒或毫秒timing-function 规定速度效果的速度曲线，默认easedalay 定义过渡效果延迟多久开始，默认0知识-webkit-font-smoothing:antialiased;用于字体平滑&lt; body onselectstart=”return false”&gt; onselectstart=”return false” 防止文字被选中-webkit-perspective:800px; // 支持3Dbox-sizing: border-box; // 内容和padd都会在border边框之内去呈现-webkit-transform-style:preserve-3d; //支持子元素的3D效果-webkit-transform:translate(0px,0px) rotateY(0deg); //定义位移以及沿着Y轴旋转-webkit-backface-visibility:hidden; 当元素不面向屏幕时隐藏 放大镜效果放大镜效果 瀑布流布局JQ瀑布流布局JQ 电商网站实战电商网站实战]]></content>
      <categories>
        <category>github项目笔记</category>
        <category>笔记MAX</category>
      </categories>
      <tags>
        <tag>html5</tag>
        <tag>css3</tag>
        <tag>jquery</tag>
        <tag>node</tag>
        <tag>mongodb</tag>
        <tag>php</tag>
        <tag>canvas</tag>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-qunaerkaifa]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2Fvue-qunaerkaifa%2F</url>
    <content type="text"><![CDATA[Vue 去哪儿网站开发项目地址：VueLearn -&gt; vue-qunaerkaifaVue官方文档：老师都是和官方文档一起讲解的，vue官方文档 mvvm开发模式2-4123456平常我们用的是mvp开发模式 Model 数据ajax presenter 控制器 View 视图MVVM 我们开发的话只用关心MV这两个层面 VM是VUE帮我们完成的M层数据 V层视图 VM层做的事情就是当M层数据改变去更改V层，这个都是VUE帮我们完成的 虚拟DOM 还有个什么拼不出来，老师让自己翻阅资料查看 组件化2-512页面本来是一个整体，组件化就是把它们切分为一个一个部分， 每一个部分都称之为一个组件更容易维护 Todolist组件化2-6123456789101112131415161718192021全局模板-组件Vue.component('TodoItem',&#123; 创建全局模板 props: ['content'], &#123;'item':content&#125; 接收 template: '&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;',&#125;)使用：上面创建的时候使用了驼峰，所以下面可以这样使用 还真是智能&lt;todo-item&gt;&lt;/todo-item&gt;局部模板-组件var TodoItem = &#123; props: ['content'], template: '&lt;li&gt;&#123;&#123;content&#125;&#125;&lt;/li&gt;',&#125;var app = new Vue(&#123; components: &#123; TodoItem: TodoItem &#125;&#125;) 组件间传值2-71234567this.$emit('delete') 子组件传递事件，这个不但可以传递事件，还可以传递参数，我估计直接传递一个对象都可以吧this.$emit('delete',this.index)父组件用@delete='' 绑定监听事件.splice(index,1) 删除数组内容 3-112345678910vm = new Vue(&#123; &#125;)vm.$el vm.$data凡是以$符号开头的都是指vue的实例属性，或者实例方法vm.$destroy() 销毁vue实例 vue生命周期3-4计算属性，方法，侦听器123456789计算属性 内置缓存 依赖的值没有改变就不会刷新，高效computed : &#123;&#125;methods侦听器：当这个数据改变了就会执行对应的函数，也具有缓存机制watch: &#123;&#125; 计算属性的setter和getter 3-5123456789101112coputed: &#123; fullName: &#123; get: function() &#123; return &#125;, set: function(value) &#123; value值是get的返回值 console.log(value) &#125; &#125;&#125;更改set表示设置了fullName就会更改set值 样式绑定1234567891011类绑定&lt;div :class=&quot;&#123;class: true&#125;&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;className&quot;&gt;&lt;/div&gt;&lt;div :class=&quot;[ClassName,&#123;class: true&#125;]&quot;&gt;&lt;/div&gt;styel绑定style绑定&lt;div :style=&quot;&#123;fontSize: &apos;20px&apos;&#125;&quot;&gt;&lt;/div&gt;&lt;div :style=&quot;[styleName,&#123;fontSize: &apos;20px&apos;&#125;]&quot;&gt;&lt;/div&gt;需要注意 style需要试用驼峰式写法 这里是样式绑定这一节的代码块，1234567891011121314151617181920212223&lt;style&gt; .activated &#123; color: red; &#125;&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;div @Click=&quot;handleClick&quot; :class=&quot;&#123;activated: isActivated&#125;&quot;&gt;Hell world&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; isActivated: false &#125;, methods: &#123; handleClick: function()&#123; this.isActivated = !this.isActivated &#125; &#125; &#125;)&lt;/script&gt; 三元表达式12345678 普通写法： if(this.activated === &quot;activated&quot;)&#123; this.activated= &quot;&quot;; &#125;else &#123; this.activated= &quot;activated; &#125;this.activated= this.activated === &quot;activated&quot; ? &quot;&quot; : &quot;activated&quot; 3-7 Vue中的条件渲染通过v-if 指令结合js表达式的返回值来决定一个标签是否在页面上显示或者是觉得这个标签是否在页面上存在 12345v-show 增加display：none属性 性能高√v-if 从DOM结构移除 v-else 要和v-if紧贴使用v-else-if=&quot;&quot;key 当一个元素被加key值后，vue会知道他是页面上唯一一个值，如果两个东西(应该没有同样的key值吧)的key值不一样，vue就不会去复用以前的dom 3-8 Vue中的列表渲染1234567891011121314151617181920212223&lt;div id=&quot;app&quot;&gt; &lt;div v-for=&quot;(item, index) of list&quot; :key=&quot;item.id&quot;&gt; &#123;&#123;item.text&#125;&#125; ---- &#123;&#123;index&#125;&#125; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &quot;#app&quot;, data: &#123; list: [&#123; id: &quot;01&quot;, text: &quot;hello&quot; &#125;,&#123; id: &quot;02&quot;, text: &quot;blue&quot; &#125;,&#123; id: &quot;03&quot;, text: &quot;less&quot; &#125;] &#125; &#125;) &lt;/script&gt; item 得到的数据，index下标，of是什么东西(以前用的in)，list数组 key值不要使用index，使用项目中自带的id， 这几个变异(？)方法可以达到数据变内容变push pop shift unshift splice(记录成spilce了，我服了) sort reverse第二种方法是改变数据的引用地址，从而改变内容 对象列表有3个值v-for=”(item, key, index) of info”,item 对象里面的键名，key键值， index位置信息，下标 3-9Vue中的set方法通过set方法，注入数据，页面也会跟着变对象中的set方法:12Vue.set(vm.userinfo,&quot;address&quot;,&quot;beijing&quot;)vm.$set(vm.userinfo,&quot;address&quot;,&quot;beijing&quot;) 数组中set方法使用:Vue.set(vm.userinfo,1,5) 1是下标vm.$set(vm.userInfo,2,10) 想改变页面上内容数组有三种方法(改变引用，变异方法，set方法)，对象有两种方法(改变引用，set方法) 4-1组件使用的细节点一、因为html5规范，tbody里面只能放tr，所以用vue模板的时候要这样写1&lt;tr is=&quot;row&quot;&gt;&lt;/tr&gt; 使用is属性解决模板bug 二、子组件定义data，后面必须是一个函数(function),之所以这么设计，是因为一个子组件不像根组件那样只被调用一次，它可能在不同的地方被调用12345data: function() &#123; return &#123; content: &apos;this is content&apos; &#125;&#125;, 三、通过ref=’hello’获取dom节点，达成更改dom的操作12345methods: &#123; handleClick: function() &#123; this.$refs.hello.innerHTML&#125;&#125; 当ref在一个标签上的时候通过this.$refs.名字获取到的内容实际上是获取到的dom节点当ref在一个组件上的时候通过this.$refs.名字获取到里面的内容的时候你获取到的实际上是子组件的引用本节的代码。。12345678910111213141516171819202122232425262728293031323334&lt;div id="root"&gt; &lt;row @change="changeClick" ref='woder'&gt;&lt;/row&gt; &lt;row @change="changeClick" ref='hello'&gt;&lt;/row&gt; &lt;div&gt;&#123;&#123;numberAll&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; Vue.component('row',&#123; template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', data: function()&#123; return &#123; number: 0 &#125; &#125;, methods: &#123; handleClick: function()&#123; this.number ++ this.$emit('change') &#125; &#125; &#125;) var vm = new Vue(&#123; el: "#root", data: &#123; numberAll: 0 &#125;, methods: &#123; changeClick: function()&#123; this.numberAll = this.$refs.hello.number + this.$refs.woder.number &#125; &#125; &#125;)&lt;/script&gt; 4-2父子组件的数据传递更多的传递方式，上一节只是一种一丶父组件通过属性的方式传递数据1234567891011&lt;counter :count=&quot;0&quot;&gt;&lt;/counter&gt;var counter = &#123; props: [&apos;count&apos;], template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;count&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick: function()&#123; this.count ++ 这里不能直接修改 &#125; &#125;&#125; 单项数据流，子组件不能直接修改父组件参数1234567891011121314var counter = &#123; props: [&apos;count&apos;], data: function()&#123; return &#123; number: this.count &#125; &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick: function()&#123; this.number ++ &#125; &#125;&#125; 本节代码:123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="root"&gt; &lt;counter :count="0" @change='char'&gt;&lt;/counter&gt; &lt;counter :count="1" @change='char'&gt;&lt;/counter&gt; &lt;div&gt;&#123;&#123;chas&#125;&#125;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; var counter = &#123; props: ['count'], data: function()&#123; return &#123; number: this.count &#125; &#125;, template: '&lt;div @click="handleClick"&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;', methods: &#123; handleClick: function()&#123; this.number ++ this.$emit('change', 1) &#125; &#125; &#125; var vm = new Vue(&#123; el: '#root', components: &#123; counter: counter &#125;, data: &#123; chas: 1 &#125;, methods: &#123; char: function(step)&#123; this.chas += step &#125; &#125; &#125;)&lt;/script&gt; 4-3组件参数效验于非props特性传递参数的时候，:content=”这里是差值表达式，自然就是Number类型”content=”这样就是字符串”一丶props可以是一个对象，规定接收的是什么类型的值(可以接收多个值)123456Vue.component('child',&#123; props: &#123; content: [String, Number] &#125;, template: '&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;'&#125;) 还可以更复杂props,还可以跟一个对象12345678910111213Vue.component('child',&#123; props: &#123; content: &#123; type: String, required: true, //content不能没有 default: 'default value', //默认值 validator: function(value) &#123; return (value.length &gt; 5) &#125; //规定长度 &#125; &#125;, template: '&lt;div&gt;&#123;&#123;content&#125;&#125;&lt;/div&gt;'&#125;) 非props个人理解，父组件传，子组件不接收，子组件就不能用这个参数(那不是p话？)，参数会显示到标签上非props特性，是什么鬼呦 4-4给组件绑定原生事件原生事件就是组件本事绑定事件，组件拿出来用给的事件就是自定义事件1234567891011121314151617181920212223&lt;div id="root"&gt; &lt;child @click='handleClick'&gt;&lt;/child&gt; //自定义事件&lt;/div&gt;&lt;script&gt; Vue.component('child',&#123; template: '&lt;div @click="handbas"&gt;child&lt;/div&gt;', //原生事件 methods: &#123; handbas: function()&#123; alert('handbas') this.$emit('click') &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function() &#123; alert('click') &#125; &#125; &#125;)&lt;/script&gt; 但是上面的需要两层传递，很麻烦，还有下面的方法 1234567891011121314151617&lt;div id="root"&gt; &lt;child @click.native='handleClick'&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child',&#123; template: '&lt;div&gt;child&lt;/div&gt;', &#125;) var vm = new Vue(&#123; el: '#root', methods: &#123; handleClick: function() &#123; alert('click') &#125; &#125; &#125;)&lt;/script&gt; 总结：绑定.native修饰符就可以了 4-5非父子组件间的传值(Bus/总线/发布订阅模式/观察者模式)Vuex 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;div id=&quot;root&quot;&gt; &lt;child content=&apos;Dell&apos;&gt;&lt;/child&gt; &lt;child content=&apos;Lee&apos;&gt;&lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.prototype.bus = new Vue() //prototype Vue.component(&apos;child&apos;,&#123; props: &#123; content: String &#125;, data: function() &#123; return &#123; number: this.content &#125; &#125;, template: &apos;&lt;div @click=&quot;handleClick&quot;&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt;&apos;, methods: &#123; handleClick: function() &#123; this.bus.$emit(&apos;change&apos;, this.number) //this.bus &#125; &#125;, mounted: function() &#123; // var this_ = this this.bus.$on(&apos;change&apos;, function(msg)&#123; this_.number = msg &#125;) &#125; &#125;) var vm = new Vue(&#123; el: &apos;#root&apos;, methods: &#123; hands: function(step) &#123; &#125; &#125; &#125;)&lt;/script&gt; 4-6 在Vue中使用插槽(slot)一、插槽 1234567891011121314151617181920212223&lt;div id="root"&gt; &lt;child&gt; &lt;p&gt;Dell&lt;/p&gt; 插槽 &lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child',&#123; props: &#123; content: String &#125;, template: `&lt;div&gt; &lt;p&gt;hello&lt;/p&gt; &lt;slot&gt;默认内容&lt;/slot&gt; //slot语法接收，当没有内容的时候就会使用默认内容 &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;)&lt;/script&gt; 二、句名插槽1234567891011121314151617181920212223&lt;div id="root"&gt; &lt;body-content&gt; &lt;div class="header" slot='header'&gt;header&lt;/div&gt; &lt;div class="footer" slot='footer'&gt;footer&lt;/div&gt; &lt;/body-content&gt;&lt;/div&gt;&lt;script&gt; Vue.component('bodyContent',&#123; props: &#123; content: String &#125;, template: `&lt;div&gt; &lt;slot name='header'&gt;&lt;/slot&gt; &lt;div class="content"&gt;content&lt;/div&gt; &lt;slot name='footer'&gt;&lt;/slot&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;) 4-7 Vue中的作用域插槽 12345678910111213141516171819202122232425262728&lt;div id="root"&gt; &lt;child&gt; &lt;template slot-scope="props"&gt; &lt;!-- 固定写法 --&gt; &lt;li&gt;&#123;&#123;props.item&#125;&#125;&lt;/li&gt; &lt;/template&gt; &lt;/child&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child',&#123; data: function() &#123; return &#123; list: [1,2,3,4] &#125; &#125;, template: `&lt;div&gt; &lt;ul&gt; &lt;slot v-for="item of list" :item="item"&gt;&lt;/slot&gt; &lt;/ul&gt; &lt;/div&gt;` &#125;) var vm = new Vue(&#123; el: '#root', &#125;)&lt;/script&gt; 4-8动态组件与v-once指令一、普通写法，实现(toggle)互相展示隐藏的效果1234567891011121314151617181920212223242526272829&lt;div id="root"&gt; &lt;child-one v-if='type === "child-one"'&gt;&lt;/child-one&gt; &lt;child-two v-if='type === "child-two"'&gt;&lt;/child-two&gt; &lt;button @click="handClik"&gt;change&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.component('childOne',&#123; template: '&lt;div&gt;child-one&lt;/div&gt;' &#125;) Vue.component('childTwo',&#123; template: '&lt;div&gt;child-two&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type: 'child-one' &#125;, methods: &#123; handClik: function() &#123; this.type = this.type === 'child-one' ? 'child-two' : 'child-one' &#125; &#125; &#125;)&lt;/script&gt; 二、动态组件script部分就是上面的1234&lt;div id="root"&gt; &lt;component :is='type'&gt;&lt;/component&gt; &lt;!-- 动态组件 --&gt; &lt;button @click="handClik"&gt;change&lt;/button&gt;&lt;/div&gt; 三、v-once指令保存到内存，高效1234567Vue.component('childOne',&#123; template: '&lt;div v-once&gt;child-one&lt;/div&gt;'&#125;)Vue.component('childTwo',&#123; template: '&lt;div v-once &gt;child-two&lt;/div&gt;'&#125;) v-once提高静态资源的效率 Vue中的css动画原理transition标签，工作原理显示标签的时候enter即将运行的第一帧就存在了class：fade-enterfade-enter-active运行到第二帧class：删除fade-enterfade-enter-to最后就是删除所有帧 删除标签的时候leave，原理和上面一样 1234如果没有name="fade" class名字就是v-enter以此类推&lt;transition name="fade"&gt; &lt;!-- 包裹的内容有过渡效果 --&gt;&lt;/transition&gt; v-if,v-show 都可以实现本节源码12345678910111213141516171819202122232425262728293031&lt;style&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: opacity 1s; &#125;&lt;/style&gt;&lt;div id="root"&gt; &lt;transition name="fade"&gt; &lt;!-- 包裹的内容有过渡效果 --&gt; &lt;div v-if="show"&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handclick"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: '#root', data: &#123; show: true &#125;, methods: &#123; handclick: function() &#123; this.show = !this.show &#125; &#125; &#125;)&lt;/script&gt; 在Vue中使用Animate.css库enter-active-class 可以替换 v-enter-active这个class，所以我们可以利用这个特性使用Animate库 123456789101112131415161718192021222324252627&lt;link rel=&quot;stylesheet&quot; href=&quot;node_modules/animate.css/animate.css&quot;&gt; &lt;div id=&quot;root&quot;&gt; &lt;transition name=&quot;fade&quot; enter-active-class=&quot;animated bounce&quot; leave-active-class=&quot;animated bounce&quot; &gt; &lt;!-- 使用animate动画 --&gt; &lt;div v-if=&quot;show&quot;&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click=&quot;handclick&quot;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script&gt; var vm = new Vue(&#123; el: &apos;#root&apos;, data: &#123; show: true &#125;, methods: &#123; handclick: function() &#123; this.show = !this.show &#125; &#125; &#125;) &lt;/script&gt; 需要注意的是自定义class，animated添加这个class，根据喜欢的 5-3在Vue中同时使用过度和动画appear 进入动画123456789101112&lt;div id="root"&gt; &lt;transition name="fade" appear enter-active-class="animated zoomInDown" leave-active-class="animated zoomIn" appear-active-class="animated zoomInLeft" &gt; &lt;!-- 使用animate动画 --&gt; &lt;!-- 自定义class appear --&gt; &lt;div v-show="show" class="nams"&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handclick"&gt;切换&lt;/button&gt;&lt;/div&gt; animate.css提供的动画是@keyframes类型的动画 123456789&lt;!-- type="transition" 确认动画时长以transition为准 --&gt; &lt;transition name="fade" type="transition" appear enter-active-class="animated zoomInDown" leave-active-class="animated zoomIn" appear-active-class="animated zoomInLeft" &gt; 通过type:duration 属性可以控制动画总时长存在即合理1234567891011121314151617181920212223242526272829303132&lt;style&gt; .fade-enter, .fade-leave-to &#123; opacity: 0; &#125; .fade-enter-active, .fade-leave-active &#123; transition: all 10s; &#125; .nams &#123; width: 100px; height: 100px; text-align: center; line-height: 100px; &#125;&lt;/style&gt;&lt;div id="root"&gt; &lt;!-- type="transition" 确认动画时长以transition为准 --&gt; &lt;transition :duration="&#123;enter: 5000, leave: 10000&#125;" type="transition" name="fade" appear enter-active-class="animated zoomInDown fade-enter-active" leave-active-class="animated zoomIn fade-leave-active" appear-active-class="animated zoomInLeft" &gt; &lt;!-- 使用animate动画 --&gt; &lt;!-- 自定义class appear --&gt; &lt;div v-show="show" class="nams"&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handclick"&gt;切换&lt;/button&gt;&lt;/div&gt; 使用type属性需要注意transition必须存在，不然动画就==没有时长了 5-4Vue中的js动画与Velocity.js结合一，js钩子实现动画 1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;root&quot;&gt; &lt;transition @before-enter=&quot;handleBeforeEnter&quot; @enter=&quot;handleEnter&quot; @after-enter=&quot;handAfterEnter&quot; &gt; &lt;!-- 出场动画就是将enter改为leave --&gt; &lt;div v-show=&quot;show&quot; class=&quot;nams&quot;&gt;hello world&lt;/div&gt; &lt;/transition&gt; &lt;button @click=&quot;handclick&quot;&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#root&apos;, data: &#123; show: true &#125;, methods: &#123; handclick: function() &#123; this.show = !this.show &#125;, handleBeforeEnter: function(el) &#123; el.style.color = &apos;red&apos; &#125;, handleEnter: function(el,done) &#123; /*done回调函数*/ setTimeout(() =&gt; &#123; el.style.color = &apos;green&apos; &#125;,2000) setTimeout(() =&gt; &#123; done() /*这里调用done()触发@after-enter事件*/ &#125;,4000) &#125;, handAfterEnter: function(el)&#123; el.style.color = &apos;black&apos; &#125; &#125; &#125;)&lt;/script&gt; 二、velocity.js实现动画velocity官网 样式部分没有变1234567891011121314151617181920212223242526272829&lt;script src=&quot;velocity.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue(&#123; el: &apos;#root&apos;, data: &#123; show: true &#125;, methods: &#123; handclick: function() &#123; this.show = !this.show &#125;, handleBeforeEnter: function(el) &#123; el.style.opacity = 0; &#125;, handleEnter: function(el,done) &#123; /*done回调函数*/ Velocity(el, &#123; opacity: 1 &#125;,&#123; duration: 1000, complete: done &lt;!-- 当Velocity执行完动画后 后面内容会被自动执行 --&gt; &#125;) &#125;, handAfterEnter: function(el)&#123; alert(&apos;动画结束&apos;) &#125; &#125; &#125;)&lt;/script&gt; Vue中多个元素或组件的过渡一、多个元素中的过渡效果因为vue复用组件的关系，所以要加keymode可以控制动画样式，in-out先显示再隐藏，out-in隐藏再显示1234567891011121314151617&lt;style&gt; .v-enter , .v-leave-to&#123; opacity: 0 &#125; .v-enter-active, .v-leave-active &#123; transition: opacity 1s; &#125;&lt;/style&gt;&lt;div id="root"&gt; &lt;transition mode="out-in" &gt; &lt;!-- mode可以控制动画样式，in-out先显示再隐藏，out-in隐藏再显示 --&gt; &lt;div v-if="show" class="nams" key="hello"&gt;hello world&lt;/div&gt; &lt;div v-else key="bye"&gt;Bye World change Account login&lt;/div&gt; &lt;/transition&gt; &lt;button @click="handclick"&gt;切换&lt;/button&gt;&lt;/div&gt; 二、多个组件间的过渡 动态组件实现过渡效果 动态组件 123456789101112131415161718192021222324252627282930&lt;div id="root"&gt; &lt;transition mode="out-in" &gt; &lt;!-- mode可以控制动画样式，in-out先显示再隐藏，out-in隐藏再显示 --&gt; &lt;component :is="type"&gt;&lt;/component&gt; &lt;!-- 动态组件 --&gt; &lt;/transition&gt; &lt;button @click="handclick"&gt;切换&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.component('child', &#123; template: '&lt;div&gt;child&lt;/div&gt;' &#125;) Vue.component('child-on', &#123; template: '&lt;div&gt;child-on&lt;/div&gt;' &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; type: 'child' &#125;, methods: &#123; handclick: function() &#123; this.type = this.type === 'child' ? 'child-on' : 'child' &#125;, &#125; &#125;)&lt;/script&gt; 5-6、Vue中的列表过渡相当于给每一个标签加了一层自己加了个删除，还不错1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; .v-enter , .v-leave-to &#123; opacity: 0; &#125; .v-enter-active, .v-leave-active &#123; transition: opacity 1s; &#125;&lt;/style&gt;&lt;div id="root"&gt; &lt;transition-group &gt; &lt;div v-for="item of list" :key="item.id"&gt; &#123;&#123;item.title&#125;&#125; &#123;&#123;item.id&#125;&#125; &lt;/div&gt; &lt;/transition-group&gt; &lt;button @click="handclick"&gt;Add&lt;/button&gt; &lt;button @click="remos"&gt;remove&lt;/button&gt;&lt;/div&gt;&lt;script&gt; var count = 0; var vm = new Vue(&#123; el: '#root', data: &#123; list: [] &#125;, methods: &#123; handclick: function() &#123; this.list.push(&#123; id: count ++, title: 'modelist' &#125;) &#125;, remos: function() &#123; console.log(this.list.length) this.list.splice(this.list.length-1,1) &#125; &#125; &#125;)&lt;/script&gt; 5-7 Vue中的动画封装自己用了下velocity.js动画封装动画为什么不能用v-show,搞了半天原来是这个问题，我还以为老师代码有错，插入的内容我没有去v-show,hello world 写成这样了，怪不得错呢12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;script src="velocity.min.js"&gt;&lt;/script&gt;&lt;div id="root"&gt; &lt;fade :show="show" &gt; &lt;div&gt;hello world &lt;/div&gt; &lt;/fade&gt; &lt;button @click="handclick"&gt;mos&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.component('fade', &#123; props: ['show'], template: ` &lt;transition @before-enter="handleBeforeEnter" @enter="handleEnter"&gt; &lt;slot v-if="show"&gt;&lt;/slot&gt; &lt;/transition&gt; `, methods: &#123; handleBeforeEnter: function(el) &#123; el.style.opacity = 0; console.log(1) &#125;, handleEnter: function(el,done) &#123; console.log(2) Velocity(el, &#123; opacity: 1, &#125;,&#123; duration: 1000, complete: done &#125;) &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; show: false &#125;, methods: &#123; handclick: function() &#123; this.show = !this.show &#125; &#125; &#125;)&lt;/script&gt; 5-8 章节小节第5节主要讲解了过渡动画@keyframes动画在vue中通过js如何实现动画同时我们简单的说了下vue和css或者Velocity.js这样的动画库多个元素切换过程中的动画最后是列表动画的内容 课后作业可以参考官方的文档，来完成作业动态过度状态过度 一、动态过渡vue props接收值用data替换,props值改变data值不变？所遇到的问题，还没有解决百度到的答案，深度拷贝google到的，明天看吧 这个代码虽然实现了，但是还有问题，就是props接收的值我直接修改了这个坑留这里把，看看教程后面有解决方法没1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;script src="velocity.min.js"&gt;&lt;/script&gt;&lt;div id="root"&gt; &lt;input type="range" min="0" max="2000" model="500" v-model="indexnames1"&gt; &lt;input type="range" min="0" max="2000" model="500" v-model="indexnames2"&gt; &lt;fade :show="showa" :index1="indexnames1" :index2="indexnames2" &gt; &lt;div&gt;hello world &lt;/div&gt; &lt;/fade&gt; &lt;button @click="handclick"&gt;mos&lt;/button&gt;&lt;/div&gt;&lt;script&gt; Vue.component('fade', &#123; props: ['show','index1','index2'], template: ` &lt;transition @before-enter="handleBeforeEnter" @enter="handleEnter" @leave="hanleave"&gt; &lt;slot v-if="show"&gt;&lt;/slot&gt; &lt;/transition&gt; `, methods: &#123; handleBeforeEnter: function(el) &#123; el.style.opacity = 0; &#125;, handleEnter: function(el,done) &#123; var this_ = this Velocity(el, &#123; opacity: 1, &#125;,&#123; duration: this_.index1, complete: function() &#123; done() this_.show= !this_.show &#125; &#125;) &#125;, hanleave: function(el,done) &#123; var this_ = this Velocity(el, &#123; opacity: 0 &#125;,&#123; duration: this_.index2, complete: function() &#123; done() this_.show= !this_.show &#125; &#125;) &#125; &#125; &#125;) var vm = new Vue(&#123; el: '#root', data: &#123; showa: false, indexnames1: '1000', indexnames2: '1000' &#125;, methods: &#123; handclick: function() &#123; cas: '2' this.showa = !this.showa &#125; &#125; &#125;)&lt;/script&gt; 填坑：用watch监听传入的变化，然后赋值给一个新值，修改此值就可以了，我的天啊，好简单啊，深度拷贝完全不需要，我想多了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869Vue.component('fade', &#123; props: ['show','index1','index2'], data () &#123; return &#123; hide: this.show &#125; &#125;, template: ` &lt;transition @before-enter="handleBeforeEnter" @enter="handleEnter" @leave="hanleave"&gt; &lt;slot v-if="hide"&gt;&lt;/slot&gt; &lt;/transition&gt; `, computed: &#123; // shows: function () &#123; // return this.show // &#125; &#125;, watch: &#123; show: function () &#123; this.hide = this.show &#125; &#125;, methods: &#123; handleBeforeEnter: function(el) &#123; el.style.opacity = 0; &#125;, handleEnter: function(el,done) &#123; var this_ = this Velocity(el, &#123; opacity: 1, &#125;,&#123; duration: this_.index1, complete: function() &#123; done() this_.hide = !this_.hide &#125; &#125;) &#125;, hanleave: function(el,done) &#123; var this_ = this Velocity(el, &#123; opacity: 0 &#125;,&#123; duration: this_.index2, complete: function() &#123; done() this_.hide = !this_.hide &#125; &#125;) &#125; &#125;&#125;)var vm = new Vue(&#123; el: '#root', data: &#123; showa: false, indexnames1: '1000', indexnames2: '1000' &#125;, methods: &#123; handclick: function() &#123; cas: '2' this.showa = !this.showa &#125; &#125; &#125;) 6-1 项目环境准备安装node什么的，我自然都会了，还有git，我用的是桌面端，有机会用用字符的 12345npm install -g vue-clivue init webpack vuecd vuenpm installnpm run dev 6-2项目代码结构介绍项目地址：VueLearn -&gt; VueQuNaEr README.md 项目初始化文件 package.json 项目依赖 package-lock.json 一个锁文件，可以确定安装第三方包的具体版本，保持团队编程的统一 index.html 项目默认首页模板文件 .gitignore 禁止git上传文件 .eslintrc.js js代码规范，必须按照这个规范写 .eslintignore 这里面的目录及文件不会受到eslint规范影响 .editorconfig 规范书写代码 .babeirc 写ES6语法，转换为浏览器可以解析的代码，这个是配置文件 static 存放静态资源，图片，模拟json数据 node_modules src 整个项目源代码 main.js项目入口文件 App.vue 最原始的根组件 router 路由 components 组件 assets 图片类资源 config 文件夹下放的是项目配置文件 index.js 基础配置信息 dev.env.js 开发环境配置信息 prod.env.js 线上环境配置信息 build 项目打包webpack配置内容，一般来说不需要修改一般来说不需要对这些文件修改，我们要做的就是在src源代码目录下进行我们业务代码的开发6-3 单文件组件与Vue中的路由 // 路由就是根据网址的不同，返回不同的内容给用户路由这章没什么好说的，angular的时候就已经很熟了 6-4 多页应用VS单页应用代替a 列表页 服务器渲染可以完美解决单页面中的问题首屏时间稍慢，SEO差 6-5 项目代码初始化1&lt;meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no"&gt; 添加了不允许用户放大缩小的代码 移动端重置代码引入reset.css文件 移动端1像素边框问题引入border.css文件 移动端延迟300秒点击延迟问题 安装第三方模块 npm install fastclick –save import fastClick from ‘fastclick’ fastClick.attach(document.body) iconfont上传代码git 123git add . git commit -m 'project init 'git push 7-1 首页header区域开发四百勒斯类似less，cass安装stylus12npm install stylus --savenpm install stylus-loader --save home拆分成很多部分，在script里面引入就可以了 import HomeHeader from ‘./components/Header’ 样式部分用stylus写，而且是不影响全局作用域 移动端采用rem布局，rem是根据html设置的font-size规定的大小 引入全局的stylus文件，通用样式可以放到这里面，就可以复用了 @import ‘~styles/varibles’ 在style中使用的技巧，加~符号，不然会报错 创建别名webpack.base.conf.js ‘styles’: resolve(‘src/assets/styles’) 修改webpack配置项的时候，一定要重启服务display: flex这个属性很好用，以后应该会经常遇到 7-3首页轮播图分支123git pull 线上的分支拉到本地git checkout index-swiper 切换分支git status 查看分支 轮播插件vue-awesome-swiper1npm install vue-awesome-swiper@2.6.7 --save 全局引入1234567import Vue from 'vue'import VueAwesomeSwiper from 'vue-awesome-swiper'// require stylesimport 'swiper/dist/css/swiper.css'Vue.use(VueAwesomeSwiper, /* &#123; default global options &#125; */) 不懂的css12width: 100%height: 31.25vw == 31.25%相当于宽的 兼容性更高的写法1234width: 100%height: 0overflow: hiddenpadding-bottom: 31.25% 这个比例算法有问题，莫名其妙 鼠标移动到下方5-10像素距离还是可以拖动解决方法参考这个文章，遇到的问题里面也有描述大概就是给html元素添加1touch-action: none; 样式穿透在有scope作用域的style下可以这样给其他页面应用样式12.wrapper &gt;&gt;&gt; .swiper-pagination-bullet-active background: #fff 添加 &gt;&gt;&gt; git提交以及合并123456git addgit commit -m 'change'git pushgit checkout master #切换分支git merge origin/index-swiper #线上内容合并git push 7-4 图标区域页面布局github线上创建分支，拉过来12git pullgit checkout index-icons 7-5 图标区域逻辑实现js真滴神奇，1234567891011pages () &#123; const pages = [] this.iconList.forEach((item, index) =&gt; &#123; const page = Math.floor(index / 8) if (!pages[page]) &#123; pages[page] = [] &#125; pages[page].push(item) &#125;) return pages&#125; 7-6 推荐组件开发本地创建分支123git checkout -b index-recommend //创建并切换到newbranch分支下git push origin index-recommend //推送到远程仓库的newbranch分支下，没有就创建 他是下面命令的简写 12git branch index-recommendgit checkout index-recommend 没什么讲究的，就是一个1234.item-info flex 1 padding .1rem min-width 0 7-7 周末游组件开发Ajax获取首页数据老师切换分支的时候发现一个本地错误123git statusgit checkout . 去除更改git status 这次查看本地分支和线上分支一致 vue中使用ajax fech 浏览器自带函数 vue-resource 官方推荐axios跨平台请求 浏览器端可以帮你发送shr请求 node端可以帮你发送http请求 使用axios1npm install axios --save 开发环境转发Paths这个功能是webpack-dev-server提供的 config/index.js12345678proxyTable: &#123; &apos;/api&apos;: &#123; target: &apos;http://localhost:8080&apos;, pathRewrite: &#123; &apos;^/api&apos;: &apos;/static/mock&apos; &#125; &#125;&#125; 改变配置文件需要重启 首页父子组件数据传递1234567891011121314151617181920methods: &#123; getHomeInfo () &#123; axios.get(&apos;/api/index.json&apos;) .then(this.getHomeInfoSucc) &#125;, getHomeInfoSucc (res) &#123; res = res.data if (res.ret &amp;&amp; res.data) &#123; const data = res.data this.city = data.city this.swiperList = data.swiperList this.iconList = data.iconList this.recommendList = data.recommendList this.weekendList = data.WeekendList &#125; &#125; &#125;, mounted () &#123; this.getHomeInfo() &#125; 8-1城市选择页面路由配置页面a链接替换组件1&lt;router-link to='/city'&gt;&lt;/router-link&gt; 8-2搜索框布局8-3列表布局8-4Better-scroll的使用及字母表布局安装1npm install better-scroll --save 8-5页面动态数据渲染8-6兄弟组件联动1this.scroll.srollToElement() 首先确定自己的位置获得a字母距离顶部高度滑动的时候确定手指位置距离顶部高度做一个差值就能够算出当前手指位置和a顶部的差值，再除以每个字母的高度就可以知道当前是第几个字母了 123456this.startY = this.$refs['A'][0].offsetTopconst touchY = e.touches[0].clientY - 79const index = Math.floor((touchY - this.startY) / 20)if (index &gt;= 0 &amp;&amp; index &lt; this.letters.length) &#123; this.$emit('change', this.letters[index])&#125; 生命周期钩子123updated () &#123; this.startY = this.$refs[&apos;A&apos;][0].offsetTop &#125; 8-7列表切换性能优化函数截留123456timer: nullif (this.timer) &#123; clearTimeout(this.timer)&#125;this.timer = setTimeout(() =&gt; &#123;&#125;,16) 8-8s搜索功能实现1234567891011121314151617181920212223242526272829303132333435363738394041424344import Bscroll from 'better-scroll'export default &#123; name: 'CitySearch', props: &#123; cities: Object &#125;, data () &#123; return &#123; keyword: '', list: [], timer: null &#125; &#125;, computed: &#123; hasNoData () &#123; return !this.list.length &#125; &#125;, watch: &#123; keyword () &#123; if (this.timer) &#123; clearTimeout(this.timer) &#125; if (!this.keyword) &#123; this.list = [] return &#125; this.timer = setTimeout(() =&gt; &#123; const result = [] for (let i in this.cities) &#123; this.cities[i].forEach((value) =&gt; &#123; if (value.spell.indexOf(this.keyword) &gt; -1 || value.name.indexOf(this.keyword) &gt; -1) &#123; result.push(value) &#125; &#125;) &#125; this.list = result &#125;, 100) &#125; &#125;, mounted () &#123; this.scroll = new Bscroll(this.$refs.search) &#125;&#125; 8-9使用vuex实现数据共享vuex Vuex的高级使用及localStorage一些复杂的可以简写要引入vuex模块12345678910111213141516import &#123; mapState, mapMutations &#125; from 'vuex'export default &#123; computed: &#123; ...mapState(&#123; currentCity: 'city' &#125;) &#125;, methods: &#123; handclick (city) &#123; // this.$store.commit('changeCity', city) this.changeCity(city) this.$router.push('/') &#125;, ...mapMutations(['changeCity']) &#125;&#125; 使用keep-alive 优化网页性能1&lt;keep-alive&gt;&lt;/keep-alive&gt; 将内容放到内存中，就不会出现重复请求ajax了 12345678910mounted () &#123; this.lastCity = this.city this.getHomeInfo() &#125;, activated () &#123; if (this.lastCity !== this.city) &#123; this.lastCity = this.city this.getHomeInfo() &#125; &#125; 当有keep-alive的话就会多一个生命周期钩子，activated这个钩子会在页面重新出现的时候执行 原来是ok的，老师的逻辑没问题，我自己搞错了 详情页动态路由及banner布局公用图片画廊组件拆分9-3实现Header渐隐渐显效果js绑定事件。。。好久没用过了123activated () &#123; window.addEventListener(&apos;scroll&apos;, this.handleScroll) &#125; js动画+限制最大值1234567891011121314handleScroll () &#123; const top = document.documentElement.scrollTop if (top &gt; 60) &#123; let opacity = top / 140 //动画原理 opacity = opacity &gt; 1 ? 1 : opacity //限制最大值 this.opacityStyle = &#123; opacity &#125; this.showAbs = false &#125; else &#123; this.showAbs = true &#125; &#125; &#125;, 9-4对全局事件的解绑这个生命周期钩子，在页面关闭时执行1deactivated () &#123;&#125; 9-5 使用递归组件实现详情页列表自己调用自己，太6了原来name主要作用就是递归组件自己调用自己的时候使用 9-6使用ajax获取动态数据1234567&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;keep-alive exclude=&quot;Detail&quot;&gt; &lt;router-view/&gt; &lt;/keep-alive&gt; &lt;/div&gt;&lt;/template&gt; 1exclude=&quot;Detail&quot; 不缓存Detail组件的数据 name到底什么作用，使用递归组件会用到，相对某个页面取消换成可以用到，vue开发组件可以获得name名字 每次进行路由切换显示都会初始化123scrollBehavior (to, from, savedPosition) &#123; return &#123; x:0, y:0 &#125; &#125; 在项目中加入基础动画animation动画 vue项目的接口联调]]></content>
      <categories>
        <category>github项目笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VueLearn]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2FVueLearn%2F</url>
    <content type="text"><![CDATA[Vue 入门项目地址：VueLearn 课程大纲vue2.5入门教程(vueshili (vue实例) ) vue2.5入门教程 ?代表存疑问 总结vue2.5 用过的记一下 12345678910111213141516171819202122232425指令：v-on:简写 @v-bind: 简写:v-for 循环v-text 纯文本v-html 字符串转换为代码v-model 双向数据绑定对象,实例 ?el: 貌似是挂载点 ?data: 数据methods: 方法components: 模板事件：@click 点击事件@delete 自定义事件 ?应该是创建一个&apos;delete&apos;事件 ?this.$emit(&apos;delete&apos;,this.index)@click.native=&quot;&quot; .native 是事件修饰符 安装vue-cli 12npm install -g vue-clivue init webpack &#123;&#123;项目名&#125;&#125; 不懂的css12345box-sizing border-boxdisplay flexflex-direction columnjustify-content center 好的css布局12345678910111213.icons height: 0 padding-bottom: 50% overflow: hidden background: #ccc .icon position relative overflow hidden float: left width: 25% height 0 padding-bottom: 25% background: red 文字超出显示…123overflow: hiddenwhite-space: nowraptext-overflow: ellipsis try catch语法是es6的？123456let defaultCity = &apos;上海&apos;try &#123; if (localStorage.city) &#123; defaultCity = localStorage.city &#125;&#125; catch (e) &#123;&#125; 超出能力范围的es61234567import &#123; mapState &#125; from &apos;vuex&apos;export default &#123; name: &apos;HomeHeader&apos;, computed: &#123; ...mapState([&apos;city&apos;]) //不懂 &#125;&#125; 引入vuex优化代码1234567891011121314151617181920import &#123; mapState, mapMutations &#125; from &apos;vuex&apos;computed: &#123;...mapState(&#123; currentCity: &apos;city&apos;&#125;)&#125;,methods: &#123;...mapMutations([&apos;changeCity&apos;])&#125;this.$store.state.city简写为this.currentCitythis.$store.commit(&apos;changeCity&apos;, city)简写为this.changeCity(city)]]></content>
      <categories>
        <category>github项目笔记</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Template]]></title>
    <url>%2Fblog%2F2018%2F09%2F14%2F%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF%EF%BC%8C%E5%BC%80%E5%8F%91%E5%89%8D%E7%9B%B4%E6%8E%A5%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E5%B0%B1%E8%A1%8C%E4%BA%86%EF%BC%8C%E4%B8%8D%E7%94%A8%E9%82%A3%E4%B9%88%E9%BA%BB%E7%83%A6%2F</url>
    <content type="text"><![CDATA[开发模板，开发前直接下载安装就行了，不用那么麻烦项目地址 ：Template .editorconfig 规范编码格式 .gitignore git 上传忽略列表 gulpfile.js css,js压缩混淆，生成雪碧图，less生成css package.json gulp所有依赖 bower bower search bootstrap 包的查找bower info jquery 查看版本bower update 包的更新 sublime 所用到的sublime插件boxy 主题插件AutofileName 自动补全路径editorconfig 代码书写规范emmetmarkdownEditing markdown高亮table editor markdown表格快速生成 Table Editor: Enable for current syntax 开启 Table Editor: Enable for current view 当前视图开启该功能omniMarkupPreviewer markdown编辑 boxy AutofileName editorconfig emmet table editor omniMarkupPreviewer 主题插件 自动补全路径 代码书写规范 1 表格快速生成 ctrl+alt+o markdown浏览 All Autocomplete kong 而 AllAutocomplete 插件会搜索所有打开的文件来寻找匹配的提示词 sublime插件添加SublimeCodeInteljs提示插件对于Windows： - 跳转到定义= Alt+Click - 跳转到定义= Control+Windows+Alt+Up - 返回= Control+Windows+Alt+Left - 手动代码智能=Control+Shift+space jQueryjquery提示插件 DocBlockr注释插件ctrl+enter 美化/** + tab 或者 space 或者 shift+enter HTML-CSS-JS Prettify代码格式化插件ctrl+shift+h]]></content>
      <categories>
        <category>github项目笔记</category>
        <category>模板</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[音标学习]]></title>
    <url>%2Fblog%2F2018%2F09%2F12%2F%E9%9F%B3%E6%A0%87%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[字母的名称音和发音学习目标:123451.认识26个字母的读音2.了解字母的名称音和发音3.用掐头法学习字母的发音；4.字母a的音标5.学会简单单词的基本拼读 &lt;strong&gt;学习目标：&lt;/strong&gt; 1.认识26个字母的读音 2.了解字母的名称音和发音 3.用掐头法学习字母的发音； 4.字母a的音标 5.学会简单单词的基本拼读 名称音：26个字母当中的第一个字母是 a 字母 读成 A 就是在字母表中的读音 发音：字母在单词中的读音 apple 发原音的第一个 ai apron a 为什么他们发音不一样 ， 因为他们是原音字母, 如果它是一个辅音字母 上面两个单词 P 字母都发 &quot;泼&quot;; &lt;strong&gt;掐头法&lt;/strong&gt; Ff Ll Mm Nn Ss Xx &lt;em&gt;音标符号&lt;/em&gt; /f/ /l/ /m/ /n/ /s/ /ks/ &lt;strong&gt;大BOOS,A的发音&lt;/strong&gt; 每个原因字母发不止一种，今天来学习最平常最普通的发音 02用去尾法学习辅音发音 1.用去尾法学习辅音字母的读音和音标 2.字母e和i的读法和音标 3.辨别a、e、i三个字母的发音不同 4.拼读简单的单词和音标词 /k/ /b/ /s/ /d/ /d3/ /k/ /p/ /t/ Bb Cc Dd Jj Kk Pp Tt /v/ /z/ Vv Zz &lt;strong&gt;元音字母&lt;/strong&gt; e/e/ i/i/ a/蝴蝶结形状/ // 艾 /a/ a /e/ 一Ⅰ /i/ /æ/ &lt;strong&gt;会了么&lt;/strong&gt; 1.a,e,i的发音分别是什么？音标如何写 2.去尾法和掐头法的共同点是什么 03.对比法学习辅音发音 g h y w r /g/ /h/ /j/ /w/ /r/ 浊辅音声带振动 清辅音 声带不震动 学习目标： 1.用对比法学习辅音字母的读音和音标 2.学习原因字母o和u的不同发音和音标 3.学习音标[u]和[a] 4.复习掐头法、去尾法所学习的音标 原因发音： O /ɔ/ O字母有时候也发 /ʌ/ ： son come color love money U /ʌ/ &lt;i&gt;以上统称短元音音标，以下是字母组合&lt;/i&gt; a e i o u 总结：/æ/ /a/ /i/ /ɔ/ /ʌ/ /u/ /Ə/ 尽量不看 ai a yi 欧 阿 wu 额 /ʌ/这个音可能是一个字母，而字母组合有时候会是两个，甚至3个字母合在一起 [u]：look good book foot wood [u:] : food 这个就是长音 [Ə]: ure：picture er: teacher brother dinner 重点 ar:sugar or:doctor 重点 a: panda about 第三节18分钟有前面学的老师带读 重新开始/i/ please see meat believe/I/ this difficult if dinner/ei/ late gate baseball stay ok/ɛ/ bed men dread friend/æ/ man apple stand angry]]></content>
      <categories>
        <category>音标</category>
      </categories>
      <tags>
        <tag>english</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node+mongodb+nginx+linux]]></title>
    <url>%2Fblog%2F2018%2F09%2F11%2Fnode%E9%A1%B9%E7%9B%AE%E7%9A%84%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[node项目的部署项目地址：Node+mongodb+nginx+linux本次服务器为centos，只是临时在虚拟机建立的，虚拟机密码为1004041672696px网站的部署以及linux一些命令记录，还有nginx是怎么用的，到底是个什么东西 4-1~2通过ssh实现无密码登陆客户机123456789pwdcd /user/demoorbug | cd ~找到是否有.ssh这个文件夹如果有id_rsa id_rsa.pub(公钥)就是说明配置过,如果需要进行下面的的步骤的话最好改名再继续ssh-key -t rsa -b 4096 -C "465298643@qq.com"虽然不知道为什么要敲这个命令接下来是把这个ssh代理开起来eval "$(ssh-agent -s)"ssh-add ~/.ssh/id_rsa 加入代理最终目的呢就是拿到id_rsa 进入linux终端12345输入和windows一样的命令要把windows上的公钥内容粘贴到 linux的authorized_keys下但是还是要有几个动作来完成，首先是授权chmod 600 authorized_keyssudo service ssh restart 可以google “get id_rsa” 生成公钥和私钥这个没搞明白 以上方法我是没搞定参考文献centos怎么配置ssh免密码 我就有点晕，明明可以很简单的ssh-keygen 为什么要那么麻烦呢，秀操作啊老师MMP 5-1~2增加服务器安全性 如果你买了一个服务器没有修改的话登陆端口就是22虽然不知道你的用户名但是出于安全性考虑还是得修改这个 12345centos里面呢必须在防火墙中添加此端口不然还是访问不了vi /etc/sysconfig/iptablesservice iptables restartsudo vi /etc/ssh/sshd_configPort 31281 1ssh -p 31281 root@192.168.0.119 增加安全性参考文章 修改端口、禁止root用户登陆 什么都不用添加，更改用户权限就行了。 12345gpasswd -a imooc sudosudo visudo 在root ALL=(ALL) ALL下添加相同参数只需要修改用户名即可 好像也有个目录是sudoers查到了在/etc/sudoers 目录下 port 范围0~65536 但是0~1024最好不要使用，而且是必须用root身份启动. 1024~65536选择使用 关闭root登陆权限，禁止密码登陆，禁止空密码 123PermitRootLogin no 禁止rootPermitEmptyPasswords no 禁止空密码passwordAuthentication no 禁止密码登陆 ctrl+a 回到行首 ctrl+e 回到行尾 配置iptables Fail2Banyum (rpm) 和 apt-get的对应关系1234sudo apt-get update -y | sudo apt-get upgrade -yyum makecache | yum updatesudo iptables -F iptables.up.rules 此文件里面内容如下 123456789101112131415161718192021222324252627282930313233343536373839*filter# 允许所有建立起来的链接# allow all connections-A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT# 允许所有出去的流量#allow out traffic-A OUTPUT -j ACCEPT# 允许https这样下的链接#allow http https-A INPUT -p tcp --dport 443 -j ACCEPT-A INPUT -p tcp --dport 80 -j ACCEPT# ssh登陆方式建立通道#allow ssh port login-A INPUT -p tcp -m state --state NEW --dport 31281 -j ACCEPT# 方便测试服务器有没有停机，都是通过ping这种方式#ping-A INPUT -p icmp -m icmp --icmp-type 8 -j ACCEPT# 日志#log denied calls-A INPUT -m limit --limit 5/min -j LOG --log-prefix &quot;iptables denied:&quot; --log-level 7# 敏感规则对于恶意访问ip拦截#drop incoming sensitive connections-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --set#-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 --hitcount 150 -j DROP 这段代码有问题 现在没搞懂这个配置文件所以也解决不了 失望-A INPUT -p tcp --dport 80 -i eth0 -m state --state NEW -m recent --update --seconds 60 -j DROP# 禁止所有其他进入服务器流量#reject all other inbound-A INPUT -j REJECT-A FORWARD -j REJECTCOMMIT 12345678910111213141516171819sudo iptables -F 不知道什么意思啊 反正搞出来了(经过深入学习这是一条清空防火墙规则的命令)sudo iptables-restore &lt; /etc/iptables.up.rulessudo service iptables status 关闭虚拟机防火墙：关闭命令： service iptables stop永久关闭防火墙：chkconfig iptables off两个命令同时运行，运行完成后查看防火墙关闭状态service iptables status1 关闭防火墙-----service iptables stop 2 启动防火墙-----service iptables start 3 重启防火墙-----service iptables restart 4 查看防火墙状态--service iptables status 5 永久关闭防火墙--chkconfig iptables off 6 永久关闭后启用--chkconfig iptables on 创建sh脚本 每次重启后自己输入sudo iptables-restore &lt; /etc/iptables.up.rules 123456sudo vi /etc/sysconfig/if-up.d/iptables内容：#!/bin/shiptables-restore /etc/iptables.up.rules给执行权限sudo chmod +x iptables 搞了几个小时02点17分 居然把iptables弄没见了？明天重新创建吧RLG重新安装，重新来了一遍更熟练了Fail2ban源码安装方法 源码安装 1234wget https://github.com/fail2ban/fail2ban/archive/0.9.3.tar.gztar -xzvf 0.9.3.tar.gzcd fail2ban-0.9.3python setup.py install 说实话 fail2ban这里了 00点55分 睡觉去了 明天下载ubuntu把 能把我累死，我也是醉了经研究，还是用ubuntu系统把 重新记录新命令，以上均为centos命令防火墙12345678和上面方法类似只不过命令有所改变sudo ufw status 查看防火墙状态sudo ufw enable 开启防火墙sudo ufw disable 关闭防火墙每次更改/etc/iptables.up.rules都要重新sudo iptables-restore &lt; /etc/iptables.up.rules Fail2ban12345678910111213sudo apt-get install fail2bansudo vi /etc/Fail2ban/jail.conf 以下都更改 # bantime = 600 bantime = 3600 改为自己邮箱 destemail = 1004041672@qq.com #action = %(action_)s 搞不懂为什么要加mw action = %(action_mw)s sudo service fail2ban status 查看状态 想要停掉 stop就好了 以上都是一些基础性的比较简单的安全配置，这些配置呢都算是基础之劳，但是可以让一台裸的服务器大大提高安全防护等级，虽然防护等级不够，但是抵御一些基础的东西还是ok的，想做更高级的东西需要做很多运维知识的储备，比如说可以给生产的服务器登陆设置ip的绑定或者是限制，只有特定内网的机器才能登陆这台服务器， 也就是通俗所讲的在内网假设一台跳板机 ，通过本地电脑连接跳板机再从跳板机登陆到服务器， 6-1~2开始搭建环境了 呜呜呜呜呜 终于到了123456789101112131415161718192021222324252627282930313233343536373839404142434445464748首先再更新一边sudo apt-get update安装模块/包文件安装了一大堆有些认识有些没见过sudo apt-get install vim openssl build-essential libssl-dev wget curl git到github 找到 nvm 下面有两种安装方式 wget curl 我们复制wget 建议安装好后再打开一个终端操作nvm install v6.9.5 为什么安装的是node呢？nvm use v6.9.5nvm alias default 默认让系统里面的版本就是这个版本？难道是不让升级？因为国内的原因，用npm太慢或者链接不上，改为淘宝的镜像下载npm --registry=https://registry.npm.taobao.org install -g npm原来npm -v可以查看这个镜像的更新程度啊 哈哈哈 老师视频的版本是4.2.0 目前2018-1-14版本号是5.6.0增加系统文件监控次数echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf &amp;&amp; sudo sysctl -p 安装cnpm 有时候npm拉取不到的东西可以去cnpm下载，网速不行还是使用npmnpm --registry=https://registry.npm.taobao.org install -g cnpmcnpm sync koa 同步一下 koa框架就会强制把国外的模块拿到国内去安装全局工具包npm i pm2 webpack gulp grunt-cli -gvi app.js 内容如下 const http = require(&apos;http&apos;) http.createServer(function(req,res)&#123; res.writeHead(200,&#123;&apos;Content-Type&apos; : &apos;text/plain&apos;&#125;) res.end(&apos;来自慕课的力量&apos;) &#125;).listen(8080) console.log(&apos;server runing on http://192.168.0.121:8080&apos;) 80端口好像被占用了或者被禁用了 改成了8080但是我是内网服务器，不能再公网访问到，很蛋疼node app.jssudo vi /etc/iptables.up.rules#allow http https下增加一行格式一样更改端口号即可sudo iptables-restore &lt; /etc/iptables.up.rules然后就可以通过ip+端口的方式访问到服务器上返回的纯文本不过这样的话 ctrl+c 就会结束服务而且出现错误的话服务直接就停止了，所以我们需要用到pm2管理nodepm2 start app.jspm2 list 查看本台服务器跑的服务pm2 show app 更加详细的一个展示 这里是名字所以app.js不行pm2 logs 查看实时日志 哇咔咔咔咔 原来用node搭建好就可以访问了啊 啊？？？？？？？？WDMY 下节预告 我们想要通过不带端口号的ip或者域名直接访问到80端口的服务，但是现在的用户权限又不足以让我们再80端口进行监听 下一节使用nginx来实现更加魔法的效果7-1.mp4nginx 这里介绍下为什么要用到nginx，以及nginx的主要作用 12原因是为什么的demoobug用户下node是不具备root的运行权限的，所以不能监听0~1024之间的任何一个端口，当然也包括80端口，如果强制通过sudo的话来启动node服务也不是不可以一个是需要额外的配置，一个是我们去放大node的一个权限，这多少会带来一些额外的风险和成本，我们先不通过域名来访问，先直接通过ip来达到访问的效果的话，怎么做呢：我们就需要引入nginx用root级别的权限来启动对80端口的监听，同时吧80端口的流量分配给node服务的另一个端口实现这种服务的代理，如何服务器只需要一个网站程序的话，那解析网站到服务器的一个网址，网站程序监听80端口就可以了，如果是服务器有很多个应用，借助nginx的话不仅可以实现端口的代理，还可以实现负载均衡，让他来判断是来自哪个域名或者是来自IP的一个访问，可以根据配置的规则来准发给特定的端口，或者是特定的某几台机器，在我们这个案例中就是将80端口的请求转发到node启动的8080端口来处理 12345678910111213141516171819202122232425262728293031323334353637383940414243444546sudo service apache2 stop sudo service apache stop 有些服务器会预装apache 暂停估计是有冲突？还是端口冲突？update-rc.d -f apache2 remove 再来试试卸载 Removing any system startup links for /etc/init.d/apache2 ... 这个的意思是有吗？sudo apt-get remove apache2 然后再移除apache2 还真的有。。。sudo apt-get update 然后更新包列表。。。sudo apt-get install nginx nginx -v 稳定版本1.4.6 cd /etc/nginx/conf.d sudo vi 696px-com-8080.conf 一目了然 配置内容 upstream 696px &#123; server 127.0.0.1:8080; &#125; server &#123; listen 80; server_name 192.168.43.7; location / &#123; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forward-For $proxy_add_x_forwarded_for; proxy_set_header Host $http_host; proxy_set_header X-Nginx-Proxy true; proxy_pass http://696px; proxy_redirect off; &#125; &#125;sudo nginx -s reloadsudo vi /etc/nginx/nginx.conf# server_tokens off; 取消注释sudo service nginx reload 就好了这样浏览器返回的头信息就service就是nginx了 没有了更详细的nginx 1.4.6(ubuntu) 好好回顾一下前面的东西，以后部署项目的话心里有点B数 8-1~2主要就是域名解析以及七牛云的用法(七牛云耶终于找到可以用的地方了，第一次接触也不知道是啥时候？) 就是不知道DNSPOD比域名厂商免费提供的解析好多少。 9 1-2安装mongoDB 老师说可以购买一个现成的服务器，但是我这毕竟自己用，那样的话成本太大 google搜索 install mongodb on ubuntu 找到后将manual改为V3.4(当然我没改了喽) 1234567891011sudo vi /etc/apt/apt.conf 这个里面是阿里云镜像会导致安装失败，这里要注释掉(当然我的服务器是虚拟机的就不存在这样的问题) Acquire::http::Proxy &quot;http://mirrors.aliyun.com&quot;;sudo apt-get install -y mongodb-org如果嫌下载速度慢的话可以终止掉去sudo vi /etc/apt/sources.list.d/mongodb-org-3.6.list 把镜像地址修改为阿里云的原：deb [ arch=amd64 ] https://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.6 multiverse替：deb [ arch=amd64 ] https://mirrors.aliyun.com/mongodb/apt/ubuntu trusty/mongodb-org/3.6 multiversesudo service mongod start 开启服务cat /var/log/mongodb/mongod.log 检查是否开启成功 然而发现mongo命令启动不了，发现是防火墙问题修改 /etc/iptables.up.rules123# mongodb connect-A INPUT -s 127.0.0.1 -p tcp --destination-port 27017 -m state --state NEW,ESTABLISHED -j ACCEPT-A OUTPUT -d 127.0.0.1 -p tcp --source-port 27017 -m state --state ESTABLISHED -j ACCEPT sudo iptables-restore &lt; /etc/iptables.up.rules 必须执行此条命令才可生效 全世界的人都知道mongodb跑在27017端口所以要修改1234sudo vi /etc/mongod.conf 修改为8081然后更新防火墙原来修改后还要指定？那修改的意义是什么呢mongo --port 8081 打包1tar zcvf linux.tar.gz linux 本地文件上传linux1scp -P 31281 ./linux.tar.gz demoorbug@192.168.1.106:/home/demoorbug/dbbackup 解压1tar xvf linux.tar.gz 备份数据库1mongodump -h 127.0.0.1:27017 -d 696px -0 696px.app.backup 导入mongodb数据库123mongorestore -p 8081 -d 696px ./dbbackup/696px.app.backup/696px上面的命令报错了mongorestore --host 127.0.0.1:8081 -d 696px ./dbbackup/696px.app.backup/696px 查看数据库是否导入成功12345678mongoshow dbsuse 696pxshow tablesdb.creations.find(&#123;&#125;)db.users.find(&#123;&#125;) 导出单表数据1mongoexport -d imooc-movie -c users -q &apos;&#123;&quot;name&quot;:&#123;&amp;ne:null&#125;&#125;&apos; -o ./movie-users.json 导入单表数据1mongoimprot --host 127.0.0.1:8081 -d 696px -c users ./movie-users.json 删除已有数据库1mongo --host 127.0.0.1:8081 696px --eval &quot;db.dropDatabase()&quot; 管理mongodb安全性 最好是再数据库导入后再增加安全性 进入mongo12345678910111213141516use admindb.createUser(&#123;user: &apos;696px_cases_owner&apos;,pwd: &apos;1004041672&apos;,roles: [&#123;role:&apos;userAdminAnyDatabase&apos;, db:&apos;admin&apos;&#125;]&#125;) 越复杂越好db.auth(&apos;696px_cases_owner&apos;,&apos;1004041672&apos;) 进行用户授权 1代表授权成功use 696ppppdb.createUser(&#123;user: &apos;696pppp-runner&apos;,pwd: &apos;1004041672&apos;,roles: [&#123;role:&apos;readWrite&apos;, db:&apos;696pppp&apos;&#125;]&#125;) 拥有读写权限db.createUser(&#123;user: &apos;696pppp-wheel&apos;,pwd: &apos;1004041672&apos;,roles: [&#123;role:&apos;read&apos;, db:&apos;696pppp&apos;&#125;]&#125;) 拥有读权限 以上密码最好都不一样然后要切换到admin 用admin用户授权use admindb.auth(&apos;696px_cases_owner&apos;,&apos;1004041672&apos;) 打开mongod配置文件修改security:12345678security: authorization: &apos;enabled&apos;重启service mongod restartmongo --port 8081use admindb.auth(&apos;696px_cases_owner&apos;,&apos;1004041672&apos;) 直接进入数据库 带有操作权限的那种123mongo 127.0.0.1:8081/admin -u 696px_cases_owner -p 1004041672这样就可以直接进去了。。 2018/1/21/01点39分 睡觉睡觉 溜了溜了 9-3~6迁移数据库 如果服务器上线后有密码的如何导入导出呢？其实大家搜索一下官网的话就能自己摸索出来 12]]></content>
      <categories>
        <category>github项目笔记</category>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
        <tag>mongodb</tag>
        <tag>nginx</tag>
        <tag>linux</tag>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[blog建站流程]]></title>
    <url>%2Fblog%2F2018%2F09%2F11%2Fblog%E5%BB%BA%E7%AB%99%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[技术栈hexo + travis-ci + hexo next 主题hexo 快速搭建博客hexo建blog很简单 流程： 123npm install hexo-cli -gnpm install hexo-deployer-git --save hexo-cli 安装hexohexo-deployer-git 是一个git组件，用到hexo d 时候没有的话，会报错 123456789hexo init blog #创建hexo环境的blog目录cd blog #进入blog目录hexo clean #清楚缓存，虽然第一次没缓存，但是后续会有，加上没有错的hexo g #生成静态文件，其实直接可以下一步命令的，要是将文件发布到github还是要进行这一步hexo s #创建一个http://localhost:4000的访问目录，修改配置文件css，html都不需要重启访问(我踩的坑，填一下) 以上就可以搭建出来一个blog github发布自己的线上项目 使用travis-ci的话，可以跳过这一步 配置git密钥 123456cd ~ #切换根目录ssh-key -t rsa -b 4096 -C "465298643@qq.com" #换成自己的邮箱#一路回车就会创建.ssh目录cd .ssh/ #查看clip &lt; ~/.ssh/id_rsa.pub #拷贝公钥 打开打开github这里默认你已经有了github账户，没有的话自行百度注册教程 点击自己的头像 -&gt; Settings -&gt; SSH and GPG keys -&gt; New SSH key -&gt; 粘贴刚才拷贝的公钥 测试 1234ssh -T git@github.com #不用修改什么，直接粘贴就行git config --global user.name "DEBUG" #随便用户名git config --global user.email "*******@qq.com" #填写自己的邮箱(随便什么邮箱) 这样就ok了。然后创建一个仓库，这里就不写了，网上很详细的 打开本地主配置文件 blog/_config.yml 1234567url: demoorbug.github.io/blog #更改成你项目的目录deploy: type: git repo: git@github.com:DemoorBug/blog.git #github仓库地址，就是你创建仓库的地址，可以打开github进入仓库点击绿色按钮clone or download -&gt; Use SSH branch: gh-pages # github分支 打开命令行进入本地blog目录输入 12hexo g # 生成静态文件hexo d #部署网站到你的github 主题美化，我用的hexo-theme-nex 主题先进入我们的blog目录123git clone https://github.com/iissnan/hexo-theme-next themes/nexttheme: next 打开主配置文件 _config.yml修改参数为:theme: next然后执行一下代码12345hexo clean #清除缓存hexo g #生成静态文件hexo s #预览hexo d #部署线上 浏览器输入 http://localhost:4000/ next主题官网 hexo发布文章1234hexo new blog #生成一个.md文件，编写后可以hexo g直接生成静态文件，要是你启用了hexo s 就不用那么麻烦了，直接刷新网页就可以了#如果删除了blog\source\_posts\*.md 网站还没有更新，可以输入下面的代码hexo clean 这个生成的.md文件模板可以自定义，目录 blog/scaffolds/post.md google没找到，自己找了半天，才发现 明天继续，今天有点晚了，9/13/03点18分，为什么把这篇文章设置到9/11呢，因为建站的时候就是这个时间，这篇文章也是本站第一篇手写文章，所以时间弄早一点，文章排序就会是第一篇，纪念一下 更换代码高亮]]></content>
      <tags>
        <tag>hexo</tag>
        <tag>travis-ci</tag>
      </tags>
  </entry>
</search>
